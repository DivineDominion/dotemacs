#+STARTUP: hideblocks
#+OPTIONS: num:nil
#+LANGUAGE: en
#+TITLE: Farlado's Emacs

* Installation
** Summary
1) Make sure you have all the right dependencies.
2) Clone the repo into your home directory as ~.emacs.d~.
** Dependencies
Everything has different dependencies so make sure you have what you need. The easy route to getting all these dependencies installed and configured is to deploy [[https://github.com/farlado/dotfiles][my dotfiles]]:
#+BEGIN_SRC sh
  sh -c "$(curl https://farlado.xyz/deploy)"
#+END_SRC
*** EXWM
- Painfully obvious here: ~xorg~
- Always hiding the cursor while typing: ~xbanish~
- Compositor: ~xcompmgr~
- Network Configuration: ~nm-connection-editor~
- Web Browser: ~firefox~
- Editing Crappy Documents: ~libreoffice~
- Crappy Image Editor: ~gimp~
- Crappy Messenger: ~telegram~
- Crappier Messenger: ~discord~
- Games Platform: ~steam~
*** desktop-environment
- For volume control: ~alsa-utils~
- For brightness control: ~brightnessctl~
- For screenshots: ~maim~
- For copying screenshots: ~xclip~
- For locking the screen: ~i3lock-color~
*** EMMS
- For playing music: ~mpd~, ~mpc~
- For playing video: ~mpv~
*** nov
- To open epub files: ~ebook-tools~
*** graphviz-dot-mode
- To process dot files: ~graphviz~
*** flyspell-mode
- Spell checking: ~aspell~
- Dictionaries I use: ~aspell-en~
*** wttrin
- To grab weather data: ~curl~
*** sudo-edit
- Obvious dependency: ~sudo~
*** Other stuff
- Checking for a window manager: ~wmctrl~
- For Python: ~pylint~, ~jedi~
- For Haskell: ~stack~
* Startup
** Start Emacs server
Although I technically don't /have/ to do this, it is very helpful.
#+BEGIN_SRC emacs-lisp
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+END_SRC
** Enable UTF-8 encoding
I probably don't have to do this but it makes things work a little smoother.
#+BEGIN_SRC emacs-lisp
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC
** Always load newest byte code
Ensures everything works as intended.
#+BEGIN_SRC emacs-lisp
  (setq load-prefer-newer t)
#+END_SRC
** async package (asynchronous stuff)
This should make a few different things a little faster when packages are being handled.
#+BEGIN_SRC emacs-lisp
  (use-package async
    :ensure t
    :defer t
    :init
    (dired-async-mode 1)
    (async-bytecomp-package-mode 1)
    (setq async-bytecomp-allowed-packages '(all)))
#+END_SRC
** dashboard package (replacement start screen)
I love the default start screen, but it just doesn't cut it for me. I just use this to have a nice screen when I start Emacs or close all my buffers.
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :defer t
    :init
    (setq inhibit-start-menu t
	  dashboard-items '((recents . 10))
	  show-week-agenda-p t
	  dashboard-banner-logo-title "Welcome to GNU Emacs"
	  dashboard-set-footer nil
	  initial-buffer-choice (lambda ()
				  (get-buffer "*dashboard*")))
    (dashboard-setup-startup-hook))
#+END_SRC
** auto-package-update package (self-explanatory)
I don't want to have to manually update my stuff. This solution is literally plop-and-forget.
#+BEGIN_SRC emacs-lisp
  (use-package auto-package-update
    :ensure t
    :defer t
    :init
    (require 'auto-package-update)
    (setq auto-package-update-interval 2
	  auto-package-update-delete-old-versions t
	  auto-package-update-hide-results t)
    (auto-package-update-maybe))
#+END_SRC
* Making Emacs a Desktop Environment
Yes, Emacs is my *entire desktop environment*. You should probably remove this stuff if you don't plan to use Emacs as your desktop environment. It's loaded right after the startup commands so that I can bind keys more easily later on. I sometimes have to run Emacs in Windows, so I really don't want this running when I'm not in an X window system. I also conveniently check whether there's already a running window manager, but I don't export the code blocks related to that for cleanliness.
#+BEGIN_SRC emacs-lisp :exports none
  (when run-emacs-as-desktop-environment?
    (set-frame-parameter nil 'fullscreen 'fullboth)
#+END_SRC
** Configuration
*** exwm package (base window manager)
This isn't actually where we do all the configuration, it's just where we install EXWM and load what we need to configure it.
#+BEGIN_SRC emacs-lisp
  (use-package exwm
    :ensure t
    :defer t
    :init
    (require 'exwm)
    (require 'exwm-randr)
    (require 'exwm-config)
    (require 'exwm-systemtray))
#+END_SRC
*** dmenu package (dmenu but for Emacs)
Since I'm using Emacs as a window manager, I need ~dmenu~ so I can open X windows I haven't bound to keys. It will be bound elsewhere.
#+BEGIN_SRC emacs-lisp
  (use-package dmenu
    :ensure t
    :defer t)
#+END_SRC
*** system-packages package (manage system packages in Emacs)
This one is a pleasant surprise to have honestly. Having Emacs handle system packages as well as its own is a very pleasant surprise. Since I use ~yay~ on Arch, I configure an entry for it and use it if it's installed.
#+BEGIN_SRC emacs-lisp
  (use-package system-packages
    :ensure t
    :defer t
    :init
    (when (executable-find "yay")
      (require 'system-packages)
      (add-to-list 'system-packages-supported-package-managers
		   '(yay .
			 ((default-sudo . nil)
			  (install . "yay -S")
			  (search . "yay -Ss")
			  (uninstall . "yay -Rs")
			  (update . "yay -Syu")
			  (clean-cache . "yay -Sc")
			  (log . "car /var/log/pacman.log")
			  (get-info . "yay -Qi")
			  (get-info-remote . "yay -Si")
			  (list-files-provided-by . "yay -Ql")
			  (verify-all-packages . "yay -Qkk")
			  (verify-all-dependencies . "yay -Dk")
			  (remove-orphaned . "yay -Rns $(yay -Qtdq)")
			  (list-installed-packages . "yay -Qe")
			  (list-installed-packages-all . "yay -Q")
			  (list-dependencies-of . "yay -Qi")
			  (noconfirm . "--noconfirm"))))
      (setq system-packages-use-sudo nil
	    system-packages-package-manager 'yay))
    :bind (("C-c p i" . system-packages-install)
	   ("C-c p e" . system-packages-ensure)
	   ("C-c p u" . system-packages-update)
	   ("C-c p r" . system-packages-uninstall)
	   ("C-c p o" . system-packages-remove-orphaned)
	   ("C-c p c" . system-packages-clean-cache)
	   ("C-c p l" . system-packages-log)
	   ("C-c p s" . system-packages-search)
	   ("C-c p g" . system-packages-get-info)
	   ("C-c p d" . system-packages-list-dependencies-of)
	   ("C-c p f" . system-packages-list-files-provided-by)
	   ("C-c p p" . system-packages-list-installed-packages)
	   ("C-c p f" . system-packages-verify-all-dependencies)
	   ("C-c p v" . system-packages-verify-all-packages)))
#+END_SRC
*** desktop-environment package (take a guess what it does)
Previously I had to define a lot of functions to do these things, now I just change settings within ~desktop-environment~.
#+BEGIN_SRC emacs-lisp
  (use-package desktop-environment
    :ensure t
    :defer t
    :init
    (require 'desktop-environment)
    (desktop-environment-mode 1))
#+END_SRC
**** Volume adjustment
The only things I really don't like here are how much output it gives when you mute or unmute the speakers or microphone, so I set up basic scripts to give much more concise output.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-volume-toggle-command
	(concat "[ \"$(amixer set Master toggle | grep off)\" ] "
		"&& echo Volume is now muted. | tr '\n' ' ' "
		"|| echo Volume is now unmuted. | tr '\n' ' '")
	desktop-environment-volume-toggle-microphone-command
	(concat "[ \"$(amixer set Capture toggle | grep off)\" ] "
		"&& echo Microphone is now muted. | tr '\n' ' ' "
		"|| echo Microphone is now unmuted | tr '\n' ' '"))
#+END_SRC
**** Brightness adjustment
This one all I needed to do was change the increment and decrement values.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-brightness-normal-increment "5%+"
	desktop-environment-brightness-normal-decrement "5%-")
#+END_SRC
**** Screenshots
This one was the least straightforward because the way it's implemented by ~desktop-environment~ is *SUPER* wonky. Here are the binds which will be relevant.
#+BEGIN_SRC emacs-lisp
  ;; Storing to clipboard
  (define-key desktop-environment-mode-map (kbd "<print>")
    'farl-de/desktop-environment-screenshot-part-clip)
  (define-key desktop-environment-mode-map (kbd "<S-print>")
    'farl-de/desktop-environment-screenshot-clip)

  ;; Storing to file
  (define-key desktop-environment-mode-map (kbd "<C-print>")
    'farl-de/desktop-environment-screenshot-part)
  (define-key desktop-environment-mode-map (kbd "<C-S-print>")
    'farl-de/desktop-environment-screenshot)
#+END_SRC
First, I set what directory to store screenshots in.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-screenshot-directory "~/screenshots")
#+END_SRC
Then, I can set the commands for taking a full or partial screenshot and saving it to a file.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-screenshot-command
	"FILENAME=$(date +'%Y-%m-%d-%H:%M:%S').png && maim $FILENAME"
	desktop-environment-screenshot-partial-command
	"FILENAME=$(date +'%Y-%m-%d-%H:%M:%S').png && maim -s $FILENAME")
#+END_SRC
The functions which ~desktop-environment~ comes with are kinda garbage, so I made my own.
#+BEGIN_SRC emacs-lisp
  (defun farl-de/desktop-environment-screenshot ()
    "Take a screenshot and store it in a file."
    (interactive)
    (desktop-environment-screenshot)
    (message "Screenshot saved in ~/screenshots."))

  (defun farl-de/desktop-environment-screenshot-part ()
    "Take a capture of a portion of the screen and store it in a file."
    (interactive)
    (desktop-environment-screenshot-part)
    (message "Screenshot saved in ~/screenshots."))

  (defun farl-de/desktop-environment-screenshot-clip ()
    "Take a screenshot and put it in the clipboard."
    (interactive)
    (shell-command (concat desktop-environment-screenshot-command
			   " && xclip $FILENAME -selection clipboard "
			   "-t image/png &> /dev/null && rm $FILENAME"))
    (message "Screenshot copied to clipboard."))

  (defun farl-de/desktop-environment-screenshot-part-clip ()
    "Take a shot of a portion of the screen and put it in the clipboard."
    (interactive)
    (shell-command (concat desktop-environment-screenshot-partial-command
			   " && xclip $FILENAME -selection clipboard "
			   "-t image/png &> /dev/null && rm $FILENAME"))
    (message "Screenshot copied to clipboard."))
#+END_SRC
**** Lock screen
Haha yes, this is very long and very very stupid.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-screenlock-command
	(concat "i3lock -nmk --color=000000 --timecolor=ffffffff --datecolor=ffffffff "
		"--wrongcolor=ffffffff --ringcolor=00000000 --insidecolor=00000000 "
		"--keyhlcolor=00000000 --bshlcolor=00000000 --separatorcolor=00000000 "
		"--ringvercolor=00000000 --insidevercolor=00000000 --linecolor=00000000 "
		"--ringwrongcolor=00000000 --insidewrongcolor=00000000 --timestr=%H:%M "
		"--datestr='%a %d %b' --time-font=Iosevka --date-font=Iosevka "
		"--wrong-font=Iosevka --timesize=128 --datesize=64 --wrongsize=32 "
		"--time-align 0 --date-align 0 --wrong-align 0 --indpos=-10:-10 "
		"--timepos=200:125 --datepos=200:215 --wrongpos=200:155 --locktext='' "
		"--lockfailedtext='' --noinputtext='' --radius 1 --ring-width 1 "
		" --veriftext='' --wrongtext='WRONG' --force-clock"))
#+END_SRC
*** Workspace configuration
No clue why you have to do so much just to give workspaces names, but at least you can do it. I also put which monitors to try to put workspaces onto here, alongside a few other useful settings for which windows should float and which workspaces they should be on.
#+BEGIN_SRC emacs-lisp
  (setq exwm-workspace-number 3
	exwm-workspace-index-map (lambda (index)
				   (let ((named-workspaces ["1" "2" "3"]))
				     (if (< index (length named-workspaces))
					 (elt named-workspaces index)
				       (number-to-string index))))
	exwm-randr-workspace-output-plist '(0 "LVDS1"
					    0 "eDP-1-1"
					    0 "DP-1-2-2"
					    1 "DP-1-2-1"
					    2 "DP-1-2-3")
	exwm-manage-configurations '(((string= exwm-class-name "Steam")
				      workspace 0 floating t floating-mode-line nil)
				     ((string= exwm-instance-name "telegram")
				      workspace 2)
				     ((string= exwm-class-name "discord")
				      workspace 1)
				     ((string= exwm-title "Event Tester")
				      floating t)))
#+END_SRC
*** Multi-head
There was a point where I tried to make this into an Elisp function. Not trying that insanity again.
#+BEGIN_SRC emacs-lisp
  (defun display-and-dock-setup ()
    "Configure monitors and peripherals."
    ;; Monitors (works on both my X230 and my W541)
    (let* ((connected-monitors (split-string
		      (shell-command-to-string
		       "xrandr | grep ' connected' | awk '{print $1}'")))
	   (possible-monitors (if (member "LVDS1" connected-monitors)
				  '("LVDS1" "VGA1")
				'("eDP-1-1" "DP-1-2-1" "DP-1-2-2" "DP-1-2-3" "VGA-1-1")))
	   (command "xrandr "))
      (dolist (monitor possible-monitors)
	(if (member monitor connected-monitors)
	    (if (not (and (string= monitor "eDP-1-1")
		      (member "DP-1-2-1" connected-monitors)))
		(let* ((output (concat "--output " monitor " "))
		       (primary (when (or (string= monitor "LVDS1")
					 (string= monitor "eDP-1-1")
					 (string= monitor "DP-1-2-2"))
				  "--primary "))
		       (rate (when (string= monitor "DP-1-2-2")
			       "--rate 75 "))
		       (res (concat "--mode "
				    (if (or (string= monitor "LVDS1")
					   (string= monitor "VGA1"))
					"1366x768 "
				      "1920x1080 ")))
		       (rotate (when (or (string= monitor "DP-1-2-1")
					(string= monitor "DP-1-2-3"))
				 (concat "--rotate "
					 (if (string= monitor "DP-1-2-1")
					     "left "
					   "right "))))
		       (pos (concat "--pos "
				    (if (not (or (string= monitor "DP-1-2-2")
					      (string= monitor "DP-1-2-3")))
					"0x0 "
				      (if (string= monitor "DP-1-2-2")
					  "1080x0 "
					"3000x0 ")))))
		  (setq command (concat command output primary rate res rotate pos)))
	      (setq command (concat command "--output " monitor " --off ")))
	  (setq command (concat command "--output " monitor " --off "))))
      (start-process-shell-command
       "Display Setup" nil command))
    ;; Disable trackpad
    (start-process-shell-command
     "Disable trackpad" nil (concat "xinput disable $(xinput list | "
				    "grep Synaptics | head -n 1 | "
				    "sed -r 's/.*id=([0-9]+).*/\\1/')"))
    ;; Configure trackball
    (let* ((trackball-id (shell-command-to-string
			  (concat "xinput | grep ELECOM | head -n 1 | sed -r "
				  "'s/.*id=([0-9]+).*/\\1/' | tr '\\n' ' '"))))
      (dolist (command '("'libinput Button Scrolling Button' 10"
			 "'libinput Scroll Method Enabled' 0 0 1"))
	(start-process-shell-command
	 "Trackball Setup" nil (concat "sleep 2 && xinput set-prop "
				       trackball-id command)))
      (start-process-shell-command
       "Trackball Setup" nil (concat "sleep 2 && xinput set-button-map " trackball-id
				     "1 2 3 4 5 6 7 8 9 2 1 2")))
    ;; Keyboard
    (start-process-shell-command
     "Keyboard Setup" nil "setxkbmap -option ctrl:nocaps"))

  (add-hook 'exwm-randr-screen-change-hook 'display-and-dock-setup)
  (exwm-randr-enable)
#+END_SRC
*** Name EXWM buffers after the window title
This was annoying when I first installed EXWM. Thankfully this is a very easy fix.
#+BEGIN_SRC emacs-lisp
  (add-hook 'exwm-update-title-hook
	    (lambda ()
	      (exwm-workspace-rename-buffer exwm-title)))
#+END_SRC
*** Ensure Java applications know the WM is non-reparenting
Stolen from the ~.xinitrc~ included with ~EXWM~.
#+BEGIN_SRC emacs-lisp
  (setenv "_JAVA_AWT_WM_NONREPARENTING" "1")
#+END_SRC
*** Configure floating window borders
Uses the same color as my mode line, uses the same width as window divider width. See below.
#+BEGIN_SRC emacs-lisp
  (setq exwm-floating-border-width 3
	exwm-floating-border-color "#335ea8")
#+END_SRC
*** X applications
**** Firefox
Firefox has some unique abilities when it comes to how to make windows behave which work better for me. I don't use tabs, and I don't want anything to do with them, and Firefox lets me hide the tab bar and force all tabs to actually open as new windows.
#+BEGIN_SRC emacs-lisp
  (defun run-firefox ()
    "Start Firefox."
    (interactive)
    (start-process-shell-command
     "Firefox" nil "firefox"))
#+END_SRC
**** LibreOffice
Shame me all you want. I'm still in introductory courses and haven't learned enough Org-mode to use it more meaningfully.
#+BEGIN_SRC emacs-lisp
  (defun run-libreoffice ()
    "Start LibreOffice."
    (interactive)
    (start-process-shell-command
     "LibreOffice" nil "libreoffice"))
#+END_SRC
**** GIMP
Until GIMP's functionality gets merged into Emacs, guess I'm stuck having it.
#+BEGIN_SRC emacs-lisp
  (defun run-gimp ()
    "Start GIMP."
    (interactive)
    (start-process-shell-command
     "GIMP" nil "gimp"))
#+END_SRC
**** Telegram
I have a painfully white theme which fits perfectly with my setup.
#+BEGIN_SRC emacs-lisp
  (defun run-telegram ()
    "Start Telegram."
    (interactive)
    (let ((telegram (if (executable-find "telegram")
			"telegram"
		      (if (executable-find "Telegram")
			  "Telegram"
			(if (executable-find "telegram-desktop")
			    "telegram-desktop")))))
      (start-process-shell-command
       "Telegram" nil telegram)))
#+END_SRC
**** Discord
Yeah, I also use a light theme for Discord. It looks comfy, even if Discord is a garbage application.
#+BEGIN_SRC emacs-lisp
  (defun run-discord ()
    "Start Discord."
    (interactive)
    (start-process-shell-command
     "Discord" nil "discord"))
#+END_SRC
**** Steam
Gaming is possible with EXWM, if you run games windowed.
#+BEGIN_SRC emacs-lisp
  (defun run-steam ()
    "Start Steam."
    (interactive)
    (start-process-shell-command
     "Steam" nil "steam"))
#+END_SRC
*** Other things a DE should probably have
**** Display setup
Calling ~arandr~ to adjust monitors is useful when I am preparing to present something using my computer or need to adjust how monitors are set up in a unique way that isn't a preset from my dotfiles.
#+BEGIN_SRC emacs-lisp
  (defun monitor-settings ()
    "Open arandr to configure monitors."
    (interactive)
    (start-process-shell-command
     "Monitor Settings" nil "arandr"))
#+END_SRC
**** Network Settings
This one uses two windows: one to open the NetworkManager connection editor, and another to list WiFi networks nearby.
#+BEGIN_SRC emacs-lisp
  (defun network-settings ()
    "Open a NetworkManager connection editor."
    (interactive)
    (start-process-shell-command
     "Connections" nil "nm-connection-editor")
    (async-shell-command "nmcli dev wifi list"))
#+END_SRC
**** Volume mixer
For when you need to do volume mixing.
#+BEGIN_SRC emacs-lisp
  (defun volume-settings ()
    "Open pavucontrol to adjust volume."
    (interactive)
    (start-process-shell-command
     "Volume Mixer" nil "pavucontrol"))
#+END_SRC
**** Keyboard layout selection
This will eventually be its own package, but for now, it's just in my config. First, I set up three custom variables:
#+BEGIN_SRC emacs-lisp
  (defgroup keyboard-layout nil
    "Keyboard layouts to cycle through."
    :group 'environment)

  (defcustom keyboard-layout-1 "us"
    "The first of three keyboard layouts to cycle through.

  Set to nil to have one less keyboard layout."
    :group 'keyboard-layout
    :type 'string)

  (defcustom keyboard-layout-2 "epo"
    "The second of three keyboard layouts to cycle through.

  Set to nil to have one less keyboard layout."
    :group 'keyboard-layout
    :type 'string)

  (defcustom keyboard-layout-3 "de"
    "The third of three keyboard layouts to cycle through.

  Set to nil to have one less keyboard layout."
    :group 'keyboard-layout
    :type 'string)
#+END_SRC
Then, I use these functions to control setting and cycling the keyboard layout.
#+BEGIN_SRC emacs-lisp
  (defun get-keyboard-layout ()
    "Get the current keyboard layout."
    (shell-command-to-string
     (concat "setxkbmap -query | "
	     "grep -oP 'layout:\\s*\\K(\\w+)' | "
	     "tr '\n' ' ' | sed 's/ //'")))

  (defun set-keyboard-layout (&optional layout)
    "Set the keyboard layout to LAYOUT."
    (interactive)
    (let ((layout (or layout (read-string "Enter keyboard layout: "))))
      (shell-command (concat "setxkbmap " layout " -option ctrl:nocaps"))
      (message "Keyboard layout is now: %s" layout)))

  (defun cycle-keyboard-layout ()
    "Cycle between `keyboard-layout-1', `keyboard-layout-2', and `keyboard-layout-3'."
    (interactive)
    (let* ((current-layout (get-keyboard-layout))
	   (new-layout (if (string= current-layout keyboard-layout-1)
			   (or keyboard-layout-2 keyboard-layout-3)
			 (if (string= current-layout keyboard-layout-2)
			     (or keyboard-layout-3 keyboard-layout-1)
			   (or keyboard-layout-1 keyboard-layout-2)))))
      (if new-layout
	  (set-keyboard-layout new-layout)
	(message "No keyboard layouts selected."))))

  (defun cycle-keyboard-layout-reverse ()
    "Cycle between `keyboard-layout-1', `keyboard-layout-2', and `keyboard-layout-3' in reverse."
    (interactive)
    (let* ((current-layout (get-keyboard-layout))
	   (new-layout (if (string= current-layout keyboard-layout-3)
			   (or keyboard-layout-2 keyboard-layout-1)
			 (if (string= current-layout keyboard-layout-2)
			     (or keyboard-layout-1 keyboard-layout-3)
			   (or keyboard-layout-3 keyboard-layout-2)))))
      (if new-layout
	  (set-keyboard-layout new-layout)
	(message "No keyboard layouts selected."))))
#+END_SRC
**** Suspending
#+BEGIN_SRC emacs-lisp
  (defun suspend-computer ()
    (interactive)
    (when (yes-or-no-p "Really suspend? ")
      (shell-command "suspend")))

  (global-set-key (kbd "C-x C-M-s") 'suspend-computer)
#+END_SRC
**** Shutting down
I copied the function for quitting Emacs to handle shutting down.
#+BEGIN_SRC emacs-lisp
  (defun save-buffers-shut-down (&optional arg)
    "Offer to save each buffer, then shut down the computer.
  This function is literally just a copycat of `save-buffers-kill-emacs'.
  With prefix ARG, silently save all file-visiting buffers without asking.
  If there are active processes where `process-query-on-exit-flag'
  returns non-nil and `confirm-kill-processes' is non-nil,
  asks whether processes should be killed.
  Runs the members of `kill-emacs-query-functions' in turn and stops
  if any returns nil.  If `confirm-kill-emacs' is non-nil, calls it.
  Instead of just killing Emacs, shuts down the system."
    (interactive "P")
    ;; Don't use save-some-buffers-default-predicate, because we want
    ;; to ask about all the buffers before killing Emacs.
    (save-some-buffers arg t)
    (let ((confirm confirm-kill-emacs))
      (and
       (or (not (memq t (mapcar (function
				 (lambda (buf) (and (buffer-file-name buf)
						    (buffer-modified-p buf))))
				(buffer-list))))
	   (progn (setq confirm nil)
		  (yes-or-no-p "Modified buffers exist; shut down anyway? ")))
       (or (not (fboundp 'process-list))
	   ;; process-list is not defined on MSDOS.
	   (not confirm-kill-processes)
	   (let ((processes (process-list))
		 active)
	     (while processes
	       (and (memq (process-status (car processes)) '(run stop open listen))
		    (process-query-on-exit-flag (car processes))
		    (setq active t))
	       (setq processes (cdr processes)))
	     (or (not active)
		 (with-current-buffer-window
		  (get-buffer-create "*Process List*") nil
		  #'(lambda (window _value)
		      (with-selected-window window
			(unwind-protect
			    (progn
			      (setq confirm nil)
			      (yes-or-no-p "Active processes exist; kill them and shut down anyway? "))
			  (when (window-live-p window)
			    (quit-restore-window window 'kill)))))
		  (list-processes t)))))
       ;; Query the user for other things, perhaps.
       (run-hook-with-args-until-failure 'kill-emacs-query-functions)
       (or (null confirm)
	   (funcall confirm "Really shut down? "))
       (shell-command "shutdown now")
       (kill-emacs))))

  (global-set-key (kbd "C-x C-M-c") 'save-buffers-shut-down)
#+END_SRC
**** Rebooting
I copied the function for quitting Emacs to handle reboot too.
#+BEGIN_SRC emacs-lisp
  (defun save-buffers-reboot (&optional arg)
    "Offer to save each buffer, then shut down the computer.
  This function is literally just a copycat of `save-buffers-kill-emacs'.
  With prefix ARG, silently save all file-visiting buffers without asking.
  If there are active processes where `process-query-on-exit-flag'
  returns non-nil and `confirm-kill-processes' is non-nil,
  asks whether processes should be killed.
  Runs the members of `kill-emacs-query-functions' in turn and stops
  if any returns nil.  If `confirm-kill-emacs' is non-nil, calls it.
  Instead of just killing Emacs, shuts down the system."
    (interactive "P")
    ;; Don't use save-some-buffers-default-predicate, because we want
    ;; to ask about all the buffers before killing Emacs.
    (save-some-buffers arg t)
    (let ((confirm confirm-kill-emacs))
      (and
       (or (not (memq t (mapcar (function
				 (lambda (buf) (and (buffer-file-name buf)
						    (buffer-modified-p buf))))
				(buffer-list))))
	   (progn (setq confirm nil)
		  (yes-or-no-p "Modified buffers exist; reboot anyway? ")))
       (or (not (fboundp 'process-list))
	   ;; process-list is not defined on MSDOS.
	   (not confirm-kill-processes)
	   (let ((processes (process-list))
		 active)
	     (while processes
	       (and (memq (process-status (car processes)) '(run stop open listen))
		    (process-query-on-exit-flag (car processes))
		    (setq active t))
	       (setq processes (cdr processes)))
	     (or (not active)
		 (with-current-buffer-window
		  (get-buffer-create "*Process List*") nil
		  #'(lambda (window _value)
		      (with-selected-window window
			(unwind-protect
			    (progn
			      (setq confirm nil)
			      (yes-or-no-p "Active processes exist; kill them and reboot anyway? "))
			  (when (window-live-p window)
			    (quit-restore-window window 'kill)))))
		  (list-processes t)))))
       ;; Query the user for other things, perhaps.
       (run-hook-with-args-until-failure 'kill-emacs-query-functions)
       (or (null confirm)
	   (funcall confirm "Really reboot? "))
       (shell-command "reboot")
       (kill-emacs))))

  (global-set-key (kbd "C-x C-M-r") 'save-buffers-reboot)
#+END_SRC
** Keybindings
*** Set a bind for both global and EXWM usage
Save lines, save time.
#+BEGIN_SRC emacs-lisp
  (defun exwm-bind-key (key function)
    (global-set-key key function)
    (define-key exwm-mode-map key function))
#+END_SRC
*** Global binds to use across everything
Anything I couldn't cram into ~desktop-environment-mode~ has been slapped into this area.
#+BEGIN_SRC emacs-lisp
  (setq exwm-input-global-keys
	`(;; Switching Workspaces
	  ([?\s-w] . (lambda ()
		       (interactive)
		       (exwm-workspace-switch-create 0)))
	  ([?\s-q] . (lambda ()
		       (interactive)
		       (exwm-workspace-switch-create 1)))
	  ([?\s-e] . (lambda ()
		       (interactive)
		       (exwm-workspace-switch-create 2)))

	  ;; Opening X applications
	  ([?\s-f]    . run-firefox)
	  ([?\s-b]    . run-libreoffice)
	  ([?\s-g]    . run-gimp)
	  ([?\s-t]    . run-telegram)
	  ([?\s-d]    . run-discord)
	  ([?\s-s]    . run-steam)
	  ([s-return] . run-terminal)
	  ([?\s-r]    . monitor-settings)
	  ([?\s-n]    . network-settings)
	  ([?\s-v]    . volume-settings)

	  ;; Other desktop environment things
	  ([?\s-x]       . dmenu)
	  ([menu]        . smex)
	  ([?\s- ]       . cycle-keyboard-layout)
	  ([s-backspace] . cycle-keyboard-layout-reverse)))
#+END_SRC
*** Emacs key bindings in X windows
This is super nice, because I love these key bindings and they are just intuitive to me, and now they can carry over safely to other programs.
#+BEGIN_SRC emacs-lisp
  (setq exwm-input-simulation-keys
	'(;; Navigation
	  ([?\C-b] . [left])
	  ([?\C-f] . [right])
	  ([?\C-p] . [up])
	  ([?\C-n] . [down])

	  ([?\M-b] . [C-left])
	  ([?\M-f] . [C-right])
	  ([?\M-p] . [C-up])
	  ([?\M-n] . [C-down])

	  ([?\C-a] . [home])
	  ([?\C-e] . [end])
	  ([?\C-v] . [next])
	  ([?\M-v] . [prior])

	  ;; Copy/Paste
	  ([?\C-w] . [?\C-x])
	  ([?\M-w] . [?\C-c])
	  ([?\C-y] . [?\C-v])
	  ([?\C-s] . [?\C-f])
	  ([?\C-\/] . [?\C-z])

	  ;; Other
	  ([?\C-d] . [delete])
	  ([?\C-k] . [S-end delete])
	  ([?\C-g] . [escape])))

  ;; I can't do sequences above, so this is separate
  (defun exwm-C-s ()
    "Pass C-s to the EXWM window."
    (interactive)
    (execute-kbd-macro (kbd "C-q C-s")))

  (define-key exwm-mode-map (kbd "C-x C-s") 'exwm-C-s)
#+END_SRC
*** Send a key verbatim more easily
#+BEGIN_SRC emacs-lisp
       (define-key exwm-mode-map (kbd "C-c C-q") nil)
       (define-key exwm-mode-map (kbd "C-q") 'exwm-input-send-next-key)
#+END_SRC
*** Inhibit things I don't use
This includes:
- Toggling fullscreen
- Toggling floating
- Toggling hiding
- Toggling the mode line
#+BEGIN_SRC emacs-lisp
  (dolist (key '("C-c C-f"
		 "C-c C-t C-f"
		 "C-c C-t C-v"
		 "C-c C-t C-m"))
    (define-key exwm-mode-map (kbd key) nil))
#+END_SRC
** On startup
*** Always hide the cursor when typing
Just a personal preference, I don't like seeing the cursor when I'm pressing keys.
#+BEGIN_SRC emacs-lisp
  (start-process-shell-command
   "Cursor Hiding" nil "xbanish")
#+END_SRC
*** Disable screen blanking
I don't need my laptop's screen shutting off just because I'm sitting and watching a video too long.
#+BEGIN_SRC emacs-lisp
  (start-process-shell-command
   "" nil "xset s off -dpms")
#+END_SRC
*** Keyboard configuration
This block sets the keyboard layout to US and give Caps Lock the functionality of Control. I was hesitant to do this at first, but it's significantly more comfortable. I almost never used caps lock as it is, given my keyboards have no indicator for it on my laptops, but this gives me a much easier way to do commands without shifting my hand too far.
#+BEGIN_SRC emacs-lisp
  (start-process-shell-command
   "" nil "setxkbmap us -option ctrl:nocaps")
#+END_SRC
*** Set fallback cursor
Some X windows will have weird cursors if this isn't done.
#+BEGIN_SRC emacs-lisp
  (start-process-shell-command
   "" nil "xsetroot -cursor_name left_ptr")
#+END_SRC
*** Compositor
I don't need it, but having basic compositing is very nice.
#+BEGIN_SRC emacs-lisp
  (start-process-shell-command
   "Compositor" nil "xcompmgr")
#+END_SRC
*** Start EXWM
#+BEGIN_SRC emacs-lisp
  (exwm-enable)
  (exwm-config-ido)
  (exwm-systemtray-enable)
#+END_SRC
#+BEGIN_SRC emacs-lisp :exports none
  )
#+END_SRC
* EMMS (Emacs MultiMedia System)
I am big on doing as much in Emacs as possible. Having my music player moved to Emacs was a HUGE step. When I first started using it, it was weird, but now I have come to absolutely love it. This is only loaded if ~mpd~ is found.
#+BEGIN_SRC emacs-lisp :exports none
  (when (executable-find "mpd")
#+END_SRC
** Install EMMS
I do a crapload here, but basically the two main things I do here is configure mpd information and bind some keys for EMMS controls and music controls.
#+BEGIN_SRC emacs-lisp
  (use-package emms
    :ensure t
    :defer t
    :init
    (require 'emms-setup)
    (require 'emms-player-mpd)
    (emms-all)
    (setq emms-seek-seconds 5
	  emms-player-list '(emms-player-mpd)
	  emms-info-functions '(emms-info mpd)
	  emms-player-mpd-server-name "localhost"
	  emms-player-mpd-server-port "6601"
	  mpc-host "localhost:6601"))
#+END_SRC
** Useful daemon functions
*** Starting the daemon
#+BEGIN_SRC emacs-lisp
  (defun mpd/start-music-daemon ()
    "Start MPD, connect to it and sync the metadata cache"
    (interactive)
    (shell-command "mpd")
    (mpd/update-database)
    (emms-player-mpd-connect)
    (emms-cache-set-from-mpd-all)
    (message "MPD started!"))
#+END_SRC
*** Stopping the daemon
#+BEGIN_SRC emacs-lisp
  (defun mpd/kill-music-daemon ()
    "Stop playback and kill the music daemon."
    (interactive)
    (emms-stop)
    (call-process "killall" nil nil nil "mpd")
    (message "MPD killed!"))
#+END_SRC
*** Updating the database
#+BEGIN_SRC emacs-lisp
  (defun mpd/update-database ()
    "Update the MPD database synchronously."
    (interactive)
    (call-process "mpc" nil nil nil "update")
    (message "MPD database updated!"))
#+END_SRC
*** Showing playback status
#+BEGIN_SRC emacs-lisp
  (defun mpd/status ()
    "Display the mpc status in the echo area."
    (interactive)
    (shell-command "mpc"))
#+END_SRC
*** Shuffling the playlist
#+BEGIN_SRC emacs-lisp
  (defun farl-emms/shuffle-with-message ()
    "Shuffle the playlist and say so in the echo area."
    (interactive)
    (emms-shuffle)
    (message "Playlist has been shuffled."))
#+END_SRC
** Binding all the keys
To ensure we don't try to call ~exwm-bind-key~ if it isn't set, we check to make sure the conditions for EXWM are met.
#+BEGIN_SRC emacs-lisp
  (let ((func  (if run-emacs-as-desktop-environment?
		   'exwm-bind-key
		 'global-set-key)))
    ;; Base functions
    (funcall func (kbd "s-a v") 'emms)
    (funcall func (kbd "s-a b") 'emms-smart-browse)
    (funcall func (kbd "s-a r c") 'emms-player-mpd-update-all-reset-cache)

    ;; Track navigation
    (funcall func (kbd "<s-left>") 'emms-previous)
    (funcall func (kbd "<s-right>") 'emms-next)
    (funcall func (kbd "<s-up>") 'emms-stop)
    (funcall func (kbd "<s-down>") 'emms-pause)

    ;; Media keys
    (funcall func (kbd "<XF86AudioPrev>") 'emms-previous)
    (funcall func (kbd "<XF86AudioNext>") 'emms-next)
    (funcall func (kbd "<XF86AudioStop>") 'emms-stop)
    (funcall func (kbd "<XF86AudioPlay>") 'emms-pause)

    ;; Repeat/shuffle
    (funcall func (kbd "s-a r a") 'emms-toggle-repeat-playlist)
    (funcall func (kbd "s-a r t") 'emms-toggle-repeat-track)
    (funcall func (kbd "s-a s") 'farl-emms/shuffle-with-message)

    ;; mpd-specific
    (funcall func (kbd "s-a x") 'mpd/start-music-daemon)
    (funcall func (kbd "s-a q") 'mpd/kill-music-daemon)
    (funcall func (kbd "s-a r d") 'mpd/update-database)
    (funcall func (kbd "s-a a") 'mpd/status))
#+END_SRC
#+BEGIN_SRC emacs-lisp :exports none
  )
#+END_SRC
* Other Emacs Goodies
This is other stuff I use in Emacs.
** Terminal
I've been jumping between ~vterm~ and ~ansi-term~. I guess ~ansi-term~ wins out because ~vterm~ does not actually provide much benefit in comparison. Regardless, I use an alias ~run-terminal~ so that I only have to change this single block, instead of other blocks as well. In the off-chance I'm running Emacs in the terminal, =C-c t= works too.
#+BEGIN_SRC emacs-lisp
  (defvar ansi-term-shell "/bin/zsh"
    "The default shell for `ansi-term' if the environment variable SHELL is not set.")

  (defadvice ansi-term (before force-bash)
    (interactive (list (or (getenv "SHELL")
			  ansi-term-shell))))
  (ad-activate 'ansi-term)

  (defalias 'run-terminal 'ansi-term)
  (global-set-key (kbd "C-c t") 'run-terminal)
#+END_SRC
** Reading the manpages
Wow, there's actually an Emacs mode for this!
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c m") 'man)
#+END_SRC
** Calculator
#+BEGIN_SRC emacs-lisp
  (require 'calc)

  (global-set-key (kbd "C-c c") 'calc)

  (define-key calc-mode-map (kbd "ESC ESC ESC") 'kill-this-buffer-and-window)
#+END_SRC
** Calendar
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c C-c") 'calendar)
#+END_SRC
** Weather forecasts
Picking a service to use for this was a pain. I ended up settling for wttrin because it is the fastest and easiest to use, and plays nice with my setup.
#+BEGIN_SRC emacs-lisp
  (use-package wttrin
    :ensure t
    :defer t
    :init
    (defvar wttrin-default-location "Indianapolis, IN"
      "A default location for `wttrin-local'.")
    (defun wttrin-local ()
      "Show a weather report for `wttrin-default-location'."
      (interactive)
      (save-window-excursion
	(unwind-protect
	    (progn (wttrin wttrin-default-location)
		   (delete-other-windows)
		   (while (not (string= (read-key-sequence "") 'q)) (message ""))
		   (message ""))
	 (kill-buffer))))
    (defun wttrin-not-local ()
      "Show a weather report for a user-defined locality."
      (interactive)
      (save-window-excursion
	(unwind-protect
	    (progn (wttrin (read-string "Get weather for: "))
		   (delete-other-windows)
		   (while (not (string= (read-key-sequence "") 'q)) (message ""))
		   (message ""))
	 (kill-buffer))))
    :bind (("C-c w" . wttrin-local)
	   ("C-c C-w" . wttrin-not-local)))
#+END_SRC
** Reading ebooks
Not the best way to do epub reading, but at least it's in Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package nov
    :ensure t
    :defer t
    :init
    (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode)))
#+END_SRC
** Games
*** Chess
Just for fun. I suck but it's nice.
#+BEGIN_SRC emacs-lisp
  (use-package chess
    :ensure t
    :defer t
    :bind ("C-c M-c" . chess))
#+END_SRC
*** Sudoku
I /love/ sudoku puzzles.
#+BEGIN_SRC emacs-lisp
  (use-package sudoku
    :ensure t
    :defer t
    :bind ("C-c M-s" . sudoku))
#+END_SRC
*** Tetris
God I love playing Tetris
#+BEGIN_SRC emacs-lisp
  (require 'tetris)

  (global-set-key (kbd "C-c M-t") 'tetris)

  (define-key tetris-mode-map "a"     'tetris-move-left)
  (define-key tetris-mode-map "s"     'tetris-move-down)
  (define-key tetris-mode-map "w"     'tetris-move-bottom)
  (define-key tetris-mode-map "d"     'tetris-move-right)

  (define-key tetris-mode-map [left]  'tetris-rotate-prev)
  (define-key tetris-mode-map [right] 'tetris-rotate-next)

  (define-key tetris-mode-map [?\t]   'tetris-pause-game)

  (define-key tetris-mode-map "q"     'kill-this-buffer)
  (define-key tetris-mode-map "Q"     'kill-this-buffer-and-window)

  (define-key tetris-mode-map "r"     'tetris-start-game)
  (define-key tetris-mode-map "e"     'tetris-end-game)
#+END_SRC
*** 2048
A simple and fun game
#+BEGIN_SRC emacs-lisp
  (use-package 2048-game
    :ensure t
    :defer t
    :bind ("C-c M-2" . 2048-game))
#+END_SRC
* General Functionality
This is just stuff not pertaining to a specific task and/or not complex enough to warrant entire sections for them.
** Don't make extra files on the filesystem
I don't use auto-saves and backups. I love living on the edge.
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil
	auto-save-default nil)
#+END_SRC
** Make scrolling a little less crazy
Now even more comfy.
#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 0
	scroll-conservatively 100000
	scroll-preserve-screen-position 1)
#+END_SRC
** Enable word wrapping for all buffers
It's literally never not annoying when words don't wrap.
#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode 1)
#+END_SRC
** If on a system with a bell, shut it up
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC
** Move between SubWords as well as between words
#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC
** Disable suspending Emacs
Why even is this a key that is bound to begin with?
#+BEGIN_SRC emacs-lisp
  (dolist (key '("C-z"
		 "C-x C-z"))
    (global-unset-key (kbd key)))
#+END_SRC
** Change current directory with =C-c d=
Useful when things get especially annoying!
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c d") 'cd)
#+END_SRC
** Restart and open dashboard with =C-c C-d=
I constantly accidentally close dashboard, so I made a way to open it again if I accidentally kill it.
#+BEGIN_SRC emacs-lisp
  (defun dashboard-restart ()
    "Restart the dashboard buffer and switch to it."
    (interactive)
    (dashboard-insert-startupify-lists)
    (switch-to-buffer "*dashboard*"))

  (global-set-key (kbd "C-c C-d") 'dashboard-restart)
#+END_SRC
** Open configuration with =C-c e=
Since this thing is changing all the time, I really like having it available on a shortcut.
#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    "Open the config file."
    (interactive)
    (find-file "~/.emacs.d/config.org"))

  (global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC
** Edit with superuser privileges via =C-x C-M-f=
#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :ensure t
    :defer t
    :bind ("C-x C-M-f" . sudo-edit))
#+END_SRC
** graphviz-dot-mode package (diagram creation)
A nice way to make diagrams.
#+BEGIN_SRC emacs-lisp
  (use-package graphviz-dot-mode
    :ensure t
    :defer t
    :init
    (require 'graphviz-dot-mode))
#+END_SRC
** Spell-checking
Just a useful little tool to keep spelling in check.
#+BEGIN_SRC emacs-lisp
  (require 'flyspell)

  (setq ispell-program-name "aspell"
	ispell-dictionary "american")

  (add-hook 'flyspell-mode-hook 'flyspell-buffer)
  (add-hook 'prog-mode-hook 'flyspell-prog-mode)
  (add-hook 'text-mode-hook 'flyspell-mode)
#+END_SRC
* Menus/Commands
Menus, commands, and commands which involve menus.
** Enable ido-mode, install ido-vertical-mode and smex
I /love/ ~ido-mode~. God I *love* ~ido-mode~.
#+BEGIN_SRC emacs-lisp
  (setq ido-mode-flex-matching nil
	ido-create-new-buffer 'always
	ido-everywhere t)
  (ido-mode 1)
#+END_SRC
However, I /HATE/ ~ido-mode~ right out of the box. A vertical list looks craptons nicer.
#+BEGIN_SRC emacs-lisp
  (use-package ido-vertical-mode
    :ensure t
    :defer t
    :init
    (setq ido-vertical-define-keys 'C-n-and-C-p-only)
    (ido-vertical-mode 1))
#+END_SRC
Default M-x behavior doesn't use ~ido-mode~, so we install a package which gives it ~ido-mode~.
#+BEGIN_SRC emacs-lisp
  (use-package smex
    :ensure t
    :defer t
    :bind (("M-x"    . smex)
	   ("<menu>" . smex)))
#+END_SRC
** Replace "yes or no" prompts with "y or n"
Beauty in brevity.
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** which-key package (small menus to help with commands)
Even as I've gotten used to Emacs key bindings, it is always nice to have this around so that if I want to know, I can easily see what's what.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :defer t
    :init
    (which-key-mode 1))
#+END_SRC
** popup-kill-ring package (easier time managing the kill ring)
Having the whole kill ring easy to scroll through is much less hassle than default behavior.
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :defer t
    :bind ("M-y" . popup-kill-ring))
#+END_SRC
** swiper package (better searches)
This search behavior is *SO* much nicer than the default.
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :defer t
    :bind ("C-s" . swiper))
#+END_SRC
** Kill an entire word when you're in the middle of it
I don't need it super often, but it's still nice to have.
#+BEGIN_SRC emacs-lisp
  (defun whole-kill-word ()
    "Delete an entire word."
    (interactive)
    (backward-word)
    (kill-word 1))

  (global-set-key (kbd "C-c DEL") 'whole-kill-word)
#+END_SRC
** avy package (faster moving around documents)
If I want to hop around in a document without calling swiper, ~avy~ is definitely the way to go.
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :defer t
    :bind ("M-s" . avy-goto-char))
#+END_SRC
** hungry-delete package (convenient deletion of trailing whitespace)
This saves me tons of time when it comes to managing whitespace.
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :ensure t
    :defer t
    :init
    (global-hungry-delete-mode 1))
#+END_SRC
** company package (autocomplete backend)
This is the base package. I changed some key bindings to make it more pleasant to use.
#+BEGIN_SRC emacs-lisp
    (use-package company
      :ensure t
      :defer t
      :init
      (setq company-idle-delay 0.75
	    company-minimum-prefix-length 3)
      (with-eval-after-load 'company
	(define-key company-active-map (kbd "M-n") nil)
	(define-key company-active-map (kbd "M-p") nil)
	(define-key company-active-map (kbd "C-n") 'company-select-next)
	(define-key company-active-map (kbd "C-p") 'company-select-previous)
	(define-key company-active-map (kbd "SPC") 'company-abort))
      (global-company-mode 1))
#+END_SRC
* Buffers/Windows
** Sloppy focus
I hate having to click to focus a different window, so I would rather just have windows sloppily focus.
#+BEGIN_SRC emacs-lisp
  (setq focus-follows-mouse t
	mouse-autoselect-window t)
#+END_SRC
** Kill current buffer with =C-x k=, use =C-x C-k= to kill the window too
I had to adjust the function which kills both the current buffer and the current window, because it did not cooperate with EXWM buffers. That's why I have this weird chunk I don't actually have the expertise yet to fully parse.
#+BEGIN_SRC emacs-lisp
  (defun kill-this-buffer-and-window ()
    "Kill the current buffer and delete the selected window. (Adjusted for EXWM.)"
    (interactive)
    (let ((window-to-delete (selected-window))
	  (buffer-to-kill (current-buffer))
	  (delete-window-hook (lambda ()
				(ignore-errors (delete-window)))))
      (unwind-protect
	  (progn
	    (add-hook 'kill-buffer-hook delete-window-hook t t)
	    (if (kill-buffer (current-buffer))
		;; If `delete-window' failed before, we repeat
		;; it to regenerate the error in the echo area.
		(when (eq (selected-window) window-to-delete)
		  (delete-window)))))))

  (global-set-key (kbd "C-x k") 'kill-this-buffer)
  (global-set-key (kbd "C-x C-k") 'kill-this-buffer-and-window)
#+END_SRC
** Close all buffers and kill all windows with =C-x C-M-k=
I wanted a way to quickly and gracefully destroy all my open stuff at once.
#+BEGIN_SRC emacs-lisp
  (defun close-buffers-and-windows ()
    "Close every buffer and close all windows, then restart dashboard."
    (interactive)
    (save-some-buffers)
    (when (yes-or-no-p "Really kill all buffers? ")
      (mapc 'kill-buffer (buffer-list))
      (delete-other-windows)
      (dashboard-restart)))

  (global-set-key (kbd "C-x C-M-k") 'close-buffers-and-windows)
#+END_SRC
** Use buffer-menu on =C-x b= so the buffer list doesn't open a new window
Just another point of personal convenience. I don't like ~ibuffer~ just because aesthetic reasons. I also set Q to close the window, for convenience.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x b") 'buffer-menu)
  (global-unset-key (kbd "C-x C-b"))

  (define-key Buffer-menu-mode-map (kbd "q") 'kill-this-buffer)
  (define-key Buffer-menu-mode-map (kbd "Q") 'kill-this-buffer-and-window)
#+END_SRC
** Move focus and show buffer-menu when explicitly creating new windows
This to me is preferable to the default behavior.
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-vertical ()
    "Open a new window vertically."
    (interactive)
    (split-window-below)
    (other-window 1)
    (buffer-menu))

  (defun split-and-follow-horizontal ()
    "Open a new window horizontally."
    (interactive)
    (split-window-right)
    (other-window 1)
    (buffer-menu))

  (global-set-key (kbd "C-x 2") 'split-and-follow-vertical)
  (global-set-key (kbd "C-x 3") 'split-and-follow-horizontal)
#+END_SRC
** Balance windows with =C-c b=
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c b") 'balance-windows)
#+END_SRC
** buffer-move package and windmove (moving focus and moving windows)
Since apparently =C-x C-o= is actually something useful by default, I decided to squash ~windmove~ and ~buffer-move~ into a single keymap.
#+BEGIN_SRC emacs-lisp
  (use-package buffer-move
    :ensure t
    :defer t
    :init
    (defvar buffer-move-and-windmove-map
      (let ((map (make-sparse-keymap)))
	(define-key map (kbd "w") 'windmove-up)
	(define-key map (kbd "a") 'windmove-left)
	(define-key map (kbd "s") 'windmove-down)
	(define-key map (kbd "d") 'windmove-right)
	(define-key map (kbd "C-w") 'buf-move-up)
	(define-key map (kbd "C-a") 'buf-move-left)
	(define-key map (kbd "C-s") 'buf-move-down)
	(define-key map (kbd "C-d") 'buf-move-right)
	map)
      "A keymap for `buffer-move' and `windmove' functions.")
    (global-set-key (kbd "C-x o") buffer-move-and-windmove-map))
#+END_SRC
* Org-mode
I don't need much extending for org-mode.
** Agenda (only enabled if an agenda is found)
I use =C-c a= and =C-c C-a= to do things related to my agenda. Only one of my systems actually has my agenda, so this only runs on that machine so I don't try any funny business on other machines.
#+BEGIN_SRC emacs-lisp
  (if (file-exists-p "~/agenda.org")
      (progn
	(setq org-agenda-files (quote ("~/agenda.org")))

	(defun open-agenda ()
	  "Open the agenda file."
	  (interactive)
	  (find-file "~/agenda.org"))

	(global-set-key (kbd "C-c a") 'org-agenda)
	(global-set-key (kbd "C-c C-a") 'open-agenda)))
#+END_SRC
** Quality of life settings
These are just quick things that make ~org-mode~ much easier to use.
#+BEGIN_SRC emacs-lisp
  (setq org-pretty-entities t
	org-src-fontify-natively t
	org-src-tab-acts-natively t
	org-src-window-setup 'current-window
	org-fontify-whole-heading-line t
	org-fontify-done-headline t
	org-fontify-quote-and-verse-blocks t
	org-highlight-latex-and-related '(latex)
	org-enforce-todo-dependencies t
	org-agenda-use-time-grid nil
	org-agenda-skip-deadline-if-done t
	org-agenda-skip-scheduled-if-done t
	org-ellipsis (if (string= (window-system) 'x)
			 "⤵"
		       "..."))
#+END_SRC
** Shortcuts for various snippets in org-mode
This will expand as I get into more and more languages and take more notes in classes with different snippets of different languages.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
	       '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist
	       '("py" "#+BEGIN_SRC python\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist
	       '("dot" "#+BEGIN_SRC dot :file ?.png :cmdline -Kdot -Tpng\n\n#+END_SRC"))
#+END_SRC
** Use the current window when editing source code in org-mode
This is just a convenience thing.
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC
** Automatically fix inline images generated for diagrams
This is exactly what I was looking for lmao
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
#+END_SRC
** Skip confirming whether to evaluate dot snippets
Since obviously dot snippets are purely harmless +as far as I know+, I just don't bother with having to confirm evaluation every time I try to update a graphic.
#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate '(lambda (lang body) (not (string= lang "dot"))))
#+END_SRC
** Load various languages in org-babel
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages 'org-babel-load-languages '((dot . t)))
#+END_SRC
** In graphical environments
#+BEGIN_SRC emacs-lisp :exports none
  (when (window-system)
#+END_SRC
*** Fancy symbol for collapsed items
Just makes ~org-mode~ look a little fancier, no distinct changes.
#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "⤵")
#+END_SRC
*** org-bullets package (nicer bullet points in org-mode)
It's kinda slow, but bullet points are very very nice, much better than asterisks.
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :defer t
    :init
    (add-hook 'org-mode-hook 'org-bullets-mode)
    (setq inhibit-compacting-font-caches t))
#+END_SRC
*** Hide emphasis markers in org-mode
Just a point of /personal preference./ I was considering keeping this in for non-graphical environments, but I can't always trust that there will be support for the different representations of text.
#+BEGIN_SRC emacs-lisp
  (setq org-hide-emphasis-markers t)
#+END_SRC
*** epresent package
It's gonna need more polish, but it works.
#+BEGIN_SRC emacs-lisp
  (use-package epresent
    :ensure t
    :defer t
    :bind (:map org-mode-map
		("C-c r" . epresent-run)))
#+END_SRC
#+BEGIN_SRC emacs-lisp :exports none
  )
#+END_SRC
* Programming
This is quite barren, but mostly because my needs are not currently particularly that big.
** magit package (git but made easier)
I used to use a terminal for this, but holy crap this is a lot easier, a lot faster, and a whole lot nicer to use overall.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :defer t
    :bind ("C-c g" . magit-status)
    :bind (:map magit-mode-map
	       ("q" . kill-this-buffer)
	       ("Q" . kill-this-buffer-and-window)))
#+END_SRC
** flycheck package (on-the-fly syntax checker)
This is nice to have so I can be told right away when I'm doing something wrong. However, I /DON'T/ want to see all the stuff about documentation for elisp.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :defer t
    :init
    (global-flycheck-mode 1)
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
#+END_SRC
** avy-flycheck package (avy but also flycheck)
This one is SUPER COOL.
#+BEGIN_SRC emacs-lisp
  (use-package avy-flycheck
    :ensure t
    :defer t
    :bind (:map prog-mode-map
		("C-c C-'" . avy-flycheck-goto-error)))
#+END_SRC
** company-jedi package (Python autocompletion)
I will probably be adding company autocompletion for more languages as I start working in more languages.
#+BEGIN_SRC emacs-lisp
  (use-package company-jedi
    :ensure t
    :defer t
    :init
    (add-to-list 'company-backends 'company-jedi))
#+END_SRC
** haskell-mode package (self-explanatory)
I have started to mess around with Haskell, so I needed to grab a mode for that. This supplies basically everything I need, e.g. company autocompletion and flycheck information.
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure t
    :defer t
    :init
    (setq haskell-stylish-on-save t)
    :hook ((haskell-mode . interactive-haskell-mode)
	   (haskell-mode . turn-on-haskell-doc-mode)
	   (haskell-mode . haskell-indentation-mode)
	   (haskell-mode . haskell-auto-insert-module-template)))
#+END_SRC
** electric-pair-mode (OH MY GOD THIS IS SO GREAT)
I have no words for how convenient this has been and how much faster I get things done thanks to these five lines of elisp.
#+BEGIN_SRC emacs-lisp
  (setq electric-pair-pairs '((?\{ . ?\})
			      (?\( . ?\))
			      (?\[ . ?\])
			      (?\" . ?\")))
  (electric-pair-mode t)
#+END_SRC
* Looks
** General
*** Line numbers
I like having line numbers. However, I don't like line numbers in modes where it breaks the mode.
#+BEGIN_SRC emacs-lisp
  (global-display-line-numbers-mode 1)

  (dolist (hook '(nov-mode-hook
		  tetris-mode-hook
		  snake-mode-hook
		  sudoku-mode-hook
		  shell-mode-hook
		  Buffer-menu-mode-hook
		  dashboard-mode-hook
		  term-mode-hook
		  shell-mode-hook
		  epresent-mode-hook))
    (add-hook hook (lambda () (display-line-numbers-mode -1))))
#+END_SRC
*** Highlight matching parentheses et al. when hovering near one
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC
*** Make ^L a nice-looking line
This one is also just a matter of personal preference really.
#+BEGIN_SRC emacs-lisp
  (global-page-break-lines-mode 1)
#+END_SRC
** In graphical environments
This stuff really only helps when you're in a graphical environment. Running Emacs from a terminal means these things might not work, so I don't load them when not in a graphical environment.
#+BEGIN_SRC emacs-lisp :exports none
  (when (window-system)
#+END_SRC
*** Theme
I used to hate light themes. I'm not in that camp anymore. This theme is /elegant/.
#+BEGIN_SRC emacs-lisp
  (use-package leuven-theme
    :ensure t
    :defer t
    :init
    (load-theme 'leuven t))
#+END_SRC
*** Font
Originally I had this set up by means of ~custom-set-faces~, but frankly that is less easily configured than this method. First, we determine whether my preferred font is present on the system and set it if present. Otherwise, keep the default that Emacs chooses.
#+BEGIN_SRC emacs-lisp
  (when (member "Iosevka" (font-family-list))
      (set-face-attribute 'default nil :font "Iosevka"))
#+END_SRC
Then, we need to determine what size to make the text. This is based on the width of the screens I regularly use. It uses shell commands for X window systems and built-in functions for Windows.
#+BEGIN_SRC emacs-lisp
  (let* ((res (if (string= (window-system) 'x)
		  (string-to-number
		   (shell-command-to-string
		    (concat "xrandr | grep \\* | "
			    "cut -d x -f 1 | "
			    "sort -n | head -n 1")))
		(/ (display-pixel-width) (display-screens))))
	   (size (if (<= res 1366) 100
		   (if (<= res 1920) 150
		     (if (<= res 2560) 180
		       (if (<= res 3840) 220
			 240))))))
    (set-face-attribute 'default nil :height size))
#+END_SRC
*** Window dividers/fringes
Fringes and dividers look far fancier than the alternatives.
#+BEGIN_SRC emacs-lisp
  (setq window-divider-default-right-width 3)
  (dolist (face '(window-divider-first-pixel
		  window-divider
		  window-divider-last-pixel))
    (set-face-foreground face "#335ea8"))
  (window-divider-mode 1)
  (fringe-mode 10)
#+END_SRC
*** pretty-mode package (prettify symbols)
I don't like ~prettify-symbols-mode~. It doesn't do enough. This one helps so much more to make things look nice, especially in functional programming languages. I enable /all/ of them.
#+BEGIN_SRC emacs-lisp
  (use-package pretty-mode
    :ensure t
    :defer t
    :init
    (global-pretty-mode 1)
    (pretty-activate-groups
     '(:nil :ordering :equality :logic :sets :parentheses :function :greek
	    :types :punctuation :arrows :quantifiers :arithmetic :undefined
	    :other :sub-and-superscripts)))
#+END_SRC
*** rainbow package (show colors when typed as hex codes)
I don't use it too much, but it's nice to have it around.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :defer t
    :init
    (define-globalized-minor-mode global-rainbow-mode rainbow-mode rainbow-mode))
    (global-rainbow-mode 1)
#+END_SRC
*** rainbow-delimiters package (better quotes/parentheses/brackets)
It's subtle on my theme, but it still helps me keep track of my brackets and parentheses.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :defer t
    :init
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC
#+BEGIN_SRC emacs-lisp :exports none
  )
#+END_SRC
** Mode line
*** spaceline package (Spacemacs mode line)
I *hate* the default mode line. This one is much less sucky. I also show and hide specific useful things when setting it up. In terminals, ~spaceline-emacs-theme~ just looks wrong, so I don't use it unless I'm in a graphical environment.
#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :ensure t
    :defer t
    :init
    (require 'spaceline-config)
    (setq powerline-default-separator 'contour
	  spaceline-buffer-encoding-abbrev-p nil
	  spaceline-buffer-size-p nil
	  spaceline-line-column-p t)
    (if (window-system)
	(spaceline-emacs-theme)
      (spaceline-spacemacs-theme)))
#+END_SRC
*** Show clock and battery level on mode line
I used to use ~fancy-battery~ but it constantly disappeared on my teeny tiny screens so I just decided not to bother with it. Plus it's one less package to configure lol.
#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format t)
  (display-time-mode 1)
  (display-battery-mode 1)
#+END_SRC
*** diminish package (hide minor modes from mode line)
Works very nicely, makes the mode line far comfier.
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t
    :init
    :diminish (eldoc-mode
	       hungry-delete-mode
	       which-key-mode
	       subword-mode
	       company-mode
	       rainbow-mode
	       flycheck-mode
	       flyspell-mode
	       flyspell-prog-mode
	       visual-line-mode
	       interactive-haskell-mode
	       haskell-indentation-mode
	       haskell-doc-mode
	       page-break-lines-mode
	       compilation-shell-minor-mode
	       desktop-environment-mode))
#+END_SRC
