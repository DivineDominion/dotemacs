#+STARTUP: hideblocks
#+OPTIONS: num:nil
#+LANGUAGE: en
#+TITLE: Farlado's Emacs

* Installation
** Summary
1) Make sure you have all the right dependencies.
2) Clone the repo into your home directory as ~.emacs.d~.
** Dependencies
Everything has different dependencies so make sure you have what you need. The easy route to getting all these dependencies installed and configured is to deploy [[https://github.com/farlado/dotfiles][my dotfiles]]:
#+BEGIN_SRC sh
  curl https://raw.githubusercontent.com/farlado/dotfiles/master/.config/deploy/deploy | sh
#+END_SRC
*** EXWM
- Painfully obvious here: ~xorg~
- Checking for a window manager: ~wmctrl~
- Always hiding the cursor while typing: ~xbanish~
- Compositor: ~xcompmgr~
- Monitor configuration: ~arandr~
- Network configuration: ~nm-connection-editor~
- Web browser: ~firefox~
- Editing crappy documents: ~libreoffice~
- Crappy image editor: ~gimp~
- Crappy messenger: ~telegram-desktop~
- Crappier messenger: ~discord~
- Music composition: ~musescore~
- Games platform: ~steam~
*** desktop-environment
- For volume control: ~alsa-utils~
- For brightness control: ~brightnessctl~
- For screenshots: ~maim~
- For copying screenshots: ~xclip~
- For locking the screen: ~i3lock-color~
*** EMMS
- For playing music: ~mpd~, ~mpc~
- For playing video: ~mpv~
*** vterm
- Makefile parsing: ~cmake~
- Compiling: I recommend ~gcc~
- Make dependency: ~libtool~
*** nov
- To open epub files: ~ebook-tools~
*** graphviz-dot-mode
- To process dot files: ~graphviz~
*** flyspell-mode
- Spell checking: ~aspell~
- Dictionaries I use: ~aspell-en~
*** wttrin
- To grab weather data: ~curl~
*** sudo-edit
- Obvious dependency: ~sudo~
*** Other stuff
- For Python: ~pylint~, ~jedi~
- For Haskell: ~stack~
* Startup
** Start Emacs server
Having the Emacs server running allows for a lot of neat integration with other parts of my destop environment.
#+BEGIN_SRC emacs-lisp
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+END_SRC
** Enable UTF-8 encoding
I probably don't have to do this so early, but it makes things work a little smoother.
#+BEGIN_SRC emacs-lisp
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC
** Command execution improvements
Prefer newer bytecode and search more extensively when doing apropos commands.
#+BEGIN_SRC emacs-lisp
  (setq load-prefer-newer t
        apropos-do-all t)
#+END_SRC
** dashboard package (replacement start screen)
I love the default start screen, but it just doesn't cut it for me. I just use this to have a nice screen when I start Emacs or close all my buffers.
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :defer t
    :init
    (setq inhibit-startup-screen t
          dashboard-items '((recents . 10))
          dashboard-banner-logo-title "Welcome to GNU Emacs!"
          dashboard-set-footer nil
          initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
    (dashboard-setup-startup-hook))
#+END_SRC
** auto-package-update package (self-explanatory)
I don't want to have to manually update my stuff. This solution is literally plop-and-forget.
#+BEGIN_SRC emacs-lisp
  (use-package auto-package-update
    :ensure t
    :defer t
    :init
    (setq auto-package-update-interval 2
          auto-package-update-delete-old-versions t
          auto-package-update-hide-results t)
    (auto-package-update-maybe))
#+END_SRC
* Making Emacs a Desktop Environment
Yes, Emacs is my *entire desktop environment*. You should probably remove this stuff if you don't plan to use Emacs as your desktop environment. It's loaded right after the startup commands so that I can bind keys more easily later on. I sometimes have to run Emacs in Windows, so I really don't want this running when I'm not in an X window system. I also conveniently check whether there's already a running window manager, but I don't export the code blocks related to that for cleanliness.
#+BEGIN_SRC emacs-lisp :exports none
  (when (and (eq (window-system) 'x)
           (= (shell-command "wmctrl -m  1> /dev/null 2> /dev/null") 1))
    (set-frame-parameter nil 'fullscreen 'fullboth)
#+END_SRC
** Configuration
*** exwm package (base window manager)
This isn't actually where we do all the configuration, it's just where we install EXWM and load what we need to configure it. Usually it is best to configure packages inside of ~use-package~, but that would be a horrible idea due to just how many different things there are that need configuring.
#+BEGIN_SRC emacs-lisp
  (use-package exwm
    :ensure t
    :defer t
    :init
    (require 'exwm)
    (require 'exwm-randr)
    (require 'exwm-config)
    (require 'exwm-systemtray))
#+END_SRC
*** dmenu package (dmenu but for Emacs)
Since I'm using Emacs as a window manager, I need ~dmenu~ so I can open X windows I haven't bound to keys. It will be bound elsewhere.
#+BEGIN_SRC emacs-lisp
  (use-package dmenu
    :ensure t
    :defer t)
#+END_SRC
*** desktop-environment package (take a guess what it does)
Previously I had to define a lot of functions to do these things, now I just change settings within ~desktop-environment~.
#+BEGIN_SRC emacs-lisp
  (use-package desktop-environment
    :ensure t
    :defer t
    :init
    (desktop-environment-mode 1))
#+END_SRC
**** Volume adjustment
The only things I really don't like here are how much output it gives when you mute or unmute the speakers or microphone, so I set up basic scripts to give much more concise output.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-volume-toggle-command
        (concat "[ \"$(amixer set Master toggle | grep off)\" ] "
                "&& echo Volume is now muted. | tr '\n' ' ' "
                "|| echo Volume is now unmuted. | tr '\n' ' '")
        desktop-environment-volume-toggle-microphone-command
        (concat "[ \"$(amixer set Capture toggle | grep off)\" ] "
                "&& echo Microphone is now muted. | tr '\n' ' ' "
                "|| echo Microphone is now unmuted | tr '\n' ' '"))
#+END_SRC
**** Brightness adjustment
This one all I needed to do was change the increment and decrement values.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-brightness-normal-increment "5%+"
        desktop-environment-brightness-normal-decrement "5%-")
#+END_SRC
**** Screenshots
This one was the least straightforward because the way it's implemented by ~desktop-environment~ is *SUPER* wonky. Here are the binds which will be relevant.
#+BEGIN_SRC emacs-lisp
  ;; Storing to clipboard
  (define-key desktop-environment-mode-map (kbd "<print>")
    'farl-de/desktop-environment-screenshot-part-clip)
  (define-key desktop-environment-mode-map (kbd "<S-print>")
    'farl-de/desktop-environment-screenshot-clip)

  ;; Storing to file
  (define-key desktop-environment-mode-map (kbd "<C-print>")
    'farl-de/desktop-environment-screenshot-part)
  (define-key desktop-environment-mode-map (kbd "<C-S-print>")
    'farl-de/desktop-environment-screenshot)
#+END_SRC
First, I set what directory to store screenshots in.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-screenshot-directory "~/screenshots")
#+END_SRC
Then, I can set the commands for taking a full or partial screenshot and saving it to a file.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-screenshot-command
        "FILENAME=$(date +'%Y-%m-%d-%H:%M:%S').png && maim $FILENAME"
        desktop-environment-screenshot-partial-command
        "FILENAME=$(date +'%Y-%m-%d-%H:%M:%S').png && maim -s $FILENAME")
#+END_SRC
The functions which ~desktop-environment~ comes with are kinda garbage, so I made my own.
#+BEGIN_SRC emacs-lisp
  (defun farl-de/desktop-environment-screenshot ()
    "Take a screenshot and store it in a file."
    (interactive)
    (desktop-environment-screenshot)
    (message "Screenshot saved in ~/screenshots."))

  (defun farl-de/desktop-environment-screenshot-part ()
    "Take a capture of a portion of the screen and store it in a file."
    (interactive)
    (desktop-environment-screenshot-part)
    (message "Screenshot saved in ~/screenshots."))

  (defun farl-de/desktop-environment-screenshot-clip ()
    "Take a screenshot and put it in the clipboard."
    (interactive)
    (shell-command (concat desktop-environment-screenshot-command
                           " && xclip $FILENAME -selection clipboard "
                           "-t image/png &> /dev/null && rm $FILENAME"))
    (message "Screenshot copied to clipboard."))

  (defun farl-de/desktop-environment-screenshot-part-clip ()
    "Take a shot of a portion of the screen and put it in the clipboard."
    (interactive)
    (shell-command (concat desktop-environment-screenshot-partial-command
                           " && xclip $FILENAME -selection clipboard "
                           "-t image/png &> /dev/null && rm $FILENAME"))
    (message "Screenshot copied to clipboard."))
#+END_SRC
**** Lock screen
Haha yes, this is very long and very very stupid.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-screenlock-command
        (concat "i3lock -nmk --color=000000 --timecolor=ffffffff --datecolor=ffffffff "
                "--wrongcolor=ffffffff --ringcolor=00000000 --insidecolor=00000000 "
                "--keyhlcolor=00000000 --bshlcolor=00000000 --separatorcolor=00000000 "
                "--ringvercolor=00000000 --insidevercolor=00000000 --linecolor=00000000 "
                "--ringwrongcolor=00000000 --insidewrongcolor=00000000 --timestr=%H:%M "
                "--datestr='%a %d %b' --time-font=Iosevka --date-font=Iosevka "
                "--wrong-font=Iosevka --timesize=128 --datesize=64 --wrongsize=32 "
                "--time-align 0 --date-align 0 --wrong-align 0 --indpos=-10:-10 "
                "--timepos=200:125 --datepos=200:215 --wrongpos=200:155 --locktext='' "
                "--lockfailedtext='' --noinputtext='' --radius 1 --ring-width 1 "
                " --veriftext='' --wrongtext='WRONG' --force-clock"))
#+END_SRC
*** system-packages package (manage system packages in Emacs)
This one is a pleasant surprise to have honestly. Having Emacs handle system packages as well as its own is a very pleasant surprise. Since I use ~yay~ on Arch, I configure an entry for it and use it if it's installed.
#+BEGIN_SRC emacs-lisp
  (use-package system-packages
    :ensure t
    :defer t
    :init
    (when (executable-find "yay")
      (require 'system-packages)
      (add-to-list 'system-packages-supported-package-managers
                   '(yay .
                         ((default-sudo . nil)
                          (install . "yay -S")
                          (search . "yay -Ss")
                          (uninstall . "yay -Rs")
                          (update . "yay -Syu")
                          (clean-cache . "yay -Sc")
                          (log . "car /var/log/pacman.log")
                          (get-info . "yay -Qi")
                          (get-info-remote . "yay -Si")
                          (list-files-provided-by . "yay -Ql")
                          (verify-all-packages . "yay -Qkk")
                          (verify-all-dependencies . "yay -Dk")
                          (remove-orphaned . "yay -Rns $(yay -Qtdq)")
                          (list-installed-packages . "yay -Qe")
                          (list-installed-packages-all . "yay -Q")
                          (list-dependencies-of . "yay -Qi")
                          (noconfirm . "--noconfirm"))))
      (setq system-packages-use-sudo nil
            system-packages-package-manager 'yay))
    :bind (("C-c p i" . system-packages-install)
           ("C-c p e" . system-packages-ensure)
           ("C-c p u" . system-packages-update)
           ("C-c p r" . system-packages-uninstall)
           ("C-c p o" . system-packages-remove-orphaned)
           ("C-c p c" . system-packages-clean-cache)
           ("C-c p l" . system-packages-log)
           ("C-c p s" . system-packages-search)
           ("C-c p g" . system-packages-get-info)
           ("C-c p d" . system-packages-list-dependencies-of)
           ("C-c p f" . system-packages-list-files-provided-by)
           ("C-c p p" . system-packages-list-installed-packages)
           ("C-c p f" . system-packages-verify-all-dependencies)
           ("C-c p v" . system-packages-verify-all-packages)))
#+END_SRC
*** Workspace configuration
No clue why you have to do so much just to give workspaces names, but at least you can do it. I also put which monitors to try to put workspaces onto here, alongside settings for which windows should float and which workspaces they should be on.
#+BEGIN_SRC emacs-lisp
  (setq exwm-workspace-number 3
        exwm-workspace-index-map (lambda (index)
                                   (let ((named-workspaces ["1" "2" "3"]))
                                     (if (< index (length named-workspaces))
                                         (elt named-workspaces index)
                                       (number-to-string index))))
        exwm-randr-workspace-output-plist '(0 "LVDS1"
                                            0 "LVDS-1"
                                            0 "eDP-1-1"
                                            0 "DP-1-2-2"
                                            1 "DP-1-2-1"
                                            2 "DP-1-2-3")
        exwm-manage-configurations '(((string= exwm-class-name "Steam")
                                      floating-mode-line nil
                                      workspace 0
                                      floating t)
                                     ((string= exwm-instance-name "telegram-desktop")
                                      workspace 2)
                                     ((string= exwm-class-name "discord")
                                      workspace 1)
                                     ((string= exwm-title "Event Tester")
                                      floating-mode-line nil
                                      floating t)))
#+END_SRC
Additionally, I define functions for switching between workspaces, to make the global binds down the line look significantly cleaner.
#+BEGIN_SRC emacs-lisp
  (defun farl-exwm/workspace-0 ()
    "Switch to EXWM workspace 0."
    (interactive)
    (exwm-workspace-switch-create 0))

  (defun farl-exwm/workspace-1 ()
    "Switch to EXWM workspace 1."
    (interactive)
    (exwm-workspace-switch-create 1))

  (defun farl-exwm/workspace-2 ()
    "Switch to EXWM workspace 2."
    (interactive)
    (exwm-workspace-switch-create 2))
#+END_SRC
*** Multi-head
There was a point where I tried to make this into an Elisp function. Not trying that insanity again.
#+BEGIN_SRC emacs-lisp
  (defun display-and-dock-setup ()
    "Configure monitors and peripherals."
    ;; Monitors (works on both my X230 and my W541)
    (let* ((connected-monitors (split-string
                                (shell-command-to-string
                                 "xrandr | grep ' connected' | awk '{print $1}'")))
           (possible-monitors (if (member "LVDS-1" connected-monitors)
                                  '("LVDS-1" "VGA-1")
                                (if (member "LVDS1" connected-monitors)
                                    '("LVDS1" "VGA1")
                                  '("eDP-1-1" "DP-1-2-1" "DP-1-2-2"
                                    "DP-1-2-3" "VGA-1-1"))))
           (command "xrandr "))
      (dolist (monitor possible-monitors)
        (if (and (member monitor connected-monitors)
               (not (and (eq monitor "eDP-1-1")
                     (member "DP-1-2-1" connected-monitors))))
            (let* ((output (concat "--output " monitor " "))
                   (primary (when (or (eq monitor "LVDS-1")
                                     (eq monitor "eDP-1-1")
                                     (eq monitor "DP-1-2-2"))
                              "--primary "))
                   (rate (when (eq monitor "DP-1-2-2")
                           "--rate 75 "))
                   (res (concat "--mode " (if (or (eq monitor "LVDS-1")
                                                 (eq monitor "VGA-1"))
                                              "1366x768 "
                                            "1920x1080 ")))
                   (rotate (when (or (eq monitor "DP-1-2-1")
                                    (eq monitor "DP-1-2-3"))
                             (concat "--rotate " (if (eq monitor "DP-1-2-1")
                                                     "left "
                                                   "right "))))
                   (pos (concat "--pos " (if (not (or (eq monitor "DP-1-2-2")
                                                   (eq monitor "DP-1-2-3")))
                                             "0x0 "
                                           (if (eq monitor "DP-1-2-2")
                                               "1080x0 "
                                             "3000x0 ")))))
              (setq command (concat command output primary rate res rotate pos)))
          (setq command (concat command "--output " monitor " --off "))))
      (start-process-shell-command
       "Display Setup" nil command))
    ;; Disable trackpad
    (start-process-shell-command
     "Disable trackpad" nil (concat "xinput disable $(xinput list | "
                                  "grep Synaptics | head -n 1 | "
                                  "sed -r 's/.*id=([0-9]+).*/\\1/')"))
    ;; Configure trackball
    (let* ((trackball-id (shell-command-to-string
                          (concat "xinput | grep ELECOM | head -n 1 | sed -r "
                                  "'s/.*id=([0-9]+).*/\\1/' | tr '\\n' ' '"))))
      (dolist (command '("'libinput Button Scrolling Button' 10"
                         "'libinput Scroll Method Enabled' 0 0 1"))
        (start-process-shell-command
         "Trackball Setup" nil (concat "sleep 2 && xinput set-prop "
                                     trackball-id command)))
      (start-process-shell-command
       "Trackball Setup" nil (concat "sleep 2 && xinput set-button-map " trackball-id
                                   "1 2 3 4 5 6 7 8 9 2 1 2")))
    ;; Keyboard
    (start-process-shell-command
     "Keyboard Setup" nil "setxkbmap -option ctrl:nocaps"))

  (add-hook 'exwm-randr-screen-change-hook 'display-and-dock-setup)
  (exwm-randr-enable)
#+END_SRC
*** Name EXWM buffers after the window title
This was annoying when I first installed EXWM. Thankfully this is a very easy fix.
#+BEGIN_SRC emacs-lisp
  (add-hook 'exwm-update-title-hook
            (lambda () (exwm-workspace-rename-buffer exwm-title)))
#+END_SRC
*** Ensure Java applications know the WM is non-reparenting
Stolen from the ~.xinitrc~ included with ~EXWM~.
#+BEGIN_SRC emacs-lisp
  (setenv "_JAVA_AWT_WM_NONREPARENTING" "1")
#+END_SRC
*** Configure floating window borders
Uses the same color as my mode line, uses the same width as window divider width. See below.
#+BEGIN_SRC emacs-lisp
  (setq exwm-floating-border-width 3
        exwm-floating-border-color "#335ea8")
#+END_SRC
*** X applications
**** GIMP
Until GIMP's functionality gets merged into Emacs, guess I'm stuck having it.
#+BEGIN_SRC emacs-lisp
  (defun run-gimp ()
    "Start GIMP."
    (interactive)
    (start-process-shell-command
     "GIMP" nil "gimp"))
#+END_SRC
**** Steam
Gaming is possible with EXWM, if you run games windowed.
#+BEGIN_SRC emacs-lisp
  (defun run-steam ()
    "Start Steam."
    (interactive)
    (start-process-shell-command
     "Steam" nil "steam"))
#+END_SRC
**** Firefox
Firefox has some unique abilities when it comes to how to make windows behave which work better for me. I don't use tabs, and I don't want anything to do with them, and Firefox lets me hide the tab bar and force all tabs to actually open as new windows. It's like Suckless Surf, but orders of magnitude better.
#+BEGIN_SRC emacs-lisp
  (defun run-firefox ()
    "Start Firefox."
    (interactive)
    (start-process-shell-command
     "Firefox" nil "firefox"))
#+END_SRC
**** Discord
Yeah, I also use the light theme for Discord. It looks comfy, even if Discord is a garbage application.
#+BEGIN_SRC emacs-lisp
  (defun run-discord ()
    "Start Discord."
    (interactive)
    (start-process-shell-command
     "Discord" nil "discord"))
#+END_SRC
**** Telegram
I have a painfully white theme which fits perfectly with my setup.
#+BEGIN_SRC emacs-lisp
  (defun run-telegram ()
    "Start Telegram."
    (interactive)
    (start-process-shell-command
     "Telegram" nil "telegram-desktop"))
#+END_SRC
**** MuseScore
I haven't figured out how to engrave in Emacs, so for now...
#+BEGIN_SRC emacs-lisp
  (defun run-musescore ()
    "Start MuseScore."
    (interactive)
    (start-process-shell-command
     "MuseScore" nil "musescore"))
#+END_SRC
**** LibreOffice
Shame me all you want. I'm still in introductory courses and haven't learned enough Org-mode to use it more meaningfully.
#+BEGIN_SRC emacs-lisp
  (defun run-libreoffice ()
    "Start LibreOffice."
    (interactive)
    (start-process-shell-command
     "LibreOffice" nil "libreoffice"))
#+END_SRC
**** Transmission
#+BEGIN_SRC emacs-lisp
  (defun run-transmission ()
    "Start Transmission."
    (interactive)
    (start-process-shell-command
     "Transmission" nil "transmission-gtk"))
#+END_SRC
*** Other things a DE should probably have
**** Display setup
Calling ~arandr~ to adjust monitors is useful when I am preparing to present something using my computer or need to adjust how monitors are set up in a unique way that isn't a preset from my dotfiles.
#+BEGIN_SRC emacs-lisp
  (defun monitor-settings ()
    "Open arandr to configure monitors."
    (interactive)
    (start-process-shell-command
     "Monitor Settings" nil "arandr"))
#+END_SRC
**** Network settings
This one uses two windows: one to open the NetworkManager connection editor, and another to list WiFi networks nearby.
#+BEGIN_SRC emacs-lisp
  (defun network-settings ()
    "Open a NetworkManager connection editor."
    (interactive)
    (start-process-shell-command
     "Connections" nil "nm-connection-editor")
    (async-shell-command "nmcli dev wifi list"))
#+END_SRC
**** Volume mixer
For when you need to do volume mixing.
#+BEGIN_SRC emacs-lisp
  (defun volume-settings ()
    "Open pavucontrol to adjust volume."
    (interactive)
    (start-process-shell-command
     "Volume Mixer" nil "pavucontrol"))
#+END_SRC
**** Audio loop-back
Used when I play Jackbox Party Pack with friends. Also set up to launch ~pavucontrol~ to set up which programs to pass through to Discord.
#+BEGIN_SRC emacs-lisp
  (defun audio-loopback ()
    "Loop desktop audio into a null sink alongside the primary input."
    (interactive)
    ;; Create two modules: `loop' and `out'
    (dolist (sink '("loop"
                    "out"))
      (shell-command (concat "pacmd load-module module-null-sink sink_name=" sink))
      (shell-command (concat "pacmd update-sink-proplist "
                             sink " device.description=" sink)))
    ;; Loop `loop' to primary output, pipe it to `out', loop primary into to `out'
    (dolist (command '("sink=out"
                       "source=loop.monitor"
                       "source=loop.monitor sink=out"))
      (shell-command (concat "pacmd load-module module-loopback " command)))
    ;; Run `pavucontrol' and then unload the modules after it completes
    (start-process-shell-command
     "Audio Loop" nil (concat "pavucontrol && "
                            "pacmd unload-module module-null-sink && "
                            "pacmd unload-module module-loopback")))
#+END_SRC
**** Keyboard layout selection
This will eventually be its own package, but for now, it's just in my config. First, I set up three custom variables:
#+BEGIN_SRC emacs-lisp
  (defgroup keyboard-layout nil
    "Keyboard layouts to cycle through."
    :group 'environment)

  (defcustom keyboard-layout-1 "us"
    "The first of three keyboard layouts to cycle through.
  Set to nil to have one less keyboard layout."
    :group 'keyboard-layout
    :type 'string)

  (defcustom keyboard-layout-2 "epo"
    "The second of three keyboard layouts to cycle through.
  Set to nil to have one less keyboard layout."
    :group 'keyboard-layout
    :type 'string)

  (defcustom keyboard-layout-3 "de"
    "The third of three keyboard layouts to cycle through.
  Set to nil to have one less keyboard layout."
    :group 'keyboard-layout
    :type 'string)
#+END_SRC
Then, I use these functions to control setting and cycling the keyboard layout:
#+BEGIN_SRC emacs-lisp
  (defun get-keyboard-layout ()
    "Get the current keyboard layout."
    (shell-command-to-string
     (concat "setxkbmap -query | "
             "grep -oP 'layout:\\s*\\K(\\w+)' | "
             "tr '\n' ' ' | sed 's/ //'")))

  (defun set-keyboard-layout (&optional layout)
    "Set the keyboard layout to LAYOUT."
    (interactive)
    (let ((layout (or layout (read-string "Enter keyboard layout: "))))
      (shell-command (concat "setxkbmap " layout " -option ctrl:nocaps"))
      (message "Keyboard layout is now: %s" layout)))

  (defun cycle-keyboard-layout ()
    "Cycle between `keyboard-layout-1', `keyboard-layout-2', and `keyboard-layout-3'."
    (interactive)
    (let* ((current-layout (get-keyboard-layout))
           (new-layout (if (eq current-layout keyboard-layout-1)
                           (or keyboard-layout-2 keyboard-layout-3)
                         (if (eq current-layout keyboard-layout-2)
                             (or keyboard-layout-3 keyboard-layout-1)
                           (or keyboard-layout-1 keyboard-layout-2)))))
      (if new-layout
          (set-keyboard-layout new-layout)
        (message "No keyboard layouts selected."))))

  (defun cycle-keyboard-layout-reverse ()
    "Cycle between `keyboard-layout-1', `keyboard-layout-2', and `keyboard-layout-3' in reverse."
    (interactive)
    (let* ((current-layout (get-keyboard-layout))
           (new-layout (if (eq current-layout keyboard-layout-3)
                           (or keyboard-layout-2 keyboard-layout-1)
                         (if (eq current-layout keyboard-layout-2)
                             (or keyboard-layout-1 keyboard-layout-3)
                           (or keyboard-layout-3 keyboard-layout-2)))))
      (if new-layout
          (set-keyboard-layout new-layout)
        (message "No keyboard layouts selected."))))
#+END_SRC
**** Suspending
#+BEGIN_SRC emacs-lisp
  (defun suspend-computer ()
    (interactive)
    (when (yes-or-no-p "Really suspend? ")
      (shell-command "systemctl suspend -i")))

  (global-set-key (kbd "C-x C-M-s") 'suspend-computer)
#+END_SRC
**** Shutting down
I copied the function for quitting Emacs to handle shutting down.
#+BEGIN_SRC emacs-lisp
  (defun save-buffers-shut-down (&optional arg)
    "Offer to save each buffer, then shut down the computer.
  This function is literally just a copycat of `save-buffers-kill-emacs'.
  With prefix ARG, silently save all file-visiting buffers without asking.
  If there are active processes where `process-query-on-exit-flag'
  returns non-nil and `confirm-kill-processes' is non-nil,
  asks whether processes should be killed.
  Runs the members of `kill-emacs-query-functions' in turn and stops
  if any returns nil.  If `confirm-kill-emacs' is non-nil, calls it.
  Instead of just killing Emacs, shuts down the system."
    (interactive "P")
    ;; Don't use save-some-buffers-default-predicate, because we want
    ;; to ask about all the buffers before killing Emacs.
    (save-some-buffers arg t)
    (let ((confirm confirm-kill-emacs))
      (and
       (or (not (memq t (mapcar (function
                              (lambda (buf) (and (buffer-file-name buf)
                                          (buffer-modified-p buf))))
                             (buffer-list))))
          (progn (setq confirm nil)
                 (yes-or-no-p "Modified buffers exist; shut down anyway? ")))
       (or (not (fboundp 'process-list))
          ;; process-list is not defined on MSDOS.
          (not confirm-kill-processes)
          (let ((processes (process-list))
                active)
            (while processes
              (and (memq (process-status (car processes)) '(run stop open listen))
                 (process-query-on-exit-flag (car processes))
                 (setq active t))
              (setq processes (cdr processes)))
            (or (not active)
               (with-current-buffer-window
                (get-buffer-create "*Process List*") nil
                #'(lambda (window _value)
                    (with-selected-window window
                      (unwind-protect
                          (progn
                            (setq confirm nil)
                            (yes-or-no-p (concat "Active processes exist; kill "
                                                 "them and shut down anyway? ")))
                        (when (window-live-p window)
                          (quit-restore-window window 'kill)))))
                (list-processes t)))))
       ;; Query the user for other things, perhaps.
       (run-hook-with-args-until-failure 'kill-emacs-query-functions)
       (or (null confirm)
          (funcall confirm "Really shut down? "))
       (shell-command "shutdown now")
       (kill-emacs))))

  (global-set-key (kbd "C-x C-M-c") 'save-buffers-shut-down)
#+END_SRC
**** Rebooting
I copied the function for quitting Emacs to handle reboot too.
#+BEGIN_SRC emacs-lisp
  (defun save-buffers-reboot (&optional arg)
    "Offer to save each buffer, then shut down the computer.
  This function is literally just a copycat of `save-buffers-kill-emacs'.
  With prefix ARG, silently save all file-visiting buffers without asking.
  If there are active processes where `process-query-on-exit-flag'
  returns non-nil and `confirm-kill-processes' is non-nil,
  asks whether processes should be killed.
  Runs the members of `kill-emacs-query-functions' in turn and stops
  if any returns nil.  If `confirm-kill-emacs' is non-nil, calls it.
  Instead of just killing Emacs, shuts down the system."
    (interactive "P")
    ;; Don't use save-some-buffers-default-predicate, because we want
    ;; to ask about all the buffers before killing Emacs.
    (save-some-buffers arg t)
    (let ((confirm confirm-kill-emacs))
      (and
       (or (not (memq t (mapcar (function
                              (lambda (buf) (and (buffer-file-name buf)
                                          (buffer-modified-p buf))))
                             (buffer-list))))
          (progn (setq confirm nil)
                 (yes-or-no-p "Modified buffers exist; reboot anyway? ")))
       (or (not (fboundp 'process-list))
          ;; process-list is not defined on MSDOS.
          (not confirm-kill-processes)
          (let ((processes (process-list))
                active)
            (while processes
              (and (memq (process-status (car processes)) '(run stop open listen))
                 (process-query-on-exit-flag (car processes))
                 (setq active t))
              (setq processes (cdr processes)))
            (or (not active)
               (with-current-buffer-window
                (get-buffer-create "*Process List*") nil
                #'(lambda (window _value)
                    (with-selected-window window
                      (unwind-protect
                          (progn
                            (setq confirm nil)
                            (yes-or-no-p (concat "Active processes exist; kill "
                                                 "them and reboot anyway? ")))
                        (when (window-live-p window)
                          (quit-restore-window window 'kill)))))
                (list-processes t)))))
       ;; Query the user for other things, perhaps.
       (run-hook-with-args-until-failure 'kill-emacs-query-functions)
       (or (null confirm)
           (funcall confirm "Really reboot? "))
       (shell-command "reboot")
       (kill-emacs))))

  (global-set-key (kbd "C-x C-M-r") 'save-buffers-reboot)
#+END_SRC
** Keybindings
*** Set a bind for both global and EXWM usage
Save lines, save time.
#+BEGIN_SRC emacs-lisp
  (defun exwm-bind-key (key function)
    (global-set-key key function)
    (define-key exwm-mode-map key function))
#+END_SRC
*** Global binds to use across everything
Anything I couldn't cram into ~desktop-environment-mode~ has been slapped into this area.
#+BEGIN_SRC emacs-lisp
  (setq exwm-input-global-keys
        `(;; Switching Workspaces
          ([?\s-q] . farl-exwm/workspace-1)
          ([?\s-w] . farl-exwm/workspace-0)
          ([?\s-e] . farl-exwm/workspace-2)

          ;; Opening X applications
          ([?\s-g]    . run-gimp)
          ([?\s-s]    . run-steam)
          ([?\s-f]    . run-firefox)
          ([?\s-d]    . run-discord)
          ([?\s-t]    . run-telegram)
          ([?\s-m]    . run-musescore)
          ([?\s-b]    . run-libreoffice)
          ([?\s-o]    . run-transmission)
          ([?\s-r]    . monitor-settings)
          ([?\s-n]    . network-settings)
          ([?\s-v]    . volume-settings)
          ([s-return] . vterm)

          ;; Other desktop environment things
          ([?\s-x]       . dmenu)
          ([menu]        . smex)
          ([?\s- ]       . cycle-keyboard-layout)
          ([s-backspace] . cycle-keyboard-layout-reverse)
          ([s-tab]       . audio-loopback)

          ;; Controlling EMMS
          ([XF86AudioNext] . emms-next)
          ([XF86AudioPrev] . emms-previous)
          ([XF86AudioPlay] . emms-pause)
          ([XF86AudioStop] . emms-stop)))
#+END_SRC
*** Emacs key bindings in X windows
This is super nice, because I love these key bindings and they are just intuitive to me, and now they can carry over safely to other programs.
#+BEGIN_SRC emacs-lisp
  (setq exwm-input-simulation-keys
        '(;; Navigation
          ([?\C-b] . [left])
          ([?\C-f] . [right])
          ([?\C-p] . [up])
          ([?\C-n] . [down])

          ([?\M-b] . [C-left])
          ([?\M-f] . [C-right])
          ([?\M-p] . [C-up])
          ([?\M-n] . [C-down])

          ([?\C-a] . [home])
          ([?\C-e] . [end])
          ([?\C-v] . [next])
          ([?\M-v] . [prior])

          ;; Copy/Paste
          ([?\C-w] . [?\C-x])
          ([?\M-w] . [?\C-c])
          ([?\C-y] . [?\C-v])
          ([?\C-s] . [?\C-f])
          ([?\C-\/] . [?\C-z])

          ;; Other
          ([?\C-d] . [delete])
          ([?\C-k] . [S-end delete])
          ([?\C-g] . [escape])))

  ;; I can't do sequences above, so this is separate
  (defun exwm-C-s ()
    "Pass C-s to the EXWM window."
    (interactive)
    (execute-kbd-macro (kbd "C-q C-s")))

  (define-key exwm-mode-map (kbd "C-x C-s") 'exwm-C-s)
#+END_SRC
*** Send a key verbatim more easily
#+BEGIN_SRC emacs-lisp
  (define-key exwm-mode-map (kbd "C-c C-q") nil)
  (define-key exwm-mode-map (kbd "C-q") 'exwm-input-send-next-key)
#+END_SRC
*** Inhibit things I don't use
This includes:
- Toggling fullscreen
- Toggling floating
- Toggling hiding
- Toggling the mode line
#+BEGIN_SRC emacs-lisp
  (dolist (key '("C-c C-t C-f"
                 "C-c C-t C-v"
                 "C-c C-t C-m"
                 "C-c C-f"))
    (define-key exwm-mode-map (kbd key) nil))
#+END_SRC
** On startup
*** Always hide the cursor when typing
Just a personal preference, I don't like seeing the cursor when I'm pressing keys.
#+BEGIN_SRC emacs-lisp
  (start-process-shell-command
   "Cursor Hiding" nil "xbanish")
#+END_SRC
*** Disable screen blanking
I don't need my laptop's screen shutting off just because I'm sitting and watching a video too long.
#+BEGIN_SRC emacs-lisp
  (start-process-shell-command
   "Disable Blanking" nil "xset s off -dpms")
#+END_SRC
*** Keyboard configuration
This block sets the keyboard layout to US and give Caps Lock the functionality of Control. I was hesitant to do this at first, but it's significantly more comfortable. I almost never used caps lock as it is, given my keyboards have no indicator for it on my laptops, but this gives me a much easier way to do commands without shifting my hand too far.
#+BEGIN_SRC emacs-lisp
  (start-process-shell-command
   "Keyboard Layout" nil "setxkbmap us -option ctrl:nocaps")
#+END_SRC
*** Set fallback cursor
Some X windows will have weird cursors if this isn't done.
#+BEGIN_SRC emacs-lisp
  (start-process-shell-command
   "Fallback Cursor" nil "xsetroot -cursor_name left_ptr")
#+END_SRC
*** Compositor
I don't need it, but having basic compositing is very nice.
#+BEGIN_SRC emacs-lisp
  (start-process-shell-command
   "Compositor" nil "xcompmgr")
#+END_SRC
*** Start EXWM
#+BEGIN_SRC emacs-lisp
  (exwm-enable)
  (exwm-config-ido)
  (exwm-systemtray-enable)
#+END_SRC
#+BEGIN_SRC emacs-lisp :exports none
  )
#+END_SRC
* EMMS (Emacs MultiMedia System)
I am big on doing as much in Emacs as possible. Having my music player moved to Emacs was a HUGE step. When I first started using it, it was weird, but now I have come to absolutely love it. This is only loaded if ~mpd~ is found.
#+BEGIN_SRC emacs-lisp :exports none
  (when (executable-find "mpd")
#+END_SRC
** Install EMMS
All I do here is configure EMMS. Binding keys is later.
#+BEGIN_SRC emacs-lisp
  (use-package emms
    :ensure t
    :defer t
    :init
    (require 'emms-setup)
    (require 'emms-player-mpd)
    (emms-all)
    (setq emms-seek-seconds 5
	  emms-player-list '(emms-player-mpd)
	  emms-info-functions '(emms-info mpd)
	  emms-player-mpd-server-name "localhost"
	  emms-player-mpd-server-port "6601"
	  mpc-host "localhost:6601"))
#+END_SRC
** Daemon functions
*** Starting the daemon
#+BEGIN_SRC emacs-lisp
  (defun mpd/start-music-daemon ()
    "Start MPD, connect to it and sync the metadata cache"
    (interactive)
    (shell-command "mpd")
    (mpd/update-database)
    (emms-player-mpd-connect)
    (emms-cache-set-from-mpd-all)
    (message "MPD started!"))
#+END_SRC
*** Stopping the daemon
#+BEGIN_SRC emacs-lisp
  (defun mpd/kill-music-daemon ()
    "Stop playback and kill the music daemon."
    (interactive)
    (emms-stop)
    (call-process "killall" nil nil nil "mpd")
    (message "MPD killed!"))
#+END_SRC
*** Updating the database
#+BEGIN_SRC emacs-lisp
  (defun mpd/update-database ()
    "Update the MPD database synchronously."
    (interactive)
    (call-process "mpc" nil nil nil "update")
    (message "MPD database updated!"))
#+END_SRC
*** Shuffling the playlist
#+BEGIN_SRC emacs-lisp
  (defun farl-emms/shuffle-with-message ()
    "Shuffle the playlist and say so in the echo area."
    (interactive)
    (emms-shuffle)
    (message "Playlist has been shuffled."))
#+END_SRC
** Binding all the keys
Now using a keymap in place of that wonky as crap binding system. The new binds let me use ~emms~ in a terminal.
#+BEGIN_SRC emacs-lisp
  (defvar emms-map
    (let ((map (make-sparse-keymap)))
      ;; Opening playlist and music browser
      (define-key map (kbd "v") 'emms)
      (define-key map (kbd "b") 'emms-smart-browse)
      ;; Track navigation
      (define-key map (kbd "n n") 'emms-next)
      (define-key map (kbd "n p") 'emms-previous)
      (define-key map (kbd "p") 'emms-pause)
      (define-key map (kbd "s") 'emms-stop)
      ;; Repeat/shuffle
      (define-key map (kbd "t C-r") 'emms-toggle-repeat-track)
      (define-key map (kbd "t r") 'emms-toggle-repeat-playlist)
      (define-key map (kbd "t s") 'farl-emms/shuffle-with-message)
      ;; Refreshing various things
      (define-key map (kbd "r c") 'emms-player-mpd-update-all-reset-cache)
      (define-key map (kbd "r d") 'mpd/update-database)
      ;; mpd specific functions
      (define-key map (kbd "d s") 'mpd/start-music-daemon)
      (define-key map (kbd "d q") 'mpd/kill-music-daemon)
      (define-key map (kbd "d u") 'mpd/update-database)
      map)
    "A keymap for controlling `emms'.")
  (global-set-key (kbd "C-c a") emms-map)
#+END_SRC
#+BEGIN_SRC emacs-lisp :exports none
  )
#+END_SRC
* General Functionality
This is just stuff not pertaining to a specific task and/or not complex enough to warrant entire sections for them.
** Disable suspending Emacs
Why is this even something bound to begin with?
#+BEGIN_SRC emacs-lisp
  (dolist (key '("C-x C-z"
                 "C-z"))
    (global-unset-key (kbd key)))
#+END_SRC
** Don't make extra files on the filesystem
I don't use auto-saves and backups. I love living on the edge.
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil
        auto-save-default nil)
#+END_SRC
** Use a visual bell instead of sound
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore
        visible-bell t)
#+END_SRC
** Automatically revert files on change
This way if files get modified in the middle of editing them, I don't overwrite the changes.
#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode 1)
#+END_SRC
** Don't unload fonts after loading them
This solves a number of hanging issues related to a number of different packages and symbols.
#+BEGIN_SRC emacs-lisp
  (setq inhibit-compacting-font-caches t)
#+END_SRC
** End-of-file newlines and indent tabs
Screw indent tabs, spaces all the way.
#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)
  (setq-default indent-tabs-mode nil)
#+END_SRC
** Enable word wrapping for all buffers
This is a point of convenience, even in programming language buffers. Wrapping words makes for a heck of a lot more readability of any kind of text, whether a program or just normal language.
#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode 1)
#+END_SRC
** Move between SubWords as well as between words
This allows for much easier navigation between words when in programming language buffers, but also has utility outside of programming so it's enabled globally.
#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC
** Delete whatever is selected if typing starts
This is to reflect behavior in other programs.
#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC
** Spell-checking
Just a useful little tool to check spelling while editing a buffer. Only configured if ~aspell~ is installed.
#+BEGIN_SRC emacs-lisp
  (when (executable-find "aspell")
    (require 'flyspell)

    (setq ispell-program-name "aspell"
          ispell-dictionary "american")

    (add-hook 'flyspell-mode-hook 'flyspell-buffer)
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)
    (add-hook 'text-mode-hook 'flyspell-mode))
#+END_SRC
** Always confirm killing Emacs
I constantly kill Emacs on accident when running it in terminals, so this prevents me from doing that +as easily+.
#+BEGIN_SRC emacs-lisp
  (setq confirm-kill-emacs 'yes-or-no-p)
#+END_SRC
** Make scrolling a little less crazy
Not sure why the mouse wheel get acceleration, but thankfully I don't have to worry about that anymore.
#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 0
        scroll-conservatively 100000
        scroll-preserve-screen-position 1
        mouse-wheel-scroll-amount '(1 ((shift) . 1))
        mouse-wheel-progressive-speed nil
        mouse-wheel-follow-mouse t)
#+END_SRC
** Edit with superuser privileges via =C-x C-M-f=
#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :ensure t
    :defer t
    :bind ("C-x C-M-f" . sudo-edit))
#+END_SRC
** Open/create the scratch buffer with =C-c s=
The scratch buffer is immortal now.
#+BEGIN_SRC emacs-lisp
  (defun open-scratch-buffer ()
    "Open the scratch buffer."
    (interactive)
    (switch-to-buffer (get-buffer "*scratch*")))

  (with-current-buffer "*scratch*"
    (emacs-lock-mode 'kill))

  (global-set-key (kbd "C-c s") 'open-scratch-buffer)
#+END_SRC
** Restart and open dashboard with =C-c M-d=
I constantly accidentally close dashboard, so I made a way to open it again if I accidentally kill it.
#+BEGIN_SRC emacs-lisp
  (defun dashboard-restart ()
    "Restart the dashboard buffer and switch to it."
    (interactive)
    (dashboard-insert-startupify-lists)
    (switch-to-buffer "*dashboard*"))

  (global-set-key (kbd "C-c M-d") 'dashboard-restart)
#+END_SRC
** Change current directory with =C-c d=
Useful when getting lost in the filesystem!
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c d") 'cd)
#+END_SRC
** Open configuration with =C-c e=
Since this thing is changing all the time, I really like having it available on a shortcut.
#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    "Open the config file."
    (interactive)
    (find-file "~/.emacs.d/config.org"))

  (global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC
** graphviz-dot-mode package (diagram creation)
A nice way to make diagrams.
#+BEGIN_SRC emacs-lisp
  (use-package graphviz-dot-mode
    :ensure t
    :defer t
    :init
    (require 'graphviz-dot-mode))
#+END_SRC
* Other Emacs Goodies
This is other stuff I use in Emacs.
** Terminal
I've been jumping between ~vterm~ and ~ansi-term~. I guess ~vterm~ is just easier to use. In the off-chance I'm running Emacs in the terminal, =C-c t= is usable to open the terminal.
#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :ensure t
    :defer t
    :bind ("C-c t" . vterm))
#+END_SRC
** Calendar
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c l") 'calendar)
#+END_SRC
** Calculator
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c c") 'calc)
#+END_SRC
** Reading the manpages
Wow, there's actually an Emacs mode for this!
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c m") 'man)
#+END_SRC
** nov package (epub reader)
Not the best way to do epub reading, but at least it's in Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package nov
    :ensure t
    :defer t
    :mode ("\\.epub\\'" . nov-mode))
#+END_SRC
** wttrin package (weather forecasts)
Picking a service to use for this was a pain. I ended up settling for wttrin because it is the fastest and easiest to use, and plays nice with my setup.
#+BEGIN_SRC emacs-lisp
  (use-package wttrin
    :ensure t
    :defer t
    :init
    (setq wttrin-default-cities '("Indianapolis"
                                  "Wadsworth"))
    :bind ("C-c w" . wttrin))
#+END_SRC
** Games
To make running games easier, I set up a keymap to which I add the games.
#+BEGIN_SRC emacs-lisp
  (defvar games-map
    (make-sparse-keymap)
    "A keymap to which games can be added.")
  (global-set-key (kbd "C-M-g") games-map)
#+END_SRC
*** Chess
Just for fun. I suck but it's nice.
#+BEGIN_SRC emacs-lisp
  (use-package chess
    :ensure t
    :defer t
    :bind (:map games-map
           ("c" . chess)))
#+END_SRC
*** Sudoku
I /love/ sudoku puzzles.
#+BEGIN_SRC emacs-lisp
  (use-package sudoku
    :ensure t
    :defer t
    :bind (:map games-map
           ("s" . sudoku)))
#+END_SRC
*** Tetris
God I love playing Tetris
#+BEGIN_SRC emacs-lisp
  (use-package tetris
    :ensure t
    :defer t
    :bind (:map games-map
           ("t" . 'tetris)
           :map tetris-mode-map
           ("w" . tetris-move-bottom)
           ("a" . tetris-move-left)
           ("s" . tetris-mode-down)
           ("d" . tetris-move-right)
           ([left] . tetris-rotate-next)
           ([right] . tetris-rotate-prev)
           ([?\t] . tetris-pause-game)
           ("r" . tetris-start-game)
           ("e" . tetris-end-game)))
#+END_SRC
*** 2048
A simple and fun game
#+BEGIN_SRC emacs-lisp
  (use-package 2048-game
    :ensure t
    :defer t
    :bind (:map games-map
           ("2" . 2048-game)))
#+END_SRC
* Buffers/Windows
** Sloppy focus
I hate having to click to focus a different window, so I would rather just have windows sloppily focus.
#+BEGIN_SRC emacs-lisp
  (setq focus-follows-mouse t
        mouse-autoselect-window t)
#+END_SRC
** Uniquify buffer name behavior
This looks a lot fancier than the default behavior.a
#+BEGIN_SRC emacs-lisp
  (setq uniquify-buffer-name-style 'forward
        uniquify-after-kill-buffer-p t)
#+END_SRC
** Kill current buffer with =C-x k=, use =C-x C-k= to kill the window too
I had to adjust the function which kills both the current buffer and the current window, because it did not cooperate with EXWM buffers. That's why I have this weird chunk I don't actually have the expertise yet to fully parse.
#+BEGIN_SRC emacs-lisp
  (defun kill-this-buffer-and-window ()
    "Kill the current buffer and delete the selected window. (Adjusted for EXWM.)"
    (interactive)
    (let ((window-to-delete (selected-window))
          (buffer-to-kill (current-buffer))
          (delete-window-hook (lambda () (ignore-errors (delete-window)))))
      (unwind-protect
          (progn
            (add-hook 'kill-buffer-hook delete-window-hook t t)
            (if (kill-buffer (current-buffer))
                ;; If `delete-window' failed before, we repeat
                ;; it to regenerate the error in the echo area.
                (when (eq (selected-window) window-to-delete)
                  (delete-window)))))))

  (global-set-key (kbd "C-x k") 'kill-this-buffer)
  (global-set-key (kbd "C-x C-k") 'kill-this-buffer-and-window)
#+END_SRC
** Close all buffers and kill all windows with =C-x C-M-k=
I wanted a way to quickly and gracefully destroy all my open stuff at once.
#+BEGIN_SRC emacs-lisp
  (defun close-buffers-and-windows ()
    "Close every buffer and close all windows, then restart dashboard."
    (interactive)
    (save-some-buffers)
    (when (yes-or-no-p "Really kill all buffers? ")
      (mapc 'kill-buffer (buffer-list))
      (delete-other-windows)
      (dashboard-restart)))

  (global-set-key (kbd "C-x C-M-k") 'close-buffers-and-windows)
#+END_SRC
** Use buffer-menu on =C-x b= so the buffer list doesn't open a new window
Just another point of personal convenience. I don't like ~ibuffer~ just because aesthetic reasons. I also set Q to close the window, for convenience.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x b") 'ibuffer)
  (global-unset-key (kbd "C-x C-b"))
#+END_SRC
** Move focus and show buffer-menu when explicitly creating new windows
This to me is preferable to the default behavior.
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-vertical ()
    "Open a new window vertically."
    (interactive)
    (split-window-below)
    (other-window 1)
    (ibuffer))

  (defun split-and-follow-horizontal ()
    "Open a new window horizontally."
    (interactive)
    (split-window-right)
    (other-window 1)
    (ibuffer))

  (global-set-key (kbd "C-x 2") 'split-and-follow-vertical)
  (global-set-key (kbd "C-x 3") 'split-and-follow-horizontal)
#+END_SRC
** Balance windows with =C-c b=
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c b") 'balance-windows)
#+END_SRC
** buffer-move package and windmove (moving focus and moving windows)
Since apparently =C-x C-o= is actually something useful by default, I decided to squash ~windmove~ and ~buffer-move~ into a single keymap.
#+BEGIN_SRC emacs-lisp
  (use-package buffer-move
    :ensure t
    :defer t
    :init
    (defvar buffer-move-and-windmove-map
      (let ((map (make-sparse-keymap)))
        (define-key map (kbd "w") 'windmove-up)
        (define-key map (kbd "a") 'windmove-left)
        (define-key map (kbd "s") 'windmove-down)
        (define-key map (kbd "d") 'windmove-right)
        (define-key map (kbd "C-w") 'buf-move-up)
        (define-key map (kbd "C-a") 'buf-move-left)
        (define-key map (kbd "C-s") 'buf-move-down)
        (define-key map (kbd "C-d") 'buf-move-right)
        map)
      "A keymap for `buffer-move' and `windmove' functions.")
    (global-set-key (kbd "C-x o") buffer-move-and-windmove-map))
#+END_SRC
* Menus/Commands
Menus, commands, and commands which involve menus.
** Enable ido-mode, install ido-vertical-mode and smex
I /love/ ~ido-mode~. However, I /HATE/ ~ido-mode~ right out of the box. A vertical list looks craptons nicer. Both ~ido-mode~ and ~ido-vertical-mode~ are configured in the same block. Default M-x behavior doesn't use ~ido-mode~, so we install a package which gives it ~ido-mode~ capabilities.
#+BEGIN_SRC emacs-lisp
  (use-package ido-vertical-mode
    :ensure t
    :defer t
    :init
    (setq ido-mode-flex-matching nil
          ido-create-new-buffer 'always
          ido-everywhere t
          ido-vertical-define-keys 'C-n-and-C-p-only
          ido-enable-flex-matching t)
    (ido-mode 1)
    (ido-vertical-mode 1)
    (use-package smex
      :ensure t
      :defer t
      :bind (("M-x"    . smex)
             ("<menu>" . smex))))
#+END_SRC
** Replace "yes or no" prompts with "y or n"
Beauty in brevity.
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** which-key package (small menus to help with commands)
Even as I've gotten used to Emacs key bindings, it is always nice to have this around so that if I want to know, I can easily see what's what.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :defer t
    :init
    (which-key-mode 1))
#+END_SRC
** popup-kill-ring package (easier time managing the kill ring)
Having the whole kill ring easy to scroll through is much less hassle than default behavior. We also set up some yanking behavior while we're at it.
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :defer t
    :bind ("M-y" . popup-kill-ring)
    :init
    (setq save-interprogram-paste-before-kill t
          mouse-drag-copy-region t
          mouse-yank-at-point t))
#+END_SRC
** swiper package (better searches)
This search behavior is *SO* much nicer than the default.
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :defer t
    :bind ("C-s" . swiper))
#+END_SRC
** Kill an entire word when you're in the middle of it
I don't need it super often, but it's still nice to have.
#+BEGIN_SRC emacs-lisp
  (defun whole-kill-word ()
    "Delete an entire word."
    (interactive)
    (backward-word)
    (kill-word 1))

  (global-set-key (kbd "C-c DEL") 'whole-kill-word)
#+END_SRC
** avy package (faster moving around documents)
If I want to hop around in a document without calling swiper, ~avy~ is definitely the way to go.
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :defer t
    :bind ("M-s" . avy-goto-char))
#+END_SRC
** hungry-delete package (convenient deletion of trailing whitespace)
This saves me tons of time when it comes to managing whitespace.
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :ensure t
    :defer t
    :init
    (global-hungry-delete-mode 1))
#+END_SRC
** company package (autocomplete backend)
This is the base package. I changed some key bindings to make it more pleasant to use.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :defer t
    :init
    (setq company-idle-delay 0.75
          company-minimum-prefix-length 3)
    (global-company-mode 1)
    :bind (:map company-active-map
           ("M-n" . nil)
           ("M-p" . nil)
           ("C-n" . company-select-next)
           ("C-p" . company-select-previous)
           ("SPC" . company-abort)))
#+END_SRC
* Programming
It's slowly growing, but I still truly do not need all that much when it comes to programming, mostly because I don't actually do all that much programming outside what I do for fun.
** magit package (git but made easier)
I used to use a terminal for this, but holy crap this is a lot easier, a lot faster, and a whole lot nicer to use overall.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :defer t
    :bind ("C-c g" . magit-status))
#+END_SRC
** flycheck package (on-the-fly syntax checker)
This is nice to have so I can be told right away when I'm doing something wrong. However, I /DON'T/ want to see all the stuff about documentation for elisp.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :defer t
    :init
    (global-flycheck-mode 1))
#+END_SRC
** avy-flycheck package (avy but also flycheck)
This one is SUPER COOL.
#+BEGIN_SRC emacs-lisp
  (use-package avy-flycheck
    :ensure t
    :defer t
    :bind (:map prog-mode-map
           ("C-c C-'" . avy-flycheck-goto-error)))
#+END_SRC
** company-jedi package (Python autocompletion)
I will probably be adding company autocompletion for more languages as I start working in more languages.
#+BEGIN_SRC emacs-lisp
  (use-package company-jedi
    :ensure t
    :defer t
    :init
    (add-to-list 'company-backends 'company-jedi))
#+END_SRC
** haskell-mode package (self-explanatory)
I have started to mess around with Haskell, so I needed to grab a mode for that. This supplies basically everything I need, e.g. company autocompletion and flycheck information.
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure t
    :defer t
    :init
    (setq haskell-stylish-on-save t)
    :hook ((haskell-mode . interactive-haskell-mode)
           (haskell-mode . turn-on-haskell-doc-mode)
           (haskell-mode . haskell-indentation-mode)
           (haskell-mode . haskell-auto-insert-module-template)))
#+END_SRC
** electric-pair-mode (OH MY GOD THIS IS SO GREAT)
I have no words for how convenient this has been and how much faster I get things done thanks to these five lines of elisp.
#+BEGIN_SRC emacs-lisp
  (setq electric-pair-pairs '((?\{ . ?\})
                              (?\( . ?\))
                              (?\[ . ?\])
                              (?\" . ?\")))
  (electric-pair-mode 1)
  (minibuffer-electric-default-mode 1)
#+END_SRC
* Org-mode
As I spend more time in Org-mode, the more I need from it.
** markdown-mode (bootleg org-mode)
Not sure where else to put this, so...
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :defer t)
#+END_SRC
** Agenda (only enabled if an agenda is found)
I use =C-c M-a= and =C-c s-a= to do things related to my agenda. Only one of my systems actually has my agenda, so this only runs on that machine so I don't try any funny business on other machines.
#+BEGIN_SRC emacs-lisp
  (when (file-exists-p "~/agenda.org")
    (setq org-agenda-files '("~/agenda.org"))

    (defun open-agenda ()
      "Open the agenda file."
      (interactive)
      (find-file "~/agenda.org"))

    (global-set-key (kbd "C-c M-a") 'org-agenda)
    (global-set-key (kbd "C-c s-a") 'open-agenda))
#+END_SRC
** Quality of life settings
These are just quick things that make ~org-mode~ much easier to use.
#+BEGIN_SRC emacs-lisp
  (setq org-pretty-entities t
        org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-src-window-setup 'current-window
        org-fontify-whole-heading-line t
        org-fontify-done-headline t
        org-fontify-quote-and-verse-blocks t
        org-highlight-latex-and-related '(latex)
        org-enforce-todo-dependencies t
        org-agenda-use-time-grid nil
        org-agenda-skip-deadline-if-done t
        org-agenda-skip-scheduled-if-done t)
#+END_SRC
** Shortcuts for various snippets in org-mode
This will expand as I get into more and more languages and take more notes in classes with different snippets of different languages.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist
               '("py" "#+BEGIN_SRC python\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist
               '("dot" "#+BEGIN_SRC dot :file ?.png :cmdline -Kdot -Tpng\n\n#+END_SRC"))
#+END_SRC
** Use the current window when editing source code in org-mode
This is just a convenience thing.
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC
** Automatically fix inline images generated for diagrams
This is exactly what I was looking for lmao
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
#+END_SRC
** Skip confirming whether to evaluate dot snippets
Since obviously dot snippets are purely harmless +as far as I know+, I just don't bother with having to confirm evaluation every time I try to update a graphic.
#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate '(lambda (lang body) (not (eq lang "dot"))))
#+END_SRC
** Load various languages in org-babel
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages 'org-babel-load-languages '((dot . t)))
#+END_SRC
** In graphical environments
#+BEGIN_SRC emacs-lisp :exports none
  (when (window-system)
#+END_SRC
*** Fancy symbol for collapsed items
Just makes ~org-mode~ look a little fancier, no distinct changes.
#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "⤵")
#+END_SRC
*** org-bullets package (nicer bullet points in org-mode)
It's kinda slow, but bullet points are very very nice, much better than asterisks.
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :defer t
    :hook (org-mode . org-bullets-mode))
#+END_SRC
*** Hide emphasis markers in org-mode
Just a point of /personal preference./ I was considering keeping this in for non-graphical environments, but I can't always trust that there will be support for the different representations of text.
#+BEGIN_SRC emacs-lisp
  (setq org-hide-emphasis-markers t)
#+END_SRC
*** epresent package
It's gonna need more polish, but it works.
#+BEGIN_SRC emacs-lisp
  (use-package epresent
    :ensure t
    :defer t
    :bind (:map org-mode-map
           ("C-c r" . epresent-run)))
#+END_SRC
#+BEGIN_SRC emacs-lisp :exports none
  )
#+END_SRC
* Looks
** General
*** Line numbers
I like having line numbers. However, I don't like line numbers in modes where it breaks the mode.
#+BEGIN_SRC emacs-lisp
  (global-display-line-numbers-mode 1)

  (dolist (hook '(Man-mode-hook
                  nov-mode-hook
                  shell-mode-hook
                  vterm-mode-hook
                  shell-mode-hook
                  snake-mode-hook
                  tetris-mode-hook
                  sudoku-mode-hook
                  custom-mode-hook
                  ibuffer-mode-hook
                  epresent-mode-hook
                  dashboard-mode-hook))
    (add-hook hook (lambda () (display-line-numbers-mode -1))))
#+END_SRC
*** Highlight matching parentheses et al. when hovering near one
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (setq show-paren-style 'parenthesis
        show-paren-delay 0)
#+END_SRC
** In graphical environments
This stuff really only helps when you're in a graphical environment. Running Emacs from a terminal means these things might not work, so I don't load them when not in a graphical environment.
#+BEGIN_SRC emacs-lisp :exports none
  (when (window-system)
#+END_SRC
*** Theme
I used to hate light themes. I'm not in that camp anymore. This theme is /elegant/.
#+BEGIN_SRC emacs-lisp
  (use-package leuven-theme
    :ensure t
    :defer t
    :init
    (load-theme 'leuven t))
#+END_SRC
*** Font
Originally I had this set up by means of ~custom-set-faces~, but frankly that is less easily configured than this method. First, we determine whether my preferred font is present on the system and set it if present. Otherwise, keep the default that Emacs chooses.
#+BEGIN_SRC emacs-lisp
  (when (member "Iosevka" (font-family-list))
      (set-face-attribute 'default nil :font "Iosevka"))
#+END_SRC
Then, we need to determine what size to make the text. This is based on the width of the screens I regularly use. It uses shell commands for X window systems and built-in functions for Windows.
#+BEGIN_SRC emacs-lisp
  (let* ((res (if (eq (window-system) 'x)
                  (string-to-number
                   (shell-command-to-string
                    (concat "xrandr | grep \\* | "
                            "cut -d x -f 1 | "
                            "sort -n | head -n 1")))
                (/ (display-pixel-width) (display-screens))))
           (size (if (<= res 1366) 100
                   (if (<= res 1920) 150
                     (if (<= res 2560) 180
                       (if (<= res 3840) 220
                         240))))))
    (set-face-attribute 'default nil :height size))
#+END_SRC
*** Window dividers/fringes
Fringes and dividers look far fancier than the alternatives.
#+BEGIN_SRC emacs-lisp
  (setq window-divider-default-right-width 3)
  (dolist (face '(window-divider
                  window-divider-last-pixel
                  window-divider-first-pixel))
    (set-face-foreground face "#335ea8"))
  (window-divider-mode 1)
  (fringe-mode 10)
#+END_SRC
*** pretty-mode package (prettify symbols)
I don't like ~prettify-symbols-mode~. It doesn't do enough. This one helps so much more to make things look nice, especially in functional programming languages. I enable /all/ of them.
#+BEGIN_SRC emacs-lisp
  (use-package pretty-mode
    :ensure t
    :defer t
    :init
    (global-pretty-mode 1)
    (pretty-activate-groups '(:nil
                              :sets
                              :logic
                              :greek
                              :types
                              :other
                              :arrows
                              :ordering
                              :equality
                              :function
                              :undefined
                              :arithmetic
                              :parentheses
                              :punctuation
                              :quantifiers
                              :sub-and-superscripts)))
#+END_SRC
*** rainbow package (show colors when typed as hex codes)
I don't use it too much, but it's nice to have it around.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :defer t
    :init
    (define-globalized-minor-mode global-rainbow-mode rainbow-mode rainbow-mode)
    (global-rainbow-mode 1))
#+END_SRC
*** rainbow-delimiters package (better quotes/parentheses/brackets)
It's subtle on my theme, but it still helps me keep track of my brackets and parentheses.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :defer t
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC
#+BEGIN_SRC emacs-lisp :exports none
  )
#+END_SRC
** Mode line
*** spaceline package (Spacemacs mode line)
I *hate* the default mode line. This one is much less sucky. I also show and hide specific useful things when setting it up. In terminals, ~spaceline-emacs-theme~ just looks wrong, so I don't use it unless I'm in a graphical environment.
#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :ensure t
    :defer t
    :init
    (require 'spaceline-config)
    (setq powerline-default-separator 'wave
          spaceline-buffer-encoding-abbrev-p nil
          spaceline-buffer-size-p nil
          spaceline-line-column-p t
          column-number-indicator-zero-based nil)
    (if (window-system)
        (spaceline-emacs-theme)
      (spaceline-spacemacs-theme)))
#+END_SRC
*** Show clock and battery level on mode line
I used to use ~fancy-battery~ but it constantly disappeared on my teeny tiny screens so I just decided not to bother with it. Plus it's one less package to configure lol.
#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format t)
  (display-time-mode 1)
  (display-battery-mode 1)
#+END_SRC
*** diminish package (hide minor modes from mode line)
Works very nicely, makes the mode line far comfier.
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t
    :diminish (eldoc-mode
               subword-mode
               company-mode
               rainbow-mode
               flycheck-mode
               flyspell-mode
               which-key-mode
               auto-revert-mode
               visual-line-mode
               haskell-doc-mode
               flyspell-prog-mode
               hungry-delete-mode
               page-break-lines-mode
               desktop-environment-mode
               haskell-indentation-mode
               interactive-haskell-mode
               compilation-shell-minor-mode))
#+END_SRC
