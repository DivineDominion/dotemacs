#+STARTUP: overview
#+TITLE: Farlado's .emacs
#+DESCRIPTION: Farlado's personal emacs configuration
#+CREATOR: Farlado
#+LANGUAGE: en
#+OPTIONS: num:nil
#+ATTR_HTML: :style margin-left: auto; margin-right: auto;
[[./logo.png]]

* Installation
1) Clone the repo into your home directory as ~.emacs.d~.
2) Inside the repo, choose your font/border sizes using ~make~. The options are ~hires~ and ~lores~. The default is ~lores~.
3) Make sure if you aren't going to use EXWM you remove everything in the ~EXWM~ section of ~config.org~
* Startup
Since I use emacs as my window manager, there's a lot of extra stuff beyond only emacs-related things in here. You might want to clean them out if you don't intend to use EXWM.
** Start emacs server
Although I technically don't /have/ to do this, it is very helpful when I use terminals.
#+BEGIN_SRC emacs-lisp
  (server-start)
#+END_SRC
** UTF-8 encoding
I probably don't have to do this but it makes things work a little smoother.
#+BEGIN_SRC emacs-lisp
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC
** dashboard package (replacement start screen)
I love the default start screen, but it just doesn't cut it for me. I just use this to have a nice screen when I start emacs or close all my buffers.
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :config
    (setq inhibit-start-menu t
	  dashboard-startup-banner "~/.emacs.d/logo.png"
	  dashboard-items '((recents . 10))
	  show-week-agenda-p t
	  dashboard-banner-logo-title "Welcome to GNU Emacs"
	  dashboard-set-footer nil
	  initial-buffer-choice (lambda ()
				  (get-buffer "*dashboard*")))
    (dashboard-setup-startup-hook))
#+END_SRC
** auto-package-update package (self-explanatory)
I don't want to have to manually update my stuff. This solution is literally plop-and-forget.
#+BEGIN_SRC emacs-lisp
  (use-package auto-package-update
    :ensure t
    :config
    (require 'auto-package-update)
    (setq auto-package-update-interval 2
	  auto-package-update-delete-old-versions t
	  auto-package-update-hide-results t)
    (auto-package-update-maybe))
#+END_SRC
** Set fallback cursor
Some X windows will have weird cursors if this isn't done.
#+BEGIN_SRC emacs-lisp
  (shell-command "xsetroot -cursor_name left_ptr")
#+END_SRC
** Disable screen blanking
I don't need my laptop's screen shutting off just because I'm sitting and watching a video too long.
#+BEGIN_SRC emacs-lisp
  (shell-command "xset s off -dpms")
#+END_SRC
** Set keyboard layout to US
This is a script from [[https://gitlab.com/farlado/dotfiles][my dotfiles]].
#+BEGIN_SRC emacs-lisp
  (shell-command "keyctl -s us")
#+END_SRC
** Give capslock the functionality of control
I was hesitant to do this at first, but it's significantly more comfortable. I almost never used caps lock as it is, given my keyboards have no indicator for it on my laptops, but this gives me a much easier way to do commands without shifting my hand too far.
#+BEGIN_SRC emacs-lisp
  (shell-command "setxkbmap -option ctrl:nocaps")
#+END_SRC
** Compositor
I don't need it, but having basic compositing is very nice.
#+BEGIN_SRC emacs-lisp
  (start-process-shell-command
   "Compositor" nil "xcompmgr")
#+END_SRC
** Notification manager
I haven't integrated notifications into emacs just yet, sadly.
#+BEGIN_SRC emacs-lisp
  (start-process-shell-command
   "Notifications" nil "dunst")
#+END_SRC
* EXWM (Emacs X Window Manager)
Yes, emacs is my window manager. You should probably remove this stuff if you don't plan to use emacs as your window manager. It's loaded right after the startup commands so that I can bind keys more easily later on.
** Configuration
*** exwm package (base window manager)
This isn't actually where we do all the configuration, it's just where we install EXWM and grab what we need to configure it.
#+BEGIN_SRC emacs-lisp
  (use-package exwm
    :ensure t
    :config
    (require 'exwm)
    (require 'exwm-randr)
    (require 'exwm-config)
    (require 'exwm-systemtray))
#+END_SRC
*** dmenu package (dmenu but for emacs)
Since I'm using emacs as a window manager, I need dmenu so I can open X windows I haven't bound to keys.
#+BEGIN_SRC emacs-lisp
  (use-package dmenu
    :ensure t
    :bind (("s-x" . dmenu)
	   :map exwm-mode-map
	   ("s-x" . dmenu)))
#+END_SRC
*** Configure multi-head
I use this configuration for two different machines, so there's a lot of outputs listed here.
#+BEGIN_SRC emacs-lisp
  (setq exwm-randr-workspace-output-plist '(0 "LVDS1"
					    0 "eDP-1-1"
					    0 "DP-1-2-2"
					    1 "DP-1-2-1"
					    2 "DP-1-2-3"
					    3 "DP-1-2-2"
					    4 "DP-1-2-1"
					    5 "DP-1-2-3"
					    6 "DP-1-2-2"
					    7 "DP-1-2-1"
					    8 "DP-1-2-3"
					    9 "DP-1-2-2"))
  (setq exwm-workspace-number 10)
  (add-hook 'exwm-randr-screen-change-hook
	    (lambda () (start-process-shell-command "xrandr" nil "ds")))
  (exwm-randr-enable)
#+END_SRC
*** Name EXWM buffers after the window title
This was annoying when I first installed EXWM. Thankfully this is a very easy fix.
#+BEGIN_SRC emacs-lisp
  (add-hook 'exwm-update-title-hook (lambda ()
				      (exwm-workspace-rename-buffer exwm-title)))
#+END_SRC
*** Assign workspaces and floating to various windows
This is the part of the window manager configuration which is just how to control X windows as they spawn.
#+BEGIN_SRC emacs-lisp
  (setq exwm-manage-configurations
	'(((string= exwm-class-name "Steam")
	   workspace 9 floating t floating-mode-line nil)
	  ((string= exwm-instance-name "telegram")
	   workspace 8)
	  ((string= exwm-class-name "discord")
	   workspace 7)
	  ((string= exwm-instance-name "libreoffice")
	   workspace 6)
	  ((string= exwm-instance-name "gimp")
	   workspace 6)
	  ((string= exwm-title "Event Tester")
	   floating t)))
#+END_SRC
*** Configure floating window borders
Uses the same color as my modeline, uses the same width as window divider width. See below.
#+BEGIN_SRC emacs-lisp
  (setq exwm-floating-border-width 3
	exwm-floating-border-color "#335ea8")
#+END_SRC
** Keybindings
*** General workspace commands
#+BEGIN_SRC emacs-lisp
  (setq exwm-input-global-keys
	`(([?\s-q] . exwm-workspace-delete)
	  ([?\s-w] . exwm-workspace-switch)
	  ([?\s-e] . exwm-workspace-swap)
	  ([?\s-r] . exwm-reset)
	  ,@(mapcar (lambda (i)
		      `(,(kbd (format "s-%d" i)) .
			(lambda ()
			  (interactive)
			  (exwm-workspace-switch-create ,i))))
		    (number-sequence 0 9))))
#+END_SRC
*** EXWM-mode functions
**** Send a key verbatim to the program more easily
#+BEGIN_SRC emacs-lisp
       (define-key exwm-mode-map (kbd "C-c C-q") nil)
       (define-key exwm-mode-map (kbd "C-q") 'exwm-input-send-next-key)
#+END_SRC
**** Inhibit toggling fullscreen
This was suuuuper broken when I tried to use it.
#+BEGIN_SRC emacs-lisp
  (define-key exwm-mode-map (kbd "C-c C-f") nil)
#+END_SRC
**** Inhibit floating and hiding
This was wonky too, I don't think I need to be able to toggle floating for windows
#+BEGIN_SRC emacs-lisp
  (define-key exwm-mode-map (kbd "C-c C-t C-f") nil)
  (define-key exwm-mode-map (kbd "C-c C-t C-v") nil)
#+END_SRC
**** Disable toggling the mode line
This is just a matter of personal comfort. It makes no sense to me on an aesthetic basis to hide the modeline on some buffers while keeping it on others. It's weird.
#+BEGIN_SRC emacs-lisp
  (define-key exwm-mode-map (kbd "C-c C-t C-m") nil)
#+END_SRC
*** Emacs key bindings in X windows
This is super nice, because I love these key bindings and they are just intuitive to me, and now they can carry over safely to other programs.
#+BEGIN_SRC emacs-lisp
  (setq exwm-input-simulation-keys
	'(;; Navigation
	  ([?\C-b] . [left])
	  ([?\C-f] . [right])
	  ([?\C-p] . [up])
	  ([?\C-n] . [down])

	  ([?\M-b] . [C-left])
	  ([?\M-f] . [C-right])
	  ([?\M-p] . [C-up])
	  ([?\M-n] . [C-down])

	  ([?\C-a] . [home])
	  ([?\C-e] . [end])
	  ([?\C-v] . [next])
	  ([?\M-v] . [prior])

	  ;; Copy/Paste
	  ([?\C-w] . [?\C-x])
	  ([?\M-w] . [?\C-c])
	  ([?\C-y] . [?\C-v])
	  ([?\C-s] . [?\C-f])
	  ([?\C-\/] . [?\C-z])

	  ;; Other
	  ([?\C-d] . [delete])
	  ([?\C-k] . [S-end delete])
	  ([?\C-g] . [escape])))

  ;; I can't do sequences above, so this is separate
  (defun exwm-C-s ()
    "Pass C-s to the EXWM window."
    (interactive)
    (execute-kbd-macro (kbd "C-q C-s")))

  (define-key exwm-mode-map (kbd "C-x C-s") 'exwm-C-s)
#+END_SRC
** Initialize EXWM
Now that we've got all the variables nice and ready, let's start it up!
#+BEGIN_SRC emacs-lisp
  (exwm-enable)
  (exwm-config-ido)
  (exwm-systemtray-enable)
#+END_SRC
* EMMS (Emacs MultiMedia System)
I am big on doing as much in emacs as possible. Having my music player moved to emacs was a HUGE step. When I first started using it, it was weird, but now I have come to absolutely love it.
** Install EMMS and bind main playback keys
I do a crapload here, but basically the two main things I do here is configure mpd information and bind some keys for emms controls and music controls.
#+BEGIN_SRC emacs-lisp
  (use-package emms
    :ensure t
    :config
    (require 'emms-setup)
    (require 'emms-player-mpd)
    (emms-all)
    (setq emms-seek-seconds 5
	  emms-player-list '(emms-player-mpd)
	  emms-info-functions '(emms-info mpd)
	  emms-player-mpd-server-name "localhost"
	  emms-player-mpd-server-port "6601"
	  mpc-host "localhost:6601")
    :bind (("s-a v" . emms)
	   ("s-a b" . emms-smart-browse)
	   ("s-a r c" . emms-player-mpd-update-all-reset-cache)
	   ("<XF86AudioPrev>" . emms-previous)
	   ("<XF86AudioNext>" . emms-next)
	   ("<XF86AudioPlay>" . emms-pause)
	   ("<XF86AudioStop>" . emms-stop)
	   ("<s-left>" . emms-previous)
	   ("<s-right>" . emms-next)
	   ("<s-down>" . emms-pause)
	   ("<s-up>" . emms-stop)
	   :map exwm-mode-map
	   ("s-a v" . emms)
	   ("s-a b" . emms-smart-browse)
	   ("s-a r c" . emms-player-mpd-update-all-reset-cache)
	   ("<XF86AudioPrev>" . emms-previous)
	   ("<XF86AudioNext>" . emms-next)
	   ("<XF86AudioPlay>" . emms-pause)
	   ("<XF86AudioStop>" . emms-stop)
	   ("<s-left>" . emms-previous)
	   ("<s-right>" . emms-next)
	   ("<s-down>" . emms-pause)
	   ("<s-up>" . emms-stop)))
#+END_SRC
** Other useful bindings
*** Starting the daemon
#+BEGIN_SRC emacs-lisp
  (defun mpd/start-music-daemon ()
    "Start MPD, connect to it and sync the metadata cache"
    (interactive)
    (shell-command "mpd")
    (mpd/update-database)
    (emms-player-mpd-connect)
    (emms-cache-set-from-mpd-all)
    (message "MPD started!"))

  (global-set-key (kbd "s-a x") 'mpd/start-music-daemon)
  (define-key exwm-mode-map (kbd "s-a x") 'mpd/start-music-daemon)
#+END_SRC
*** Stopping the daemon
#+BEGIN_SRC emacs-lisp
  (defun mpd/kill-music-daemon ()
    "Stop playback and kill the music daemon."
    (interactive)
    (emms-stop)
    (call-process "killall" nil nil nil "mpd")
    (message "MPD killed!"))

  (global-set-key (kbd "s-a q") 'mpd/kill-music-daemon)
  (define-key exwm-mode-map (kbd "s-a q") 'mpd/kill-music-daemon)
#+END_SRC
*** Updating the database
#+BEGIN_SRC emacs-lisp
  (defun mpd/update-database ()
    "Update the MPD database synchronously."
    (interactive)
    (call-process "mpc" nil nil nil "update")
    (message "MPD database updated!"))

  (global-set-key (kbd "s-a r d") 'mpd/update-database)
  (define-key exwm-mode-map (kbd "s-a r d") 'mpd/update-database)
#+END_SRC
*** Showing playback status
#+BEGIN_SRC emacs-lisp
  (defun mpc-status ()
    "Display the mpc status in the echo area."
    (interactive)
    (shell-command "mpc"))

  (global-set-key (kbd "s-a a") 'mpc-status)
  (define-key exwm-mode-map (kbd "s-a a") 'mpc-status)
#+END_SRC
*** Shuffling the playlist
#+BEGIN_SRC emacs-lisp
  (defun emms-shuffle-message ()
    "Shuffle the playlist and say so in the echo area."
    (interactive)
    (emms-shuffle)
    (message "Playlist has been shuffled."))

  (global-set-key (kbd "s-a s") 'emms-shuffle-message)
  (define-key exwm-mode-map (kbd "s-a s") 'emms-shuffle-message)
#+END_SRC
*** Setting repeat mode
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-a r a") 'emms-toggle-repeat-playlist)
  (define-key exwm-mode-map (kbd "s-a r a") 'emms-toggle-repeat-playlist)

  (global-set-key (kbd "s-a r t") 'emms-toggle-repeat-track)
  (define-key exwm-mode-map (kbd "s-a r t") 'emms-toggle-repeat-track)
#+END_SRC
* Other programs
This is other stuff I use.
** Within emacs
*** Terminal
I make sure we use the right shell and use super+return to open a terminal. Using emacs as my terminal has helped wean me off using the terminal for things.
#+BEGIN_SRC emacs-lisp
  (defvar term-shell "/bin/zsh")
  (defadvice ansi-term (before force-bash) (interactive (list term-shell)))
  (ad-activate 'ansi-term)

  (global-set-key (kbd "<s-return>") 'ansi-term)
  (define-key exwm-mode-map (kbd "<s-return>") 'ansi-term)
#+END_SRC
*** Calculator
I love this. I really really really *really* love this. I can use my number pad exclusively to call a calculator and then use the numpad to close it as well.
#+BEGIN_SRC emacs-lisp
  (require 'calc)

  (global-set-key (kbd "C-c c") 'calc)
  (global-set-key (kbd "<XF86Calculator>") 'calc)
  (define-key exwm-mode-map (kbd "<XF86Calculator>") 'calc)

  (define-key calc-mode-map (kbd "ESC ESC ESC") 'kill-this-buffer-and-window)
#+END_SRC
*** Weather forecasts
Picking a service to use for this was a pain. I ended up settling for wttrin because it is the fastest and easiest to use, and plays nice with my setup.
#+BEGIN_SRC emacs-lisp
  (use-package wttrin :ensure t
    :init
    (defun wttrin-local ()
      "Show a weather report for a given locality."
      (interactive)
      (wttrin "Indianapolis, IN")
      (delete-other-windows))
    (defun wttrin-not-local ()
      "Show a weather report for a user-defined locality."
      (interactive)
      (wttrin)
      (delete-other-windows))
    :bind (("C-c w" . wttrin-local)
	   ("C-c C-w" . wttrin-not-local)))
#+END_SRC
** X applications
*** Firefox
Firefox has some unique abilities when it comes to how to make windows behave which work better for me. I don't use tabs, and I don't want anything to do with them, and Firefox lets me hide the tab bar and force all tabs to actually open as new windows.
#+BEGIN_SRC emacs-lisp
  (defun run-firefox ()
    "Start Firefox."
    (interactive)
    (start-process-shell-command
     "Firefox" nil "firefox"))

  (global-set-key (kbd "s-f") 'run-firefox)
  (define-key exwm-mode-map (kbd "s-f") 'run-firefox)
#+END_SRC
*** LibreOffice
Shame me all you want. I'm still in introductory courses and haven't learned enough Org-mode to use it more meaningfully.
#+BEGIN_SRC emacs-lisp
  (defun run-libreoffice ()
    "Start LibreOffice."
    (interactive)
    (start-process-shell-command
     "LibreOffice" nil "libreoffice"))

  (global-set-key (kbd "s-b") 'run-libreoffice)
  (define-key exwm-mode-map (kbd "s-b") 'run-libreoffice)
#+END_SRC
*** GIMP
Until GIMP's functionality gets merged into emacs, guess I'm stuck having it.
#+BEGIN_SRC emacs-lisp
  (defun run-gimp ()
    "Start GIMP."
    (interactive)
    (start-process-shell-command
     "GIMP" nil "gimp"))

  (global-set-key (kbd "s-g") 'run-gimp)
  (define-key exwm-mode-map (kbd "s-g") 'run-gimp)
#+END_SRC
*** Telegram
I have a painfully white theme which fits perfectly with my setup.
#+BEGIN_SRC emacs-lisp
  (defun run-tg ()
    "Start Telegram."
    (interactive)
    (start-process-shell-command
     "Telegram" nil "telegram"))

  (global-set-key (kbd "s-t") 'run-tg)
  (define-key exwm-mode-map (kbd "s-t") 'run-tg)
#+END_SRC
*** Discord
Yeah, I also use a light theme for Discord. It looks comfy, even if Discord is a garbage application.
#+BEGIN_SRC emacs-lisp
  (defun run-discord ()
    "Start Discord."
    (interactive)
    (start-process-shell-command
     "Discord" nil "discord"))

  (global-set-key (kbd "s-d") 'run-discord)
  (define-key exwm-mode-map (kbd "s-d") 'run-discord)
#+END_SRC
*** Steam
Gaming is possible with EXWM, if you run games windowed.
#+BEGIN_SRC emacs-lisp
  (defun run-steam ()
    "Start Steam."
    (interactive)
    (start-process-shell-command
     "Steam" nil "steam"))

  (global-set-key (kbd "s-s") 'run-steam)
  (define-key exwm-mode-map (kbd "s-s") 'run-steam)
#+END_SRC
** Other useful functions
Most of these functions use commands from [[https://gitlab.com/farlado/dotfiles][my dotfiles]] to complete various tasks. Few don't.
*** Network Settings
This one uses two windows: one to open the NetworkManager connection editor, and another to list wifi networks nearby.
#+BEGIN_SRC emacs-lisp
  (defun network-settings ()
    "Open a NetworkManager connection editor."
    (interactive)
    (start-process-shell-command
     "Connections" nil "nm-connection-editor")
    (async-shell-command "nmcli dev wifi list"))

  (global-set-key (kbd "s-n") 'network-settings)
  (define-key exwm-mode-map (kbd "s-n") 'network-settings)
#+END_SRC
*** Volume control
#+BEGIN_SRC emacs-lisp
  (defun volume-mute ()
    "Mute the volume."
    (interactive)
    (shell-command "volctl m"))
  (global-set-key (kbd "<XF86AudioMute>") 'volume-mute)
  (define-key exwm-mode-map (kbd "<XF86AudioMute>") 'volume-mute)

  (defun volume-mic-mute ()
    "Mute the microphone."
    (interactive)
    (shell-command "volctl t"))
  (global-set-key (kbd "<XF86AudioMicMute>") 'volume-mic-mute)
  (define-key exwm-mode-map (kbd "<XF86AudioMicMute>") 'volume-mic-mute)

  (defun volume-up ()
    "Turn the volume up."
    (interactive)
    (shell-command "volctl u"))
  (global-set-key (kbd "<XF86AudioRaiseVolume>") 'volume-up)
  (define-key exwm-mode-map (kbd "<XF86AudioRaiseVolume>") 'volume-up)

  (defun volume-down ()
    "Turn the volume down."
    (interactive)
    (shell-command "volctl d"))

  (global-set-key (kbd "<XF86AudioLowerVolume>") 'volume-down)
  (define-key exwm-mode-map (kbd "<XF86AudioLowerVolume>") 'volume-down)
#+END_SRC
*** Brightness control
#+BEGIN_SRC emacs-lisp
  (defun backlight-up ()
    "Turn the backlight up."
    (interactive)
    (shell-command "blctl -u"))
  (global-set-key (kbd "<XF86MonBrightnessUp>") 'backlight-up)
  (define-key exwm-mode-map (kbd "<XF86MonBrightnessUp>") 'backlight-up)

  (defun backlight-down ()
    "Turn the backlight down."
    (interactive)
    (shell-command "blctl -d"))

  (global-set-key (kbd "<XF86MonBrightnessDown>") 'backlight-down)
  (define-key exwm-mode-map (kbd "<XF86MonBrightnessDown>") 'backlight-down)
#+END_SRC
*** Take screenshots
I love maim specifically for this reason. It's super easy to do this and it's very good quality as a screen capture tool.
#+BEGIN_SRC emacs-lisp
  (defun screencap-section ()
    "Capture a selection of the screen."
    (interactive)
    (shell-command
     "maim -s /dev/stdout | xclip -selection clipboard -t image/png &> /dev/null")
    (message ""))
  (global-set-key (kbd "<print>") 'screencap-section)
  (define-key exwm-mode-map (kbd "<print>") 'screencap-section)

  (defun screencap-full ()
    "Capture the entire screen."
    (interactive)
    (shell-command
     "maim /dev/stdout | xclip -selection clipboard -t image/png &> /dev/null")
    (message ""))

  (global-set-key (kbd "<C-print>") 'screencap-full)
  (define-key exwm-mode-map (kbd "<C-print>") 'screencap-full)
#+END_SRC
*** Keyboard layout selection
#+BEGIN_SRC emacs-lisp
  (defun cycle-kbd-layout ()
    "Cycles the keyboard layout in reverse."
    (interactive)
    (shell-command "keyctl -c us epo de"))

  (defun cycle-kbd-layout-reverse ()
    "Cycles the keyboard layout in reverse."
    (interactive)
    (shell-command "keyctl -c de epo us"))

  (global-set-key (kbd "s-SPC") 'cycle-kbd-layout)
  (define-key exwm-mode-map (kbd "s-SPC") 'cycle-kbd-layout)

  (global-set-key (kbd "<s-backspace>") 'cycle-kbd-layout-reverse)
  (define-key exwm-mode-map (kbd "<s-backspace>") 'cycle-kbd-layout-reverse)
#+END_SRC
*** Lockscreen
#+BEGIN_SRC emacs-lisp
  (defun lock-screen ()
    "Lock the screen."
    (interactive)
    (start-process-shell-command
     "Lockscreen" nil "i3l"))

  (global-set-key (kbd "<XF86ScreenSaver>") 'lock-screen)
  (define-key exwm-mode-map (kbd "<XF86ScreenSaver>") 'lock-screen)

  (global-set-key (kbd "s-l") 'lock-screen)
  (define-key exwm-mode-map (kbd "s-l") 'lock-screen)
#+END_SRC
*** Shutting down
I copied the function for quitting emacs to handle shutting down.
#+BEGIN_SRC emacs-lisp
  (defun save-buffers-shut-down (&optional arg)
    "Offer to save each buffer, then shut down the computer.
  This function is literally just a copycat of `save-buffers-kill-emacs'.
  With prefix ARG, silently save all file-visiting buffers without asking.
  If there are active processes where `process-query-on-exit-flag'
  returns non-nil and `confirm-kill-processes' is non-nil,
  asks whether processes should be killed.
  Runs the members of `kill-emacs-query-functions' in turn and stops
  if any returns nil.  If `confirm-kill-emacs' is non-nil, calls it.
  Instead of just killing Emacs, shuts down the system."
    (interactive "P")
    ;; Don't use save-some-buffers-default-predicate, because we want
    ;; to ask about all the buffers before killing Emacs.
    (save-some-buffers arg t)
    (let ((confirm confirm-kill-emacs))
      (and
       (or (not (memq t (mapcar (function
				 (lambda (buf) (and (buffer-file-name buf)
						    (buffer-modified-p buf))))
				(buffer-list))))
	   (progn (setq confirm nil)
		  (yes-or-no-p "Modified buffers exist; shut down anyway? ")))
       (or (not (fboundp 'process-list))
	   ;; process-list is not defined on MSDOS.
	   (not confirm-kill-processes)
	   (let ((processes (process-list))
		 active)
	     (while processes
	       (and (memq (process-status (car processes)) '(run stop open listen))
		    (process-query-on-exit-flag (car processes))
		    (setq active t))
	       (setq processes (cdr processes)))
	     (or (not active)
		 (with-current-buffer-window
		  (get-buffer-create "*Process List*") nil
		  #'(lambda (window _value)
		      (with-selected-window window
			(unwind-protect
			    (progn
			      (setq confirm nil)
			      (yes-or-no-p "Active processes exist; kill them and shut down anyway? "))
			  (when (window-live-p window)
			    (quit-restore-window window 'kill)))))
		  (list-processes t)))))
       ;; Query the user for other things, perhaps.
       (run-hook-with-args-until-failure 'kill-emacs-query-functions)
       (or (null confirm)
	   (funcall confirm "Really shut down? "))
       (shell-command "shutdown now"))))

  (global-set-key (kbd "C-x C-M-c") 'save-buffers-shut-down)
  (define-key exwm-mode-map (kbd "C-x C-M-c") 'save-buffers-shut-down)
#+END_SRC
* General Functionality
This is just stuff not pertaining to a specific task and/or not complex enough to warrant entire sections for them.
** Don't make extra files on the filesystem
I don't use autosaves and backups. I love living on the edge.
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil
	auto-save-default nil)
#+END_SRC
** Make scrolling a little less crazy
One of those things I just don't know how specifically it works but it makes things comfortable.
#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC
** Enable word wrapping for all buffers
It's literally never not annoying when words don't wrap.
#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode 1)
#+END_SRC
** If on a system with a bell, shut it up
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC
** Move between SubWords as well as between words
#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC
** Disable suspending emacs
Why even is this a key that is bound?
#+BEGIN_SRC emacs-lisp
  (global-unset-key (kbd "C-z"))
  (global-unset-key (kbd "C-x C-z"))
#+END_SRC
** nov package (epub reader)
Not the best way to do epub reading, but at least it's in emacs.
#+BEGIN_SRC emacs-lisp
  (use-package nov
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode)))
#+END_SRC
** Restart and open dashboard with C-c d
I constantly accidentally close dashboard, so I made a way to open it again if I accidentally kill it.
#+BEGIN_SRC emacs-lisp
  (defun dashboard-restart ()
    "Restart the dashboard buffer and switch to it."
    (interactive)
    (dashboard-insert-startupify-lists)
    (switch-to-buffer "*dashboard*"))

  (global-set-key (kbd "C-c d") 'dashboard-restart)
#+END_SRC
** Open configuration with C-c e
Since this thing is changing all the time, I really like having it available on a shortcut.
#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    "Open the config file."
    (interactive)
    (find-file "~/.emacs.d/config.org"))

  (global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC
* Menus/Commands
Menus, commands, and commands which involve menus.
** Enable ido-mode, install ido-vertical-mode and smex
I /love/ ~ido-mode~. God I *love* ~ido-mode~.
#+BEGIN_SRC emacs-lisp
  (setq ido-mode-flex-matching nil
	ido-create-new-buffer 'always
	ido-everywhere t)
  (ido-mode 1)
#+END_SRC
However, I /HATE/ ~ido-mode~ right out of the box. A vertical list looks craptons nicer.
#+BEGIN_SRC emacs-lisp
  (use-package ido-vertical-mode
    :ensure t
    :config
    (setq ido-vertical-define-keys 'C-n-and-C-p-only)
    (ido-vertical-mode 1))
#+END_SRC
Default M-x behavior doesn't use ~ido-mode~, so we install a package which gives it ~ido-mode~.
#+BEGIN_SRC emacs-lisp
  (use-package smex
    :ensure t
    :bind ("M-x" . smex))
#+END_SRC
** Replace "yes or no" prompts with "y or n"
Beauty in brevity.
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** which-key package (small menus to help with commands)
Even as I've gotten used to emacs key bindings, it is always nice to have this around so that if I want to know, I can easily see what's what.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :init
    (which-key-mode 1))
#+END_SRC
** popup-kill-ring package (easier time managing the kill ring)
Having the whole kill ring easy to scroll through is much less hassle than default behavior.
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))
#+END_SRC
** swiper package (better searches)
This search behavior is *SO* much nicer than the default.
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :bind ("C-s" . swiper))
#+END_SRC
** Kill an entire word when you're in the middle of it
I don't need it super often, but it's still nice to have.
#+BEGIN_SRC emacs-lisp
  (defun whole-kill-word ()
    "Delete an entire word."
    (interactive)
    (backward-word)
    (kill-word 1))

  (global-set-key (kbd "C-c DEL") 'whole-kill-word)
#+END_SRC
** avy package (faster moving around documents)
If I want to hop around in a document without calling swiper, ~avy~ is definitely the way to go.
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind ("M-s" . avy-goto-char))
#+END_SRC
** hungry-delete package (convenient deletion of trailing whitespace)
This saves me tons of time when it comes to managing whitespace.
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :ensure t
    :config
    (global-hungry-delete-mode 1))
#+END_SRC
** company package (autocomplete backend)
This is the base package. I changed some keybinds to make it more pleasant to use.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :init
    (add-hook 'after-init-hook 'global-company-mode)
    :config
    (setq company-idle-delay 0.75
	  company-minimum-prefix-length 3)
    (with-eval-after-load 'company
      (define-key company-active-map (kbd "M-n") nil)
      (define-key company-active-map (kbd "M-p") nil)
      (define-key company-active-map (kbd "C-n") #'company-select-next)
      (define-key company-active-map (kbd "C-p") #'company-select-previous)
      (define-key company-active-map (kbd "SPC") #'company-abort)))
#+END_SRC
* Buffers/Windows
** Sloppy focus
I hate having to click to focus a different window, so I would rather just have windows sloppily focus.
#+BEGIN_SRC emacs-lisp
  (setq focus-follows-mouse t
	mouse-autoselect-window t)
#+END_SRC
** Kill current buffer with C-x k, use C-x C-k to kill the window too
I had to adjust the function which kills both the current buffer and the current window, because it did not cooperate with EXWM buffers. That's why I have this weird chunk I don't actually have the expertise yet to fully parse.
#+BEGIN_SRC emacs-lisp
  (defun kill-this-buffer-and-window ()
    "Kill the current buffer and delete the selected window."
    (interactive)
    (let ((window-to-delete (selected-window))
	  (buffer-to-kill (current-buffer))
	  (delete-window-hook (lambda ()
				(ignore-errors (delete-window)))))
      (unwind-protect
	  (progn
	    (add-hook 'kill-buffer-hook delete-window-hook t t)
	    (if (kill-buffer (current-buffer))
		;; If `delete-window' failed before, we repeat
		;; it to regenerate the error in the echo area.
		(when (eq (selected-window) window-to-delete)
		  (delete-window)))))))

  (global-set-key (kbd "C-x k") 'kill-this-buffer)
  (global-set-key (kbd "C-x C-k") 'kill-this-buffer-and-window)
#+END_SRC
** Close all buffers and kill all windows with C-x C-M-k
I wanted a way to quickly and gracefully destroy all my open stuff at once.
#+BEGIN_SRC emacs-lisp
  (defun close-buffers-and-windows ()
    "Close every buffer and close all windows, then restart dashboard."
    (interactive)
    (save-some-buffers)
    (mapc 'kill-buffer (buffer-list))
    (delete-other-windows)
    (dashboard-restart))

  (global-set-key (kbd "C-x C-M-k") 'close-buffers-and-windows)
#+END_SRC
** Use buffer-menu on C-x b so the buffer list doesn't open a new window
Just another point of personal convenience. I don't like ~ibuffer~ just because aesthetic reasons.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x b") 'buffer-menu)
  (global-unset-key (kbd "C-x C-b"))
#+END_SRC
** Move focus and show buffer-menu when explicitly creating new windows
This to me is preferable to the default behavior.
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-vertical ()
    "Open a new window vertically."
    (interactive)
    (split-window-below)
    (other-window 1)
    (buffer-menu))

  (defun split-and-follow-horizontal ()
    "Open a new window horizontally."
    (interactive)
    (split-window-right)
    (other-window 1)
    (buffer-menu))

  (global-set-key (kbd "C-x 2") 'split-and-follow-vertical)
  (global-set-key (kbd "C-x 3") 'split-and-follow-horizontal)
#+END_SRC
** Balance windows with C-c b
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c b") 'balance-windows)
#+END_SRC
** switch-window package (easier movement between windows)
You know what sucks? Yeah, ~other-window~ sucks. It really sucks. So, I use ~switch-window~ instead so that I can more easily move between windows when I have more than two.
#+BEGIN_SRC emacs-lisp
  (use-package switch-window
    :ensure t
    :config
    (setq switch-window-input-style 'minibuffer
	  switch-window-increase 4
	  switch-window-threshold 2
	  switch-window-shortcut-style 'qwerty
	  switch-window-qwerty-shortcuts '("a" "s" "d" "f" "g" "z" "x" "c" "v" "b"))
    :bind ([remap other-window] . switch-window))
#+END_SRC
** move focus with C-M-w/a/s/d
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-s-w") 'windmove-up)
  (global-set-key (kbd "C-s-a") 'windmove-left)
  (global-set-key (kbd "C-s-s") 'windmove-down)
  (global-set-key (kbd "C-s-d") 'windmove-right)

  (define-key exwm-mode-map (kbd "C-s-w") 'windmove-up)
  (define-key exwm-mode-map (kbd "C-s-a") 'windmove-left)
  (define-key exwm-mode-map (kbd "C-s-s") 'windmove-down)
  (define-key exwm-mode-map (kbd "C-s-d") 'windmove-right)
#+END_SRC
** buffer-move package (move windows around)
#+BEGIN_SRC emacs-lisp
  (use-package buffer-move
    :ensure t
    :bind (("<C-s-up>" . buf-move-up)
	   ("<C-s-down>" . buf-move-down)
	   ("<C-s-left>" . buf-move-left)
	   ("<C-s-right>" . buf-move-right)
	   :map exwm-mode-map
	   ("<C-s-up>" . buf-move-up)
	   ("<C-s-down>" . buf-move-down)
	   ("<C-s-left>" . buf-move-left)
	   ("<C-s-right>" . buf-move-right)))
#+END_SRC
* Org-mode
I don't need much extending for org-mode.
** Agenda (only enabled if an agenda is found)
I use C-c a and C-c C-a to do things related to my agenda. Only one of my systems actually has my agenda, so this only runs on that machine so I don't try any funny business on other machines.
#+BEGIN_SRC emacs-lisp
  (if (file-exists-p "~/agenda.org")
      (progn
	(setq org-agenda-files (quote ("~/agenda.org")))

	(defun open-agenda ()
	  "Open the agenda file."
	  (interactive)
	  (find-file "~/agenda.org"))

	(global-set-key (kbd "C-c a") 'org-agenda)
	(global-set-key (kbd "C-c C-a") 'open-agenda)))
#+END_SRC
** Shortcuts for various code snippets in org-mode
This will expand as I get into more and more languages and take more notes in classes with different snippets of different languages.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
	       '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist
	       '("py" "#+BEGIN_SRC python\n?\n#+END_SRC"))
#+END_SRC
** Use the current window when editing source code in org-mode
This is just a convenience thing.
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC
* Programming
This is quite barren, but mostly because my needs are not currently particularly that big.
** magit package (git but made easier)
I used to use a terminal for this, but holy crap this is a lot easier, a lot faster, and a whole lot nicer to use overall.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind ("C-c g" . magit-status))
#+END_SRC
** flycheck package (on-the-fly syntax checker)
This is nice to have so I can be told right away when I'm doing something wrong.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :config (global-flycheck-mode 1))
#+END_SRC
** company-jedi package (Python autocompletion)
I will probably be adding company autocompletion for more languages as I start working in more languages.
#+BEGIN_SRC emacs-lisp
  (use-package company-jedi
    :ensure t
    :config (add-to-list 'company-backends 'company-jedi))
#+END_SRC
** haskell-mode package (self-explanatory)
I have started to mess around with Haskell, so I needed to grab a mode for that. This supplies basically everything I need, e.g. company autocompletion and flycheck information.
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure t
    :init
    (require 'haskell-mode)
    (require 'haskell-process)
    (require 'haskell-interactive-mode)
    :hook
    (haskell-mode-hook . interactive-haskell-mode)
    (haskell-mode-hook . turn-on-haskell-doc-mode)
    (haskell-mode-hook . turn-on-haskell-indentation)
    (haskell-mode-hook . haskell-auto-insert-module-template)
    :config (setq haskell-stylish-on-save t))
#+END_SRC
** electric-pair-mode (OH MY GOD THIS IS SO GREAT)
I have no words for how convenient this has been and how much faster I get things done thanks to these five lines of elisp.
#+BEGIN_SRC emacs-lisp
  (setq electric-pair-pairs '((?\{ . ?\})
			      (?\( . ?\))
			      (?\[ . ?\])
			      (?\" . ?\")))
  (electric-pair-mode t)
#+END_SRC
* Looks
** Theme
I used to hate light themes. I'm not in that camp anymore. I love this elegant theme.
#+BEGIN_SRC emacs-lisp
  (use-package leuven-theme
    :ensure t
    :config
    (setq org-fontify-whole-heading-line t
	  leuven-scale-org-agenda-structure t
	  leuven-scale-outline-headlines t)
    (load-theme 'leuven t))
#+END_SRC
** Hide useless things
Who even uses the toolbar in emacs?
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
  (tooltip-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (setq use-dialog-box nil)
#+END_SRC
** Window dividers/fringes
Since I use EXWM, X windows will remove the thin divider which is present by default. To remedy this, I use a different method. I set it to a solid color. I like the fringes at ten pixels, so I just keep it there.
#+BEGIN_SRC emacs-lisp
  (setq window-divider-default-right-width 3)
  (set-face-foreground 'window-divider-first-pixel "#335ea8")
  (set-face-foreground 'window-divider "#335ea8")
  (set-face-foreground 'window-divider-last-pixel "#335ea8")
  (window-divider-mode 1)
  (fringe-mode 10)
#+END_SRC
** Line/column numbers
I like having line numbers and the current cursor position and a highlighted current line.
#+BEGIN_SRC emacs-lisp
  (line-number-mode 1)
  (column-number-mode 1)
  (global-hl-line-mode 1)
  (global-display-line-numbers-mode 1)
#+END_SRC
However, I don't like line numbers in modes where it breaks the mode.
#+BEGIN_SRC emacs-lisp
  (defun disable-line-numbers-for (hook)
    "Disable `display-line-numbers-mode` for HOOK."
    (add-hook hook (lambda ()
		     (display-line-numbers-mode 0))))

  (disable-line-numbers-for 'term-mode-hook)
  (disable-line-numbers-for 'tetris-mode-hook)
  (disable-line-numbers-for 'snake-mode-hook)
  (disable-line-numbers-for 'ibuffer-hook)
  (disable-line-numbers-for 'dashboard-mode-hook)
  (disable-line-numbers-for 'shell-mode-hook)
  (disable-line-numbers-for 'nov-mode-hook)
#+END_SRC
** Pretty symbols/text
*** pretty-mode package (prettify symbols)
I don't like ~prettify-symbols-mode~. It doesn't do enough. This one helps so much more to make things look nice, especially in functional programming languages. I enable /all/ of them.
#+BEGIN_SRC emacs-lisp
  (use-package pretty-mode
    :ensure t
    :config
    (require 'pretty-mode)
    (global-pretty-mode 1)
    (pretty-activate-groups
     '(:ordering :equality :logic :sets :sub-and-superscripts
		 :function :greek :punctuation :types :arrows
		 :quantifiers :nil :arithmetic :undefined
		 :parentheses :other)))
#+END_SRC
*** Highlight matching parentheses et al. when hoving near one
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC
*** rainbow package (show colors when typed as hex codes)
I don't use it too much, but it's nice to have it around.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :config
    (define-globalized-minor-mode global-rainbow-mode rainbow-mode (lambda ()
								     (rainbow-mode 1)))
    (global-rainbow-mode 1))
#+END_SRC
*** rainbow-delimiters package (better quotes/parentheses/brackets)
It's subtle on my theme, but it still helps me keep track of my brackets and parentheses.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode 1))
#+END_SRC
*** org-bullets package (nicer bullet points in org-mode)
It's kinda slow, but bullet points are very very nice, much better than asterisks.
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda ()
			       (org-bullets-mode 1)))
    (setq inhibit-compacting-font-caches t))
#+END_SRC
** Mode line
*** spaceline package (spacemacs mode line)
I *hate* the default modeline. This one is much less sucky.
#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :ensure t
    :config
    (require 'spaceline-config)
    (setq powerline-default-separator (quote butt))
    (spaceline-spacemacs-theme))
#+END_SRC
*** Show clock on mode line
#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format t)
  (display-time-mode 1)
#+END_SRC
*** fancy-battery package (battery on mode line)
I used to just use the default battery modeline setting, but I decided I want something a little nicer.
#+BEGIN_SRC emacs-lisp
  (use-package fancy-battery
    :ensure t
    :config
    (setq fancy-battery-show-percentage t
	  battery-update-interval 15)
    (fancy-battery-mode 1))
#+END_SRC
*** diminish package (hide minor modes from mode line)
Supposedly ~use-package~ is going to have this feature soon, but till that rolls out I'll be using this.
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t
    :init
    (diminish 'hungry-delete-mode)
    (diminish 'which-key-mode)
    (diminish 'subword-mode)
    (diminish 'company-mode)
    (diminish 'rainbow-mode)
    (diminish 'eldoc-mode)
    (diminish 'flycheck-mode)
    (diminish 'visual-line-mode)
    (diminish 'interactive-haskell-mode)
    (diminish 'haskell-doc-mode))
#+END_SRC
