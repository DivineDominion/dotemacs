#+title: Farlado's Illiterate GNU Emacs üêâ
#+subtitle: A far-from-sane literate GNU Emacs configuration
#+author: Farlado
#+language: en
#+startup: hideblocks
#+options: num:nil toc:2
#+property: header-args :results none

#+begin_quote
Personally, I feel inspired whenever I open Emacs. Like a craftsman entering his
workshop, I feel a realm of possibility open before me. I feel the comfort of an
environment that has evolved over time to fit me perfectly -- an assortment of
packages and keybindings which help me bring ideas to life day after day.
-- [[https://www.braveclojure.com/basic-emacs/][Daniel Higginbotham]]
#+end_quote

* Table of Contents :toc:quote:
#+BEGIN_QUOTE
- [[#about-this-configuration][About this configuration]]
  - [[#okay-thats-pretty-neat-why-though][Okay, that's pretty neat. Why though?]]
  - [[#installation][Installation]]
  - [[#dependencies][Dependencies]]
  - [[#license][License]]
  - [[#files-to-ignore][Files to ignore]]
- [[#giving-files-their-headers][Giving files their headers]]
- [[#making-emacs-start-quickly][Making Emacs start quickly]]
  - [[#starting-emacs-fast][Starting Emacs FAST]]
  - [[#do-these-things-asap][Do these things ASAP]]
  - [[#early-package-management][Early package management]]
  - [[#later-package-management][Later package management]]
  - [[#final-considerations][Final considerations]]
- [[#making-emacs-much-less-ugly][Making Emacs much less ugly]]
  - [[#font][Font]]
  - [[#theme][Theme]]
  - [[#mode-line][Mode line]]
  - [[#in-buffers][In buffers]]
- [[#making-emacs-more-comfortable][Making Emacs more comfortable]]
  - [[#general-functionality][General functionality]]
  - [[#completion-helpers][Completion helpers]]
  - [[#functionsmacros][Functions/macros]]
  - [[#bufferswindows][Buffers/windows]]
  - [[#key-binds][Key binds]]
- [[#making-emacs-a-good-text-editor][Making Emacs a good text editor]]
  - [[#additional-major-modes][Additional major modes]]
  - [[#personal-save-hooks][Personal save hooks]]
  - [[#general-editing][General editing]]
  - [[#programming][Programming]]
  - [[#org-mode][Org-mode]]
- [[#making-emacs-more-than-an-editor][Making Emacs more than an editor]]
  - [[#not-built-in][Not built-in]]
  - [[#built-in][Built-in]]
  - [[#games][Games]]
- [[#making-emacs-a-desktop-environment][Making Emacs a desktop environment]]
  - [[#window-management][Window management]]
  - [[#workspace-configuration][Workspace configuration]]
  - [[#multi-head-configuration][Multi-head configuration]]
  - [[#x-applications][X applications]]
  - [[#de-components][DE components]]
  - [[#keybindings][Keybindings]]
  - [[#on-startup][On startup]]
  - [[#on-logout][On logout]]
- [[#making-emacs-an-mpd-based-music-player][Making Emacs an ~mpd~-based music player]]
  - [[#loading][Loading]]
  - [[#functions][Functions]]
  - [[#keybindings-1][Keybindings]]
  - [[#configuring][Configuring]]
- [[#giving-files-their-footers][Giving files their footers]]
#+END_QUOTE

* About this configuration

  This file is an attempt at a literate GNU Emacs (henceforth "Emacs")
  configuration. It is /incredibly/ opinionated. Admittedly, much of the
  "documentation" in here is more commentary I provide about my choices and
  personal feelings about certain things in Emacs based on my admittedly very
  limited opinion of the program than honest-to-god documentation of what this
  file contains. Regardless, the idea is that this file, when tangled, generates
  everything in my git repository, from =LICENSE= to =.gitignore=. I would /highly/
  recommend you *NOT* try to read the =.el= files on their own. It's a jungle,
  especially since all of the commentary regarding the configuration is in this
  file and this file alone.

** Okay, that's pretty neat. Why though?

   The answer is rather simple. Before I used a fully literate file, I had an
   =init.el= which tangled blocks from a =config.org= on the fly (read: on startup).
   It turns out this was abysmally slow, making for a startup time of around 4.5
   seconds when loading into my desktop environment. Tangling blocks from a
   =literate-emacs.org= into byte-compiled =early-init.el= and =init.el= alongside the
   use of portable dumping (plus multiple other efficiency improvements, of
   course) cuts this time down to around 1.1 seconds to load into my desktop
   environment. This also comes with the advantage of being a hub for /all/ things
   related to my Emacs configuration, where previously I had to check multiple
   files when I thought I might have changed something for the worse.

** Installation

   1) Clone the repo into where you store your Emacs configuration.
   2) Make sure you have all the right dependencies. See below for more details.
   3) If using Emacs as a desktop environment, it may take a couple restarts to
      work right.

** Dependencies

   Everything has different dependencies so make sure you have what you need.
   The quick and dirty route to getting all these dependencies installed and
   configured is to deploy [[https://github.com/farlado/dotfiles][my dotfiles]].

   #+begin_center
   *THIS CONFIGURATION IS MEANT FOR EMACS 27 AND 28 AND WILL /NOT/ LOAD PROPERLY ON
   EMACS 26 OR EARLIER. THE BRANCH FOR EMACS 26 OR EARLIER IS [[https://github.com/farlado/dotemacs/tree/emacs26-end][HERE]].*
   #+end_center


*** For EXWM

|----------------------+--------------------------------------------|
| EXWM depends on...   | which is used for...                       |
|----------------------+--------------------------------------------|
| ~xorg~                 | obvious reasons                            |
| ~font-awesome~         | workspace names                            |
| ~xcompmgr~             | compositor                                 |
| ~arandr~               | monitor configuration                      |
| ~nm-connection-editor~ | network configuration                      |
| ~pavucontrol~          | volume mixing                              |
| ~firefox~              | browsing the web                           |
| ~libreoffice~          | editing unfriendly documents               |
| ~gimp~                 | editing images (Emacs can't do this sadly) |
| ~musescore~            | editing music                              |
| ~telegram~             | crappy messenger                           |
| ~discord~              | crappier messenger                         |
| ~steam~                | games platform                             |
|----------------------+--------------------------------------------|

*** For ~desktop-environment~

|-----------------------------------+--------------------------------------|
| ~desktop-environment~ depends on... | which is used for...                 |
|-----------------------------------+--------------------------------------|
| ~alsa-utils~                        | volume adjustment                    |
| ~brightnessctl~                     | laptop backlight adjustment          |
| ~maim~                              | screenshots                          |
| ~xclip~                             | copying screenshots to the clipboard |
| ~i3lock-color~                      | lock screen                          |
|-----------------------------------+--------------------------------------|

*** Other

|-------------------+---------------------+------------------------------------|
| Emacs uses...     | which depends on... | which is used for...               |
|-------------------+---------------------+------------------------------------|
| ~EMMS~              | ~mpd~                 | playing music                      |
|-------------------+---------------------+------------------------------------|
| ~nov~               | ~ebook-tools~         | opening epub files                 |
|-------------------+---------------------+------------------------------------|
| ~graphviz-dot-mode~ | ~graphviz~            | process dot files                  |
|-------------------+---------------------+------------------------------------|
| ~flyspell-mode~     | ~aspell~              | spell checking                     |
|-------------------+---------------------+------------------------------------|
| ~wttrin~            | ~curl~                | get weather data from the internet |
|-------------------+---------------------+------------------------------------|
| ~sudo-edit~         | ~sudo~                | duh                                |
|-------------------+---------------------+------------------------------------|
| ~flycheck~          | ~pylint~              | Python syntax checking             |
|-------------------+---------------------+------------------------------------|
| ~company~           | ~jedi~                | Python autocomplete                |
|-------------------+---------------------+------------------------------------|
| ~haskell-mode~      | ~stack~               | everything about Haskell           |
|-------------------+---------------------+------------------------------------|

** License

   Because I +am a lazy piece of shit who doesn't like long licenses+ don't think
   much harm could come from using a pushover license for a configuration, I am
   publishing this literate Emacs configuration under the WTFPL.

#+begin_src text :tangle (user-emacs-file "LICENSE")
  DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
  Version 2, December 2004

  Copyright (c) 2019-20 Farlado

  Everyone is permitted to copy and distribute verbatim or modified
  copies of this license document, and changing it is allowed as long
  as the name is changed.

             DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

   0. You just DO WHAT THE FUCK YOU WANT TO.
#+end_src

** Files to ignore

   Like mentioned above, this file is supposed to tangle into everything in my
   git repository. That includes my =.gitignore= as well.

#+begin_src text :tangle (user-emacs-file ".gitignore")
  .last-package-update-day
  .org-id-locations
  auto-save-list
  dmenu-items
  smex-items
  nov-places
  emacs.pdmp
  transient
  ido.last
  recentf
  eshell
  *.elc
  tramp
  elpa
  emms
  url
#+end_src

* Giving files their headers

  In order to make the files look at least somewhat decent for documentation
  linters, and to warn those who are unfortunate enough to think they'll just
  mosey on into one of them if they want to understand the config, we create
  headers that tell people the reality of the files.

*** =pdumper.el=

    #+begin_src emacs-lisp :tangle (user-emacs-file "lisp/pdumper.el")
      ;;; pdumper.el --- Making a portable dump image

      ;; This file is not part of GNU Emacs.
      
      ;;; Commentary:

      ;; This file has been automatically generated from `literate-emacs.org'.
      ;; If you don't have a copy of that file, it is best not to use this file!
      ;; All relevant commentary is in `literate-emacs.org', not here.
      ;; There may not be any comments past this point.
      ;; Abandon all hope, ye who enter here.
      
      ;;; Code:
    #+end_src

*** =early-init.el=

    #+begin_src emacs-lisp :tangle (user-emacs-file "early-init.el")
      ;;; early-init.el --- Early Initialization of Farlado's Illiterate GNU Emacs

      ;; This file is not part of GNU Emacs.
      
      ;;; Commentary:

      ;; This file has been automatically generated from `literate-emacs.org'.
      ;; If you don't have a copy of that file, it is best not to use this file!
      ;; All relevant commentary is in `literate-emacs.org', not here.
      ;; There may not be any comments past this point.
      ;; Abandon all hope, ye who enter here.
      
      ;;; Code:
    #+end_src

*** =init.el=

    #+begin_src emacs-lisp :tangle (user-emacs-file "init.el")
      ;;; init.el --- Initializing Farlado's Illiterate GNU Emacs

      ;; This file is not part of GNU Emacs.
      
      ;;; Commentary:

      ;; This file has been automatically generated from `literate-emacs.org'.
      ;; If you don't have a copy of that file, it is best not to use this file!
      ;; All relevant commentary is in `literate-emacs.org', not here.
      ;; There may not be any comments past this point.
      ;; Abandon all hope, ye who enter here.
      
      ;;; Code:
    #+end_src

* Making Emacs start quickly

  This is everything related to starting Emacs quickly. First things first is
  setting up a batch script used to create a custom portable dump image,
  followed by what to execute at startup to make initialization faster.

** Starting Emacs FAST
  :properties:
  :header-args: :tangle (user-emacs-file "lisp/pdumper.el")
  :end:

  Even with the "small" amount I ask of Emacs, it's a lot of beef to start up as
  fast as I demand it start up. The portable dumper is an amazing thing. This is
  just a minimal setup for utilizing the portable dumper to make Emacs load
  faster. Every single ~require~ that doesn't create a =LispObject= incompatible
  with the portable dumper can now be skipped while loading. Before I started
  using the portable dumper, I saw start times of around 2.5 seconds. Now I am
  down to 1.1 seconds, having cut about half of the start time out. This script
  must be run while Emacs is *not* open, otherwise it will *crash* Emacs and (if
  you're using ~vterm~ or another virtual terminal inside of Emacs to run the
  script) *the dump image will be corrupted*. To run the script, from the shell
  enter the following, substituting =$USER_EMACS_DIR= for wherever you store your
  Emacs configuration:

  #+begin_src sh :tangle no
    emacs --batch -q -l $USER_EMACS_DIR/lisp/pdumper.el
  #+end_src

*** Load packages

    No need to go overboard here, just load package management. In this step I
    also add two other features to =load-path= which aren't yet packages.

    #+begin_src emacs-lisp
      (require 'package)
      (package-initialize)

      (add-to-list 'load-path (expand-file-name "lisp/xkb" user-emacs-directory))
      (add-to-list 'load-path (expand-file-name "lisp/wallpaper" user-emacs-directory))
    #+end_src

*** Store =load-path=

    For some reason, the dump image doesn't store =load-path=, so it needs to be
    stored here.

    #+begin_src emacs-lisp
      (setq pdumper-load-path load-path
            pdumper-dumped t)
    #+end_src

*** ~require~ packages

    This will save much time later down the line.

    #+begin_src emacs-lisp
      (dolist (package `(;; Core
                         async
                         use-package
                         auto-package-update
                         server

                         ;; Looks
                         dashboard
                         dracula-theme
                         mood-line
                         display-line-numbers
                         rainbow-mode
                         rainbow-delimiters

                         ;; Functionality
                         which-key
                         company
                         company-emoji
                         counsel
                         buffer-move
                         sudo-edit

                         ;; Editing
                         graphviz-dot-mode
                         markdown-mode
                         flyspell
                         swiper
                         popup-kill-ring
                         hungry-delete
                         avy

                         ;; Programming
                         haskell-mode
                         highlight-indent-guides
                         company-jedi
                         flycheck
                         flycheck-posframe
                         avy-flycheck

                         ;; `org-mode'
                         org
                         toc-org
                         org-bullets
                         epresent
                         org-tempo

                         ;; Other
                         nov
                         wttrin

                         ;; games
                         yahtzee
                         sudoku
                         tetris
                         chess
                         2048-game

                         ;; Desktop Environment
                         exwm
                         exwm-randr
                         exwm-config
                         exwm-systemtray
                         ivy-posframe
                         dmenu
                         minibuffer-line
                         system-packages
                         desktop-environment
                         wallpaper
                         xkb

                         ;; Media
                         emms
                         emms-setup))
          (require package))
    #+end_src

*** Pre-load the theme

    Loading the theme takes up much of the time spent initializing Emacs.

    #+begin_src emacs-lisp
      (load-theme 'dracula t t)
    #+end_src

*** Write the dump image

    This is where the magic happens.

    #+begin_src emacs-lisp
      (dump-emacs-portable (expand-file-name "emacs.pdmp" user-emacs-directory))
    #+end_src

** Do these things ASAP
   :properties:
   :header-args: :tangle (user-emacs-file "early-init.el")
   :end:

   Emacs 27 introduced =early-init.el=, allowing configuration of multiple items
   before Emacs has graphically loaded. Either I want these configured as soon
   as possible, or they are related to Emacs starting up. Which are which is
   left as an exercise to the reader.

*** Prepare GUI (Part 1)

    I want to get GUI elements out of my face as soon as I possibly can. They
    just take up space. If I'm running Emacs as my desktop environment (see
    further below), I want Emacs to immediately take on the background color of
    the theme I use.

    #+begin_src emacs-lisp
      (menu-bar-mode -1)
      (tool-bar-mode -1)
      (scroll-bar-mode -1)

      (when (getenv "_RUN_EXWM")
        (set-face-background 'default "#282a36"))
    #+end_src

*** Handling portable dumping

    For some reason, the portable dumper has odd behaviors.

    This block is supposed to:
    - Recover =load-path= from the dump image
    - Restore modes not preserved in the dump image
    - Fix the scratch buffer
    - Create a function to ~require~ a feature only if =pdumper-dumped= is nil

    #+begin_src emacs-lisp
      (defvar pdumper-dumped nil
        "Non-nil if a custom dump image was loaded.")

      (defvar pdumper-load-path nil
        "Contains `load-path' if a custom dump image was loaded.")

      (defun pdumper-require (feature &optional filename noerror)
        "Call `require' to load FEATURE if `pdumper-dumped' is nil.

      FILENAME and NOERROR are also passed to `require'."
        (unless pdumper-dumped
          (require feature filename noerror)))

      (defun pdumper-fix-scratch-buffer ()
        "Ensure the scratch buffer is properly loaded."
        (with-current-buffer "*scratch*"
          (lisp-interaction-mode)))

      (when pdumper-dumped
        (add-hook 'after-init-hook #'pdumper-fix-scratch-buffer)
        (setq load-path pdumper-load-path)
        (global-font-lock-mode 1)
        (transient-mark-mode 1)
        (blink-cursor-mode 1))
    #+end_src

*** Byte-compile on first run

    It's done after =after-init-hook= so that we don't actually do it in the
    middle of loading files. That would be disastrous.

    #+begin_src emacs-lisp
      (defun farl-init/compile-user-emacs-directory ()
        "Recompile all files in `user-emacs-directory'."
        (byte-recompile-directory user-emacs-directory 0))

      (unless (file-exists-p (expand-file-name "init.elc" user-emacs-directory))
        (add-hook 'after-init-hook #'farl-init/compile-user-emacs-directory))
    #+end_src

*** Prefer the newest files

    If there's a difference in time between a file and its byte-compiled
    counterpart, prefer the newer one.

    #+begin_src emacs-lisp
      (setq load-prefer-newer t)
    #+end_src

*** More complete apropos

    This way, apropos does things more thoroughly, even if it's slower.

    #+begin_src emacs-lisp
      (setq-default apropos-do-all t)
    #+end_src

*** File name handling setup

    For whatever reason, setting ~file-name-handler-alist~ to nil helps Emacs load
    faster. After Emacs finishes loading, it's reverted to its original value.

    #+begin_src emacs-lisp
      (defvar startup/file-name-handler-alist file-name-handler-alist
        "Temporary storage for `file-name-handler-alist' during startup.")

      (defun startup/revert-file-name-handler-alist ()
        "Revert `file-name-handler-alist' to its default value after startup."
        (setq file-name-handler-alist startup/file-name-handler-alist))

      (setq file-name-handler-alist nil)
      (add-hook 'emacs-startup-hook #'startup/revert-file-name-handler-alist)
    #+end_src

*** Garbage collection setup

    Garbage collection shouldn't happen during startup, as that will slow Emacs
    down. Do it later. This is also where more ideal garbage collection settings
    are chosen.

    #+begin_src emacs-lisp
      (defun garbage-collect-defer ()
        "Defer garbage collection."
        (setq gc-cons-threshold most-positive-fixnum
              gc-cons-percentage 0.6))

      (defun garbage-collect-restore ()
        "Return garbage collection to normal parameters."
        (setq gc-cons-threshold 16777216
              gc-cons-percentage 0.1))

      (garbage-collect-defer)
      (add-hook 'emacs-startup-hook #'garbage-collect-restore)
    #+end_src

** Early package management
   :properties:
   :header-args: :tangle (user-emacs-file "early-init.el")
   :end:

   Because I am writing this configuration to be as portable as possible (e.g. I
   should be able to dump this onto any machine and run it), I manage all
   packages through Emacs. All of this is done leading up to the call of
   ~package-initialize~ between that =early-init.el= and =init.el=, which makes for
   faster loading.

*** Disable ~customize~, keep ~package-autoremove~ working

    I /hate/ ~customize~. I configure everything in this file, so I don't need
    anything messing with my =init.el=, much less changing settings on me. Even
    though I do not use ~customize~ but really like protecting packages used in my
    configuration from ~package-autoremove~, I need to still set the variable
    =package-selected-packages= so that it'll work. Packages are listed in the
    order in which they are mentioned in this configuration.

    #+begin_src emacs-lisp
      (setq custom-file "/dev/null"
            package-selected-packages '(;; Core
                                        async
                                        use-package
                                        auto-package-update

                                        ;; Looks
                                        dashboard
                                        dracula-theme
                                        mood-line
                                        rainbow-mode
                                        rainbow-delimiters

                                        ;; Functionality
                                        which-key
                                        company
                                        company-emoji
                                        counsel
                                        buffer-move
                                        sudo-edit

                                        ;; Text Editing
                                        graphviz-dot-mode
                                        markdown-mode
                                        swiper
                                        popup-kill-ring
                                        hungry-delete
                                        avy

                                        ;; Programming
                                        magit
                                        haskell-mode
                                        highlight-indent-guides
                                        company-jedi
                                        flycheck
                                        flycheck-posframe
                                        avy-flycheck

                                        ;; `org-mode'
                                        toc-org
                                        org-bullets
                                        epresent

                                        ;; Extend
                                        vterm
                                        nov
                                        wttrin

                                        ;; Games
                                        yahtzee
                                        sudoku
                                        chess
                                        2048-game

                                        ;; Desktop Environment
                                        exwm
                                        ivy-posframe
                                        dmenu
                                        minibuffer-line
                                        system-packages
                                        desktop-environment

                                        ;; Other
                                        emms))
    #+end_src

*** Disable an annoying ~customize~ function

    Since I don't use ~customize~, we don't need to mess with it every time a
    package is installed or uninstalled. Because of this, I need to first load
    everything related to package management.

    #+begin_src emacs-lisp
      (require 'package)
      (defun package--save-selected-packages (&rest opt) nil)
    #+end_src

*** Configure package repositories

    Next, we have to add our repositories to the list. The GNU and MELPA
    repositories should be enough to last me decades.

    #+begin_src emacs-lisp
      (setq package-archives '(("gnu"   . "https://elpa.gnu.org/packages/")
                               ("melpa" . "https://melpa.org/packages/")))
    #+end_src

** Later package management
   :properties:
   :header-args: :tangle (user-emacs-file "init.el")
   :end:

   This part of package management is meant to be done after ~package-initialize~
   has been called. At this point, we can leave =early-init.el= and move into
   =init.el= to continue Emacs startup.

*** Bootstrap ~async~

    This package is super useful for making package installation significantly
    faster. It also allows for asynchronous ~dired~ and byte-compilation.

    #+begin_src emacs-lisp
      (unless (package-installed-p 'async)
        (package-refresh-contents)
        (package-install 'async))

      (dired-async-mode 1)
      (async-bytecomp-package-mode 1)
      (setq async-bytecomp-allowed-packages '(all))
    #+end_src

*** Bootstrap ~use-package~

    Since I manage all Emacs packages in Emacs itself, ~use-package~ makes it much
    easier to install all the packages I need. It also means I can see what
    packages take the longest to load.

    #+begin_src emacs-lisp
      (unless (package-installed-p 'use-package)
        (package-refresh-contents)
        (package-install 'use-package))

      (pdumper-require 'use-package)
      (setq use-package-compute-statistics t)
    #+end_src

*** Automatically update packages

    I don't want to have to manually update my stuff. This solution is literally
    plop-and-forget, and updates packages on a regular interval of two days.

    #+begin_src emacs-lisp
      (use-package auto-package-update
        :ensure t
        :defer t
        :init
        (setq auto-package-update-interval 2
              auto-package-update-hide-results t
              auto-package-update-delete-old-versions t)
        (auto-package-update-maybe))
    #+end_src

** Final considerations
   :properties:
   :header-args: :tangle (user-emacs-file "init.el")
   :end:

   These are other startup-specific things to be done after package management
   is finished being configured, e.g. put into =init.el= instead of =early-init.el=.

*** Start Emacs server

    Having the Emacs server running allows for a lot of neat integration with
    other parts of my desktop environment.

    #+begin_src emacs-lisp
      (use-package server
        :ensure t
        :defer t
        :init
        (pdumper-require 'server)
        (unless (server-running-p)
          (server-start)))
    #+end_src

*** Prepare GUI (Part 2)

    These buggers won't properly set unless it's done after =early-init.el=, which
    is a real bummer.

    #+begin_src emacs-lisp
      (tooltip-mode -1)
      (setq use-dialog-box nil
            use-file-dialog nil)
    #+end_src

*** Alternative start screen

    I like the default start screen, but it just doesn't cut it for me. I just
    use this to have a nice screen when I start Emacs or close all my buffers.

    #+begin_src emacs-lisp :noweb yes
      (use-package dashboard
        :ensure t
        :defer t
        :init
        <<dashboard-or-scratch>>
        (setq dashboard-set-footer nil
              inhibit-startup-screen t
              dashboard-items '((recents . 10))
              dashboard-startup-banner 'logo
              initial-buffer-choice #'dashboard-or-scratch
              dashboard-banner-logo-title "Welcome to Farlado's Illiterate GNU Emacs!")
        (dashboard-setup-startup-hook))
    #+end_src

    When Emacs or ~emacsclient~ starts, the first buffer shown should be either
    dashboard or a scratch buffer.

    #+begin_src emacs-lisp :tangle no :noweb-ref dashboard-or-scratch
      (defun dashboard-or-scratch ()
        "Open either dashboard or the scratch buffer."
        (or (get-buffer "*dashboard*")
            (get-buffer "*scratch*")))
    #+end_src

* Making Emacs much less ugly

  Stock Emacs is /ugly/. Just straight up ugly. Suffice to say it leaves much to
  be desired. This section is specifically meant for fixing Emacs visually and
  making it much more desirable for everyday use.

** Font
   :properties:
   :header-args: :tangle (user-emacs-file "init.el")
   :end:

*** Use UTF-8 encoding

    This makes for a much easier time editing files and working with text. Why
    isn't this the default to begin with since it's basically standard?

    #+begin_src emacs-lisp
      (set-language-environment "UTF-8")
      (set-default-coding-systems 'utf-8)
      (setq locale-coding-system 'utf-8)
      (set-terminal-coding-system 'utf-8)
      (set-keyboard-coding-system 'utf-8)
      (set-selection-coding-system 'utf-8)
      (prefer-coding-system 'utf-8)
    #+end_src

*** Setting the font style

    Originally I had this set up by means of ~custom-set-faces~, but frankly that
    is less easily configured than this method.

    #+begin_src emacs-lisp
      (when (member "Iosevka" (font-family-list))
        (set-face-attribute 'default nil :font "Iosevka" :height 100))
    #+end_src

*** Getting emoji to work properly

    God does this one feel great to have now that I use an Emacs version that
    can handle it! Emoji now render properly in documents! üê≤

    #+begin_src emacs-lisp
      (when (member "Noto Color Emoji" (font-family-list))
        (set-fontset-font t 'symbol (font-spec :family "Noto Color Emoji") nil 'prepend))
    #+end_src

*** Don't unload fonts when not in use

    This solves a number of hanging issues related to a number of different
    packages and symbols. Emacs gets annoyingly slow if this is not set.

    #+begin_src emacs-lisp
      (setq inhibit-compacting-font-caches t)
    #+end_src

** Theme

   For a long time, I used Leuven for my theme. Nowadays, I don't. It was a
   brilliant theme, but just didn't work when I needed a new mode line.

   #+begin_src emacs-lisp :noweb yes :tangle (user-emacs-file "init.el")
     (use-package dracula-theme
       :ensure t
       :defer t
       :init
       (if pdumper-dumped
           (enable-theme 'dracula)
         (load-theme 'dracula t))
       <<fringes>>
       <<line-numbers>>
       <<window-dividers>>
       <<transparent-frames>>
       <<better-org-mode-headers>>)
   #+end_src

*** Fringes

    Having fringes helps keep things looking good and gives the opportunity to
    have nice indicators on the edges of buffers. I prefer when fringes are the
    same color as the rest of the window.

    #+begin_src emacs-lisp :noweb-ref fringes
      (set-face-background 'fringe (face-attribute 'default :background))
      (fringe-mode 10)
    #+end_src

*** Line numbers

    For some reason, some themes like to give line numbers a different background
    from the rest of a window. I hate that.

    #+begin_src emacs-lisp :noweb-ref line-numbers
      (set-face-background 'line-number (face-attribute 'default :background))
    #+end_src

*** Window dividers

    Windows dividers make Emacs look far less sloppy. The color is grabbed from
    the mode line for consistency.

    #+begin_src emacs-lisp :noweb-ref window-dividers
      (setq window-divider-default-right-width 3)
      (let ((color (face-attribute 'mode-line :background)))
        (set-face-foreground 'window-divider-first-pixel color)
        (set-face-foreground 'window-divider-last-pixel color)
        (set-face-foreground 'window-divider color))
      (window-divider-mode 1)
    #+end_src

*** Transparent frames

    If there's a gimmick I can't get enough of, it's having a transparent frame.

    #+begin_src emacs-lisp :noweb-ref transparent-frames
      (dolist (frame (frame-list))
        (set-frame-parameter frame 'alpha 90))
      (add-to-list 'default-frame-alist '(alpha . 90))
    #+end_src

*** Better ~org-mode~ headers

    For some reason, theme creators don't really think of formatting ~org-mode~
    past colors, so I have instead taken matters into my own hands. This way, I
    can use whatever color scheme I want with some peace of mind that at the
    least I don't have to look for ~org~-aware themes. +It also means I can override
    some of the dumber choices of ~org~-aware themes!+

    #+begin_src emacs-lisp :noweb-ref better-org-mode-headers
      ;; Load `org-mode' if it isn't dumped
      (pdumper-require 'org)
      ;; Title
      (set-face-attribute 'org-document-title nil :weight 'extra-bold :height 1.8)
      ;; Headers
      (set-face-attribute 'org-level-1 nil :height 1.3)
      (set-face-attribute 'org-level-2 nil :height 1.1)
      (set-face-attribute 'org-level-3 nil :height 1.0)
    #+end_src

** Mode line

   I hate the default mode line with a burning passion. This mode line, on the
   other hand, is minimal and gorgeous. When configured properly, it is hands
   down the best mode line I have ever used.

   #+begin_src emacs-lisp :noweb yes :tangle (user-emacs-file "init.el")
     (use-package mood-line
       :ensure t
       :defer t
       :init
       (mood-line-mode 1)
       <<flatten>>
       <<clock-and-battery>>
       <<line-and-col-numbers>>)
   #+end_src

*** Make the mode line look flat

    This is just something that bugs me about some themes. I want the mode line
    to not have that silly box around it.

    #+begin_src emacs-lisp :noweb-ref flatten
      (set-face-attribute 'mode-line nil :box nil)
      (set-face-attribute 'mode-line-inactive nil :box nil)
    #+end_src

*** Show clock and battery level on mode line

    I use 24-hour time on all my clocks. I used to use ~fancy-battery~ for battery
    level but it constantly disappeared on my teeny tiny screens so I just
    decided not to bother with it. Plus it's one less package to configure lol.

    #+begin_src emacs-lisp :noweb-ref clock-and-battery
      (setq display-time-24hr-format t)
      (display-time-mode 1)
      (display-battery-mode 1)
    #+end_src

*** Show line and column numbers on the mode line

    Why isn't this enabled by default on a /text editor/?

    #+begin_src emacs-lisp :noweb-ref line-and-col-numbers
      (line-number-mode 1)
      (column-number-mode 1)
    #+end_src

** In buffers
   :properties:
   :header-args: :tangle (user-emacs-file "init.el")
   :end:

*** Word wrapping

    This is a more point of convenience than aesthetic, even in programming
    language buffers. Wrapping words makes for a heck of a lot more readability
    of any kind of text, whether a program or just normal language.

    #+begin_src emacs-lisp
      (global-visual-line-mode 1)
    #+end_src

*** Turn ^L into pretty lines

    This is used in a number of places in Emacs. Better to have it on all the
    time than never on.

    #+begin_src emacs-lisp
      (global-page-break-lines-mode 1)
    #+end_src

*** Line numbers (on most buffers)

    I like having line numbers and indicators for lines past the EOF. However, I
    don't like line numbers in modes where it breaks the mode.

    #+begin_src emacs-lisp
      (use-package display-line-numbers
        :ensure t
        :defer t
        :init
        (setq-default indicate-empty-lines t)
        :hook ((text-mode
                prog-mode
                conf-mode) . display-line-numbers-mode))
    #+end_src

*** Highlight matching parentheses

    For when I can't figure out what's going on with parentheses...

    #+begin_src emacs-lisp
      (show-paren-mode 1)
      (set-face-attribute 'show-paren-match nil :weight 'extra-bold :underline t)
      (setq show-paren-style 'parentheses
            show-paren-delay 0)
    #+end_src

*** Color the background of text based on the color/hex typed

    I don't use it too much, but it's nice to have it around.

    #+begin_src emacs-lisp
      (use-package rainbow-mode
        :if window-system
        :ensure t
        :defer t
        :hook (prog-mode . rainbow-mode))
    #+end_src

*** Change the color of various delimiters based on how deep they go

    It's subtle on my theme, but it still helps me keep track of my brackets and
    parentheses and other important delimiters.

    #+begin_src emacs-lisp
      (use-package rainbow-delimiters
        :ensure t
        :defer t
        :hook (prog-mode . rainbow-delimiters-mode))
    #+end_src

* Making Emacs more comfortable
  :properties:
  :header-args: :tangle (user-emacs-file "init.el")
  :end:

  Anyone who has used Emacs for any period of time can attest to the fact it
  takes a lot to make Emacs comfortable for one's use. That is not to say that
  Emacs is /bad/, but it definitely isn't the most usable piece of software
  straight out of the box.

** General functionality
*** No suspending Emacs

    Why is this even something bound to begin with?

    #+begin_src emacs-lisp
      (global-unset-key (kbd "C-x C-z"))
      (global-unset-key (kbd "C-z"))
    #+end_src

*** No more training wheels

    I'm a big boy now.

    #+begin_src emacs-lisp
      (setq disabled-command-function nil)
    #+end_src

*** Don't hang the minibuffer

    When using the minibuffer, never do garbage collection.

    #+begin_src emacs-lisp
      (add-hook 'minibuffer-setup-hook #'garbage-collect-defer)
      (add-hook 'minibuffer-exit-hook #'garbage-collect-restore)
    #+end_src

*** Always confirm closing Emacs

    I constantly kill Emacs on accident when running it in terminals, so this
    prevents me from doing that +as easily+.

    #+begin_src emacs-lisp
      (setq confirm-kill-emacs 'yes-or-no-p)
    #+end_src

*** Don't hide the cursor by default

    I need to know where my cursor is at all times.

    #+begin_src emacs-lisp
      (setq make-pointer-invisible nil)
    #+end_src

*** Make scrolling a little less crazy

    Not sure why the mouse wheel gets acceleration, but thankfully I don't have
    to worry about that anymore.

    #+begin_src emacs-lisp
      (setq scroll-margin 0
            auto-window-vscroll nil
            scroll-conservatively 100000
            scroll-preserve-screen-position 1
            mouse-wheel-scroll-amount '(1 ((shift) . 1))
            mouse-wheel-progressive-speed nil
            mouse-wheel-follow-mouse t)
    #+end_src

*** Use a visual bell instead of making noise

    Sound is obnoxious and it should be visibly obvious without flashing the
    frame or mode line that something has gone wrong.

    #+begin_src emacs-lisp
      (setq ring-bell-function 'ignore)
    #+end_src

*** Replace "yes or no" prompts with "y or n" prompts

    Beauty in brevity.

    #+begin_src emacs-lisp
      (defalias 'yes-or-no-p #'y-or-n-p)
    #+end_src

** Completion helpers
*** ~which-key~ (small menus to help with commands)

    Even as I've gotten used to Emacs key bindings, it is always nice to have
    this around so that if I want to know, I can easily see what's what.

    #+begin_src emacs-lisp
      (use-package which-key
        :ensure t
        :defer t
        :hook (after-init . which-key-mode))
    #+end_src

*** Auto-complete in documents

    This is the base package. I changed some key bindings to make it more
    pleasant to use. It's not just for programming anymore, as seen in the next
    block.

    #+begin_src emacs-lisp
      (use-package company
        :ensure t
        :defer t
        :init
        (setq company-idle-delay 0.75
              company-minimum-prefix-length 3)
        :hook (after-init . global-company-mode)
        :bind (:map company-active-map
               ("M-n" . nil)
               ("M-p" . nil)
               ("C-n" . company-select-next)
               ("C-p" . company-select-previous)
               ("SPC" . company-abort)))
    #+end_src

*** Typing Emoji using Emacs

    Thanks to ~company~ above, this is possible now!

    #+begin_src emacs-lisp
      (use-package company-emoji
        :after company
        :ensure t
        :defer t
        :init
        (add-to-list 'company-backends 'company-emoji))
    #+end_src

*** Auto-completion for commands

    I /love/ ~ido-mode~, but sometimes it just doesn't cut it. For those times, I
    instead use ~counsel~, which provides a fancier completion experience than
    ~ido-mode~ does currently. It's also way more ubiquitous than ~ido-mode~.

    #+begin_src emacs-lisp
      (use-package counsel
        :ensure t
        :defer t
        :init
        (defun farl-init/ivy-mode ()
          "Start `ivy-mode' while disabling `ido-mode'."
          (ivy-mode 1)
          (ido-mode -1))
        (pdumper-require 'counsel)
        (setq ivy-initial-inputs-alist nil)
        :hook (after-init . farl-init/ivy-mode)
        :bind (("M-x" . counsel-M-x)
               ("C-x C-f" . counsel-find-file)
               ("C-c d" . counsel-cd)))
    #+end_src

** Functions/macros
*** Find a string in a buffer's file name

    #+begin_src emacs-lisp
      (defun buffer-file-match (string)
        "Find STRING in variable `buffer-file-name'."
        (string-match-p string buffer-file-name))
    #+end_src

*** Reference a file in =user-emacs-directory=

    Yeah, ~locate-user-emacs-file~ exists, but I keep this macro around anyway.

    #+begin_src emacs-lisp
      (defmacro user-emacs-file (file)
        "Find FILE in `user-emacs-directory'."
        (expand-file-name file user-emacs-directory))
    #+end_src

*** Reference a file in the home directory

    This macro, much like ~user-emacs-file~, is meant to make for easy shorthand.

    #+begin_src emacs-lisp
      (defmacro user-home-file (file)
        "Find FILE in the user's home directory."
        (expand-file-name file (getenv "HOME")))
    #+end_src

*** Reference a file in =$XDG_CONFIG_HOME=

    This is also crucial for my literate dotfiles, since I am maximizing the
    compliance of my dotfiles with the XDG Base Directory Specification.

    #+begin_src emacs-lisp
      (defmacro user-config-file (file)
        "Find a FILE in the user's $XDG_CONFIG_HOME directory."
        (expand-file-name file (getenv "XDG_CONFIG_HOME")))
    #+end_src

** Buffers/windows
*** Sloppy focus windows

    I hate having to click to focus a different window, so I would rather just
    have windows sloppily focus.

    #+begin_src emacs-lisp
      (setq focus-follows-mouse t
            mouse-autoselect-window t)
    #+end_src

*** Making buffer names unique

    This looks a lot fancier than the default behavior.

    #+begin_src emacs-lisp
      (setq uniquify-buffer-name-style 'forward
            uniquify-after-kill-buffer-p t)
    #+end_src

*** Make the scratch buffer immortal and start blank

    I kill the scratch buffer way too often if I don't do this. While I'm here,
    I might as well also make the scratch buffer blank.

    #+begin_src emacs-lisp
      (with-current-buffer "*scratch*"
        (emacs-lock-mode 'kill))

      (setq initial-scratch-message "")
    #+end_src

*** ~buffer-move~ (moving windows) and ~windmove~ (changing focus)

    Since apparently =C-x C-o= is actually something useful by default, I decided
    to squash ~windmove~ and ~buffer-move~ into a single keymap.

    #+begin_src emacs-lisp
      (use-package buffer-move
        :ensure t
        :defer t
        :init
        (defvar buffer-move-and-windmove-map
          (let ((map (make-sparse-keymap)))
            (define-key map (kbd "w") #'windmove-up)
            (define-key map (kbd "a") #'windmove-left)
            (define-key map (kbd "s") #'windmove-down)
            (define-key map (kbd "d") #'windmove-right)
            (define-key map (kbd "C-w") #'buf-move-up)
            (define-key map (kbd "C-a") #'buf-move-left)
            (define-key map (kbd "C-s") #'buf-move-down)
            (define-key map (kbd "C-d") #'buf-move-right)
            map)
          "A keymap for `buffer-move' and `windmove' functions.")
        (global-set-key (kbd "C-x o") buffer-move-and-windmove-map))
    #+end_src

*** Move focus and show ~ibuffer~ when explicitly creating new windows

    This to me is preferable to the default behavior.

    #+begin_src emacs-lisp
      (defun split-and-follow-vertical ()
        "Open a new window vertically."
        (interactive)
        (split-window-below)
        (other-window 1)
        (ibuffer))

      (defun split-and-follow-horizontal ()
        "Open a new window horizontally."
        (interactive)
        (split-window-right)
        (other-window 1)
        (ibuffer))

      (global-set-key (kbd "C-x 2") #'split-and-follow-vertical)
      (global-set-key (kbd "C-x 3") #'split-and-follow-horizontal)
    #+end_src

** Key binds
*** Use ~ibuffer~ on =C-x b=

    #+begin_src emacs-lisp
      (global-set-key (kbd "C-x b") #'ibuffer)
      (global-unset-key (kbd "C-x C-b"))
    #+end_src

*** Open Emacs configuration with =C-c e=

    #+begin_src emacs-lisp
      (defun config-visit ()
        "Open the configuration file."
        (interactive)
        (find-file (user-emacs-file "literate-emacs.org")))

      (global-set-key (kbd "C-c e") #'config-visit)
    #+end_src

*** Open dotfiles configuration with =C-c M-e=

    #+begin_src emacs-lisp
      (defun literate-dotfiles-visit ()
        "Open the literate dotfiles."
        (interactive)
        (find-file (user-config-file "dotfiles/literate-dotfiles.org")))

      (when (file-exists-p (user-config-file "dotfiles/literate-dotfiles.org"))
        (global-set-key (kbd "C-c M-e") #'literate-dotfiles-visit))
    #+end_src

*** Open system configuration with =C-c C-M-e=

    #+begin_src emacs-lisp
      (defun sys-config-visit ()
        "Open the literate system configuration"
        (interactive)
        (find-file (user-config-file "dotfiles/literate-sysconfig.org")))

      (when (file-exists-p (user-config-file "dotfiles/literate-sysconfig.org"))
        (global-set-key (kbd "C-c C-M-e") #'sys-config-visit))
    #+end_src

*** Restart dashboard with =C-c M-d=

    #+begin_src emacs-lisp
      (defun dashboard-restart ()
        "Restart the dashboard buffer and switch to it."
        (interactive)
        (dashboard-insert-startupify-lists)
        (switch-to-buffer "*dashboard*"))

      (global-set-key (kbd "C-c M-d") #'dashboard-restart)
    #+end_src

*** Balance window sizes with =C-c b=

    #+begin_src emacs-lisp
      (global-set-key (kbd "C-c b") #'balance-windows)
    #+end_src

*** Kill the current buffer with =C-x k=

    #+begin_src emacs-lisp
      (global-set-key (kbd "C-x k") #'kill-this-buffer)
    #+end_src

*** Kill both the buffer and window with =C-x C-k=

    I had to adjust the function which kills both the current buffer and the
    current window, because it did not cooperate with EXWM buffers.

    #+begin_src emacs-lisp
      (defun kill-this-buffer-and-window ()
        "Kill the current buffer and delete the selected window.

      This function has been altered from `kill-buffer-and-window' for `exwm-mode'."
        (interactive)
        (let ((window-to-delete (selected-window))
              (buffer-to-kill (current-buffer))
              (delete-window-hook (lambda ()
                                    (ignore-errors
                                      (delete-window)))))
          (unwind-protect
              (progn
                (add-hook 'kill-buffer-hook delete-window-hook t t)
                (if (kill-buffer (current-buffer))
                    ;; If `delete-window' failed before, we repeat
                    ;; it to regenerate the error in the echo area.
                    (when (eq (selected-window) window-to-delete)
                      (delete-window)))))))

      (global-set-key (kbd "C-x C-k") #'kill-this-buffer-and-window)
    #+end_src

*** Kill all buffers and all windows with =C-x C-M-k=

    #+begin_src emacs-lisp
      (defun close-buffers-and-windows ()
        "Kill every buffer and close all windows, then restart dashboard."
        (interactive)
        (when (yes-or-no-p "Really kill all buffers? ")
          (save-some-buffers)
          (mapc 'kill-buffer (buffer-list))
          (delete-other-windows)
          (dashboard-restart)))

      (global-set-key (kbd "C-x C-M-k") #'close-buffers-and-windows)
    #+end_src

*** Edit files with superuser privileges using =C-x C-M-f=

    This is especially useful when I need to edit system files.

    #+begin_src emacs-lisp
      (use-package sudo-edit
        :ensure t
        :defer t
        :bind ("C-x C-M-f" . sudo-edit))
    #+end_src

* Making Emacs a good text editor
  :properties:
  :header-args: :tangle (user-emacs-file "init.el")
  :end:

  Emacs /is/ a text editor... right? This used to be a +much bigger+ mess of
  different sections, but I've been working to categorize these settings far
  better. So, much of what was previously elsewhere is now set up in here.
  Everything in here /should/ be about making Emacs pleasant to use for editing
  text of various kinds. If it isn't, I have failed.

** Additional major modes

   These are modes that enable Emacs to edit different kinds of files
   differently. Programming major modes are further down, in the
   programming section.

*** ~graphviz-dot-mode~ (diagram creation)

    A nice way to make diagrams.

    #+begin_src emacs-lisp
      (use-package graphviz-dot-mode
        :ensure t
        :defer t
        :init
        (pdumper-require 'graphviz-dot-mode))
    #+end_src

*** ~markdown-mode~ (bootleg org-mode for GitHub)

    I really don't like Markdown but I have to use it, so...

    #+begin_src emacs-lisp
      (use-package markdown-mode
        :ensure t
        :defer t)
    #+end_src

** Personal save hooks

   When I save a file, sometimes I want specific things to be done.

*** Tangle literate programming files

    I've gotten really into literate programming lately, so this makes it much
    easier to tangle files.

    #+begin_src emacs-lisp
      (defun tangle-literate-program ()
        "Tangle a file if it's a literate programming file."
        (interactive)
        (when (buffer-file-match "literate.*.org$")
          (org-babel-tangle)))

      (add-hook 'after-save-hook #'tangle-literate-program -100)
    #+end_src

*** Automatically byte-compile Emacs files

    This is meant to happen when I save my Emacs configuration, so that all
    bytecode is up to date.

    #+begin_src emacs-lisp
      (defun byte-compile-config-files ()
        "Byte-compile Emacs configuration files."
        (when (string-match-p "literate-emacs.org" (buffer-file-name))
          (byte-recompile-directory user-emacs-directory 0)))

      (add-hook 'after-save-hook #'byte-compile-config-files 100)
    #+end_src

** General editing

   These settings are specifically about editing text in general.

*** Spell-checking

    Just a useful little tool to check spelling while editing a buffer. Only
    configured if ~aspell~ is installed. It's not super great, but it does the
    trick well enough for me.

    #+begin_src emacs-lisp
      (use-package flyspell
        :if (executable-find "aspell")
        :ensure t
        :defer t
        :init
        (pdumper-require 'flyspell)
        (setq ispell-program-name "aspell"
              ispell-dictionary "american")
        :hook ((flyspell-mode . flyspell-buffer)
               ((prog-mode
                 conf-mode) . flyspell-prog-mode)
               (text-mode . flyspell-mode)))
    #+end_src

*** Better search behavior

    This search behavior is *SO* much nicer than the default.

    #+begin_src emacs-lisp
      (use-package swiper
        :ensure t
        :defer t
        :bind ("C-s" . swiper))
    #+end_src

*** No backups or auto-saving

    I love living on the edge.

    #+begin_src emacs-lisp
      (setq backup-inhibited t
            make-backup-files nil
            auto-save-default nil)
    #+end_src

*** Automatically revert files on change

    This way if files get modified in the middle of editing them, I don't
    overwrite the changes. This can also change ~dired~ and ~ibuffer~ buffers if I
    am not mistaken. However, I don't need to hear every last thing about it.

    #+begin_src emacs-lisp
      (global-auto-revert-mode 1)

      (setq global-auto-revert-non-file-buffers t
            auto-revert-remote-files t
            auto-revert-verbose nil)
    #+end_src

*** End-of-file newlines and indent tabs

    Screw indent tabs, spaces all the way. Also, if there is no end-of-file
    newline, add it. Things that help me keep my files nice and clean.

    #+begin_src emacs-lisp
      (setq require-final-newline t)
      (setq-default indent-tabs-mode nil)
    #+end_src

*** Manage the kill ring using a pop-up menu

    Having the whole kill ring easy to scroll through is much less hassle than
    default behavior. We also set up some yanking behavior while we're at it.

    #+begin_src emacs-lisp
      (use-package popup-kill-ring
        :ensure t
        :defer t
        :bind ("M-y" . popup-kill-ring)
        :init
        (setq save-interprogram-paste-before-kill t
              mouse-drag-copy-region t
              mouse-yank-at-point t))
    #+end_src

*** Delete whatever is selected if typing starts

    This is to reflect behavior in other programs.

    #+begin_src emacs-lisp
      (delete-selection-mode 1)
    #+end_src

*** Hungrily remove all whitespace when deleting

    This saves me tons of time when it comes to managing whitespace. Instead of
    having to repeatedly press delete or backspace, a single keystroke decimates
    all the whitespace between the point and whatever is in the direction the
    deletion happens.

    #+begin_src emacs-lisp
      (use-package hungry-delete
        :ensure t
        :defer t
        :init
        (global-hungry-delete-mode 1))
    #+end_src

*** Move around visible portions of files faster

    If I want to hop around in a document without calling swiper, ~avy~ is
    definitely the way to go.

    #+begin_src emacs-lisp
      (use-package avy
        :ensure t
        :defer t
        :bind ("M-s" . avy-goto-char))
    #+end_src

*** Move between SubWords as well as between words

    This allows for much easier navigation between words when in programming
    language buffers, but also has utility outside of programming so it's
    enabled globally.

    #+begin_src emacs-lisp
      (global-subword-mode 1)
    #+end_src

*** electric-pair-mode (OH MY GOD THIS IS SO GREAT)

    I have no words for how convenient this has been and how much faster I get
    things done thanks to these six lines of elisp.

    #+begin_src emacs-lisp
      (setq electric-pair-pairs '((?\{ . ?\})
                                  (?\( . ?\))
                                  (?\[ . ?\])
                                  (?\" . ?\")))
      (electric-pair-mode 1)
      (minibuffer-electric-default-mode 1)
    #+end_src

*** Kill an entire word when you're in the middle of it

    I don't need it super often, but it's still nice to have.

    #+begin_src emacs-lisp
      (defun whole-kill-word ()
        "Delete an entire word."
        (interactive)
        (backward-word)
        (kill-word 1))

      (global-set-key (kbd "C-c DEL") #'whole-kill-word)
    #+end_src

** Programming

   It's slowly growing, but I still truly do not need all that much when it
   comes to programming, mostly because I don't actually do all that much
   programming outside what I do for fun... and editing this file.

*** Use SBCL for inferior Lisp mode

    #+begin_src emacs-lisp
      (setq inferior-lisp-program "sbcl")
    #+end_src

*** ~magit~ (git but in Emacs)

    I used to use a terminal for this, but holy crap this is a lot easier, a lot
    faster, and a whole lot nicer to use overall.

    #+begin_src emacs-lisp
      (use-package magit
        :ensure t
        :defer t
        :bind ("C-x g" . magit-status))
    #+end_src

*** ~haskell-mode~

    I have started to mess around with Haskell, so I needed to grab a mode for
    that. This supplies basically everything I need as far as I know, e.g.
    company autocompletion and flycheck information.

    #+begin_src emacs-lisp
      (use-package haskell-mode
        :ensure t
        :defer t
        :init
        (setq haskell-stylish-on-save t)
        :hook ((haskell-mode . interactive-haskell-mode)
               (haskell-mode . haskell-doc-mode)
               (haskell-mode . haskell-indentation-mode)
               (haskell-mode . haskell-auto-insert-module-template)))
    #+end_src

*** Indent guides

    This is really nice to have, because I screw up indentation all the time.

    #+begin_src emacs-lisp
      (use-package highlight-indent-guides
        :if window-system
        :ensure t
        :defer t
        :init
        (setq highlight-indent-guides-method 'character)
        :hook (prog-mode . highlight-indent-guides-mode))
    #+end_src

*** Python autocomplete

    #+begin_src emacs-lisp
      (use-package company-jedi
        :after company
        :ensure t
        :defer t
        :init
        (add-to-list 'company-backends 'company-jedi))
    #+end_src

*** On-the-fly syntax checking

    This is nice to have so I can be told right away when something's wrong.

    #+begin_src emacs-lisp
      (use-package flycheck
        :ensure t
        :defer t
        :hook (prog-mode . flycheck-mode))
    #+end_src

*** Move ~flycheck~ issues out of the minibuffer

    I want errors to be in their own area, not polluting the minibuffer.

    #+begin_src emacs-lisp
      (use-package flycheck-posframe
        :if window-system
        :after flycheck
        :ensure t
        :defer t
        :init
        (setq flycheck-posframe-position 'window-bottom-left-corner)
        :hook ((flycheck-mode . flycheck-posframe-mode)
               (flycheck-posframe-mode . flycheck-posframe-configure-pretty-defaults)))
    #+end_src

*** ~avy~-style navigation but between syntax errors

    This one is *SUPER COOL*. Being able to jump straight to a problem is comfy.

    #+begin_src emacs-lisp
      (use-package avy-flycheck
        :ensure t
        :defer t
        :bind (:map prog-mode-map
               ("C-c C-'" . avy-flycheck-goto-error)))
    #+end_src

** Org-mode
   :properties:
   :header-args: :tangle no :noweb-ref org-init
   :end:

   As I spend more time in Org-mode, the more I need from it.

   #+begin_src emacs-lisp :noweb yes :noweb-ref no :tangle (user-emacs-file "init.el")
     (use-package org
       :ensure t
       :defer t
       :init
       <<org-init>>
       :hook (
              <<org-hooks>>
              )
       :bind (
              <<org-binds>>
              )
       )
   #+end_src

*** Table of Contents

    This automates creating the table of contents for an ~org-mode~ document. It
    also works in ~markdown-mode~ too if I ever have to use Markdown.

    #+begin_src emacs-lisp
      (use-package toc-org
        :ensure t
        :defer t
        :hook ((org-mode . toc-org-mode)
               (markdown-mode . toc-org-mode)))
    #+end_src

*** Fancier bullet points

    It's kinda slow, but bullet points are very nice, better than asterisks.

    #+begin_src emacs-lisp
      (use-package org-bullets
        :if window-system
        :ensure t
        :defer t
        :hook (org-mode . org-bullets-mode))
    #+end_src

*** Presentations in Emacs

    It's gonna need more polish, but it works.

    #+begin_src emacs-lisp
      (use-package epresent
        :if window-system
        :ensure t
        :defer t
        :bind (:map org-mode-map
               ("C-c r" . epresent-run)))
    #+end_src

*** Quality-of-life settings

    These are just quick things that make ~org-mode~ much easier to use.

    #+begin_src emacs-lisp
      (setq org-pretty-entities t
            org-src-fontify-natively t
            org-agenda-use-time-grid nil
            org-fontify-done-headline t
            org-src-tab-acts-natively t
            org-enforce-todo-dependencies t
            org-fontify-whole-heading-line t
            org-agenda-skip-deadline-if-done t
            org-agenda-skip-scheduled-if-done t
            org-fontify-quote-and-verse-blocks t
            org-src-window-setup 'current-window
            org-highlight-latex-and-related '(latex)
            org-ellipsis (if window-system "‚§µ" "...")
            org-hide-emphasis-markers window-system)
    #+end_src

*** Evaluating Graphviz blocks

    Since obviously dot snippets are purely harmless +as far as I know+, I just
    don't bother with having to confirm evaluation every time I try to update a
    graphic.

    #+begin_src emacs-lisp
      (org-babel-do-load-languages 'org-babel-load-languages '((dot . t)))
    #+end_src

*** Execute some code without having to confirm

    Since obviously dot snippets are purely harmless +as far as I know+, I just
    don't bother with having to confirm evaluation every time I try to update a
    graphic. I also don't need to confirm evaluation of snippets in use in my
    literate files.

    #+begin_src emacs-lisp
      (defun farl-org/confirm-babel-evaluate (lang body)
        "Don't ask to evaluate graphviz blocks or literate programming blocks."
        (not (or (string= lang "dot")
                 (buffer-file-match "literate.*.org$"))))

      (setq org-confirm-babel-evaluate #'farl-org/confirm-babel-evaluate)
    #+end_src

*** Shortcuts for various snippets

    First, we load ~org-tempo~, the extension that allows the old way of doing
    things, and add it to =org-modules=. Then, we add shortcuts for the individual
    blocks of code. Finally, we can add shortcuts for other items that aren't
    blocks. I've grown somewhat fond of this way of organizing my shortcuts,
    because it separates the blocks from the one-liners.

    #+begin_src emacs-lisp
      (pdumper-require 'org-tempo)
      (add-to-list 'org-modules 'org-tempo)
      (setq org-structure-template-alist '(;; General blocks
                                           ("c" . "center")
                                           ("C" . "comment")
                                           ("e" . "example")
                                           ("q" . "quote")
                                           ("v" . "verse")

                                           ;; Export blocks
                                           ("a"   . "export ascii")
                                           ("h"   . "export html")
                                           ("css" . "export css")
                                           ("l"   . "export latex")

                                           ;; Code blocks
                                           ("s"   . "src")
                                           ("sh"  . "src sh")
                                           ("cf"  . "src conf")
                                           ("cu"  . "src conf-unix")
                                           ("cs"  . "src conf-space")
                                           ("cx"  . "src conf-xdefaults")
                                           ("cjp" . "src conf-javaprop")
                                           ("el"  . "src emacs-lisp")
                                           ("py"  . "src python")
                                           ("dot" . "src dot :file")
                                           ("txt" . "src text :tangle"))
            org-tempo-keywords-alist '(;; Title/subtitle/author
                                       ("t"  . "title")
                                       ("st" . "subtitle")
                                       ("au" . "author")

                                       ;; Language
                                       ("la" . "language")

                                       ;; Name/caption
                                       ("n"  . "name")
                                       ("ca" . "caption")

                                       ;; Property/options/startup
                                       ("p"  . "property")
                                       ("o"  . "options")
                                       ("su" . "startup")

                                       ;; Other
                                       ("L" . "latex")
                                       ("H" . "html")
                                       ("A" . "ascii")
                                       ("i" . "index")))
    #+end_src

*** Don't give angle brackets syntax

    For some reason, starting with ~org-mode~ 9.3 or so, all symbols that are
    brackets, i.e. ={}=, =()=, =<>=, are given syntax as pairs. This isn't a problem
    on its own (especially since it makes quotations and parentheses far easier
    to work with), but /angle brackets specifically/ cause issues since they
    specifically are inequality operators in my books and =<= is the prefix for
    the shortcuts provided by ~org-tempo~.

    #+begin_src emacs-lisp
      (defun farl-org/disable-angle-bracket-syntax ()
        "Disable angle bracket syntax."
        (modify-syntax-entry ?< ".")
        (modify-syntax-entry ?> "."))
    #+end_src

    This function is hooked in =org-mode-hook=.

    #+begin_src emacs-lisp :noweb-ref org-hooks
      (org-mode . farl-org/disable-angle-bracket-syntax)
    #+end_src

*** Agenda (only enabled if an agenda is found)

    I store my agendas in =$HOME/agendas=.

    #+begin_src emacs-lisp
      (defun open-agenda-file ()
        "Open the agenda file."
        (interactive)
        (find-file (ivy-read
                    "Open agenda: "
                    (all-completions "" org-agenda-files))))

      (when (file-directory-p "~/agendas")
        (setq org-agenda-files (directory-files-recursively
                                (user-home-file "agendas")
                                ".org$" nil t t)))
    #+end_src

    I open the agenda with =C-c M-a= and open a specific agenda file with =C-c s-a=.

    #+begin_src emacs-lisp :noweb-ref org-binds
      ("C-c M-a" . org-agenda)
      ("C-c s-a" . open-agenda-file)
    #+end_src

*** Use the current window when editing source blocks

    This is just a convenience thing.

    #+begin_src emacs-lisp
      (setq org-src-window-setup 'current-window)
    #+end_src

*** Automatically fix inline images generated for diagrams

    This is exactly what I was looking for lmao

    #+begin_src emacs-lisp :noweb-ref org-hooks
      (org-babel-after-execute . org-redisplay-inline-images)
    #+end_src

* Making Emacs more than an editor
  :properties:
  :header-args: :tangle (user-emacs-file "init.el")
  :end:

  Emacs is also more than just an editor, right? If it isn't about editing text
  but also isn't a major thing, it will probably be found in here.

** Not built-in
*** Emacs is my terminal

    I've been jumping between ~vterm~ and ~ansi-term~. In the end ~vterm~ blows
    ~ansi-term~ clean out of the water. In the off-chance I'm running Emacs in the
    terminal, =C-c t= can open ~vterm~.

    #+begin_src emacs-lisp
      (use-package vterm
        :ensure t
        :defer t
        :bind ("C-c t" . vterm))
    #+end_src

*** Reading ebooks in Emacs

    Not the best way to do epub reading, but at least it's in Emacs.

    #+begin_src emacs-lisp
      (use-package nov
        :ensure t
        :defer t
        :mode ("\\.epub\\'" . nov-mode))
    #+end_src

*** Getting the weather using Emacs

    Picking a service to use for this was a pain. I ended up settling for wttrin
    because it is the fastest and easiest to use, and plays nice with my setup.

    #+begin_src emacs-lisp
      (use-package wttrin
        :ensure t
        :defer t
        :init
        (setq wttrin-default-cities '("Indianapolis"))
        :bind ("C-c w" . wttrin))
    #+end_src

** Built-in
*** Calendar

    Weeks start on Monday.

    #+begin_src emacs-lisp
      (setq calendar-week-start-day 1)
      (global-set-key (kbd "C-c l") #'calendar)
    #+end_src

*** Reading the manpages

    Wow, there's actually an Emacs mode for this! I put these into the =C-h=
    binds, since it is a way of getting help, after all. If for some reason ~man~
    is working, ~woman~ can still grab a manpage without calling ~man~.

    #+begin_src emacs-lisp
      (global-set-key (kbd "C-h 4 m") #'man)
      (global-set-key (kbd "C-h 4 w") #'woman)
    #+end_src

** Games

   To make running games easier, I set up a keymap to which I add the games.

   #+begin_src emacs-lisp
     (defvar games-map (make-sparse-keymap)
       "A keymap to which games can be added.")

     (global-set-key (kbd "C-c g") games-map)
   #+end_src

*** Yahtzee

    Fun dice game. Now I can get mad at Emacs instead of my sister.

    #+begin_src emacs-lisp
      (use-package yahtzee
        :ensure t
        :defer t
        :bind (:map games-map
               ("y" . yahtzee)))
    #+end_src

*** Sudoku

    I /love/ sudoku puzzles.

    #+begin_src emacs-lisp
      (use-package sudoku
        :ensure t
        :defer t
        :bind (:map games-map
               ("s" . sudoku)))
    #+end_src

*** Tetris

    Tetris is my childhood. No way I wouldn't set it up to be nice and comfy.

    #+begin_src emacs-lisp
      (use-package tetris
        :ensure t
        :defer t
        :bind (:map games-map
               ("t" . 'tetris)
               :map tetris-mode-map
               ("w" . tetris-move-bottom)
               ("a" . tetris-move-left)
               ("s" . tetris-mode-down)
               ("d" . tetris-move-right)
               ([left] . tetris-rotate-next)
               ([right] . tetris-rotate-prev)
               ([?\t] . tetris-pause-game)
               ("r" . tetris-start-game)
               ("e" . tetris-end-game)))
    #+end_src

*** Chess

    Just for fun. I suck at chess but it's nice to have.

    #+begin_src emacs-lisp
      (use-package chess
        :ensure t
        :defer t
        :bind (:map games-map
               ("c" . chess)))
    #+end_src

*** 2048

    A simple and fun game. Was a big deal when I was in high school. I still
    play it from time to time.

    #+begin_src emacs-lisp
      (use-package 2048-game
        :ensure t
        :defer t
        :bind (:map games-map
               ("2" . 2048-game)))
    #+end_src

* Making Emacs a desktop environment

  Yes, Emacs is my *entire desktop environment*. You should probably remove this
  section if you don't plan to use Emacs as your desktop environment, but
  including it doesn't have any disadvantages either, since it only loads if an
  environment variable =_RUN_EXWM= exists, which it promptly unsets. Make a note
  of this when writing your =.xinitrc= or writing a =.desktop= file to load Emacs as
  your desktop environment.

  #+begin_src emacs-lisp :noweb yes :tangle (user-emacs-file "init.el")
    (use-package exwm
      :if (getenv "_RUN_EXWM")
      :ensure t
      :defer t
      :init
      (setenv "_RUN_EXWM")
      (pdumper-require 'exwm)
      (pdumper-require 'exwm-randr)
      (pdumper-require 'exwm-config)
      (pdumper-require 'exwm-systemtray)
      <<window-management>>
      <<workspaces>>
      <<multihead>>
      <<x-applications>>
      <<desktop-environment>>
      <<de-keys>>
      <<init>>
      <<logout>>
      :hook (
             <<hooks>>
             )
      :bind (
             <<exwm-global-binds>>
             :map exwm-mode-map
             <<exwm-mode-binds>>
             )
      )
  #+end_src

** Window management
   :properties:
   :header-args: :noweb-ref window-management
   :end:
*** Put ~ivy~ menus in special frames

    This is meant to reduce how often X windows are resized. All menus are
    displayed in their own frames. It's still a little experimental, but it's
    working and that's what matters.

    #+begin_src emacs-lisp :noweb yes
      (use-package ivy-posframe
        :ensure t
        :defer t
        :init
        <<posframe-multihead>>
        (setq posframe-mouse-banish nil
              ivy-posframe-min-width 30
              ivy-posframe-border-width 3
              ivy-posframe-parameters '((left-fringe . 10)
                                        (right-fringe . 10)
                                        (parent-frame . nil))
              ivy-posframe-height-alist '((swiper . 15)
                                          (swiper-isearch . 15)
                                          (t . 11))
              ivy-posframe-display-functions-alist
              '((swiper . farl-ivy-posframe/exwm-display-window-center)
                (t . farl-ivy-posframe/exwm-display-frame-center)))
        <<force-position>>
        :hook (exwm-init . ivy-posframe-mode))
    #+end_src

    In order to make it work with multihead, additional functions are defined.

    #+begin_src emacs-lisp :noweb-ref posframe-multihead
      (defun farl-ivy-posframe/exwm-display-frame-center (str)
        "Display a posframe for `ivy-posframe' at frame center, passing STR."
        (ivy-posframe--display str
         (lambda (info)
           (let* ((monitor-info (elt exwm-workspace--workareas
                                     exwm-workspace-current-index))
                  (monitor-x (aref monitor-info 0))
                  (monitor-y (aref monitor-info 1))
                  (monitor-width (aref monitor-info 2))
                  (monitor-height (aref monitor-info 3))
                  (posframe-width (plist-get info :posframe-width))
                  (posframe-height (plist-get info :posframe-height))
                  (posframe-x (+ monitor-x (/ (- monitor-width posframe-width) 2)))
                  (posframe-y (+ monitor-y (/ (- monitor-height posframe-height) 2))))
             (cons posframe-x posframe-y)))))

      (defun farl-ivy-posframe/exwm-display-window-center (str)
        "Display a posframe for `ivy-posframe' at point, passing STR."
        (ivy-posframe--display str
         (lambda (info)
           (let* ((window-info (posframe-poshandler-window-center info))
                  (window-x (car window-info))
                  (window-y (cdr window-info))
                  (monitor-info (elt exwm-workspace--workareas
                                     exwm-workspace-current-index))
                  (monitor-x (aref monitor-info 0))
                  (monitor-y (aref monitor-info 1))
                  (posframe-x (+ window-x monitor-x))
                  (posframe-y (+ window-y monitor-y)))
             (cons posframe-x posframe-y)))))
    #+end_src

    In order for it not to jump around too much, =frame-position= is set on every
    time a posframe is displayed.

    #+begin_src emacs-lisp :noweb-ref force-position
      (defun farl-posframe/force-set-position (&rest args)
        "Force the position to be set for a posframe, ignoring ARGS."
        (setq posframe--last-posframe-pixel-position nil))

      (advice-add 'posframe--set-frame-position
                  :before #'farl-posframe/force-set-position)
    #+end_src

*** Name EXWM buffers after the window title

    This was annoying when I first installed EXWM. Thankfully it's easy to fix.

    #+begin_src emacs-lisp
      (defun farl-exwm/name-buffer-after-window-title ()
        "Rename the current `exwm-mode' buffer after the X window's title."
        (exwm-workspace-rename-buffer exwm-title))
    #+end_src

    We hook setting the buffer name into when EXWM picks up a change in the
    window title, aptly titled =exwm-update-title-hook=.

    #+begin_src emacs-lisp :noweb-ref hooks
      (exwm-update-title . farl-exwm/name-buffer-after-window-title)
    #+end_src

*** Configure floating window borders

    Uses the same color as my mode line, uses the same width as window dividers.

    #+begin_src emacs-lisp
      (setq exwm-floating-border-width window-divider-default-right-width
            exwm-floating-border-color (face-attribute 'mode-line :background))
    #+end_src

*** Getting a ~rofi~ equivalent

    Since I'm using Emacs as a window manager, I need something comparable to
    ~rofi~ so I can open X windows I haven't bound to keys. It will be bound
    elsewhere. I really don't want one named after +a project made by Nazis+ a
    Suckless project, but laziness makes that hard. At some point I will make my
    own function, preferably one considerably more minimalist.

    #+begin_src emacs-lisp
      (use-package dmenu
        :ensure t
        :defer t
        :init
        (setq dmenu-prompt-string "s-x "))
    #+end_src

** Workspace configuration
   :properties:
   :header-args: :noweb-ref workspaces
   :end:
*** Load all workspaces on startup

    I do not want to have to load all of them individually on my own...

    #+begin_src emacs-lisp
      (setq exwm-workspace-number 10)
    #+end_src

*** Assign workspaces to monitors

    This section is only to ensure the proper workspaces are placed on the right
    monitors when my W541 is docked.

    #+begin_src emacs-lisp
      (setq exwm-randr-workspace-monitor-plist '(0 "DP2-2"
                                                 1 "DP2-1"
                                                 2 "DP2-3"
                                                 3 "DP2-2"
                                                 4 "DP2-1"
                                                 5 "DP2-3"
                                                 6 "DP2-2"
                                                 7 "DP2-1"
                                                 8 "DP2-3"
                                                 9 "DP2-2"))
    #+end_src

*** Assign programs to workspaces

    ...and also have some launch floating and/or without a mode line or borders.

    #+begin_src emacs-lisp
      (setq exwm-manage-configurations '(((string= exwm-class-name "Steam")
                                          workspace 9)
                                         ((string= exwm-class-name "hl2_linux")
                                          floating-mode-line nil)
                                         ((string= exwm-class-name "TelegramDesktop")
                                          workspace 8)
                                         ((string= exwm-class-name "discord")
                                          workspace 7)
                                         ((or (string-match-p "libreoffice"
                                                              exwm-class-name)
                                              (string= exwm-class-name "MuseScore3")
                                              (string= exwm-class-name "Gimp"))
                                          workspace 6)
                                         ((string= exwm-title "Event Tester")
                                          floating-mode-line nil
                                          floating t)))
    #+end_src

*** Name workspaces a little more intuitively

    No clue why you have to do so much just to give workspaces names, but at
    least you can do it.

    #+begin_src emacs-lisp
      (defcustom farl-exwm/workspace-names '("Ôî•" "Ôî®" "Ôîß" "Ôî§" "Ôî£"
                                             "Ôî¶" "Ôñ¨" "Ôéí" "ÔãÜ" "ÔÜ∂")
        "The names assigned to workspaces through `exwm-workspace-index-map'."
        :tag "Workspace names"
        :group 'exwm
        :type 'list)

      (defun farl-exwm/workspace-index-map (index)
        "Return either a workspace name for a given INDEX or INDEX itself."
        (or (elt farl-exwm/workspace-names index) index))

      (setq exwm-workspace-index-map #'farl-exwm/workspace-index-map)
    #+end_src

*** Show a list of workspaces in the echo area

    Because I now use so many workspaces, I need to be able to see what
    workspace I am currently on. This makes it easier to do that. It's rather
    buggy at times, but it does what it needs to do.

    #+begin_src emacs-lisp :noweb yes
      (use-package minibuffer-line
        :ensure t
        :defer t
        :init
        (pdumper-require 'minibuffer-line)
        <<list-workspaces>>
        (set-face-attribute 'minibuffer-line nil :inherit 'default)
        (setq minibuffer-line-format '((:eval (farl-exwm/list-workspaces))))
        :hook ((exwm-init . minibuffer-line-mode)
               (exwm-workspace-switch . minibuffer-line--update)))
    #+end_src

    A function is used to grab the current state of the workspaces.

    #+begin_src emacs-lisp :noweb-ref list-workspaces
      (defun farl-exwm/list-workspaces ()
        "List EXWM workspaces."
        (exwm-workspace--update-switch-history)
        (elt exwm-workspace--switch-history
             (exwm-workspace--position exwm-workspace--current)))
    #+end_src

** Multi-head configuration
   :properties:
   :header-args: :noweb-ref multihead
   :end:

   Thankfully, EXWM comes with hooks to handle when monitors are connected and
   disconnected, so I can do monitor configuration entirely in Emacs Lisp. I
   have two laptops: a ThinkPad X230 and a ThinkPad W541. Each has different
   displays and is used for different purposes. Due to now not-so-recent updates
   to Arch Linux and the fact that the original code here was a dumpster fire,
   this section had to be reworked.

*** Getting the currently connected monitors

    The first thing to do is set up a function to return a list of currently
    connected monitors.

    #+begin_src emacs-lisp
      (defun get-connected-monitors ()
        "Return a list of the currently connected monitors."
        (split-string
         (shell-command-to-string
          "xrandr | grep ' connected ' | awk '{print $1}'")))
    #+end_src

*** Configuring monitor arrangement on my X230

    This one is straightforward. I never do any kind of split-monitor setup on
    my ThinkPad X230, so every monitor looks over the same screen.

    #+begin_src emacs-lisp
      (defun display-setup-x230 ()
        "Set up the connected monitors on a ThinkPad X230."
        (let ((monitors (get-connected-monitors))
              (possible '("LVDS1"
                          "VGA1")))
          (dolist (monitor possible)
            (if (member monitor monitors)
                (start-process "xrandr" nil "xrandr"
                               "--output" monitor
                               "--mode" "1366x768"
                               "--pos" "0x0")
              (start-process "xrandr" nil "xrandr"
                             "--output" monitor
                             "--off")))))
    #+end_src

*** Configuring monitor arrangement on my W541

    This is where it gets really fun. This ThinkPad /does/ get docked, so I handle
    very different outputs.

    #+begin_src emacs-lisp
      (defun display-setup-w541 ()
        "Set up the connected monitors on a ThinkPad W541."
        (let* ((connected-monitors (get-connected-monitors))
               (docked-p (member "DP2-1" connected-monitors))
               (possible-monitors '("eDP1"
                                    "VGA1"
                                    "DP2-1"
                                    "DP2-2"
                                    "DP2-3")))
          (dolist (monitor possible-monitors)
            (if (and (member monitor connected-monitors)
                     (not (and docked-p (string= "eDP1" monitor))))
                (progn
                  (start-process "xrandr" nil "xrandr"
                                 "--output" monitor
                                 ;; Any enabled monitor needs a resolution.
                                 "--mode" "1920x1080"
                                 ;; DP2-1 and DP2-3 are rotated.
                                 "--rotate" (if (string= "DP2-1" monitor)
                                                "left"
                                              (if (string= "DP2-3" monitor)
                                                  "right"
                                                "normal"))
                                 ;; Every enabled monitor needs a position.
                                 "--pos" (if (string-match-p "1" monitor)
                                             "0x0"
                                           (if (string= monitor "DP2-2")
                                               "1080x0"
                                             "3000x0")))
                  ;; Setting a monitor as primary occurs outside enabling it.
                  ;; This is due to how `start-process' takes arguments.
                  (when (or (string= "DP2-2" monitor)
                            (string= "eDP1" monitor))
                    (start-process "xrandr" nil "xrandr"
                                   "--output" monitor
                                   "--primary")))
              (start-process "xrandr" nil "xrandr"
                             "--output" monitor
                             "--off")))))
    #+end_src

*** Configuring peripherals while docked

    Because I use a dock on my W541, there are some things I need to do
    alongside setting up my monitors.

    #+begin_src emacs-lisp
      (defun peripheral-setup ()
        "Configure peripherals I connect to my dock."
        ;; Trackball
        (let ((trackball-id (shell-command-to-string
                             (concat "xinput | grep ELECOM | head -n 1 | sed -r "
                                     "'s/.*id=([0-9]+).*/\\1/' | tr '\\n' ' '"))))
          (start-process-shell-command
           "Trackball Setup" nil (concat "xinput set-prop " trackball-id
                                         "'libinput Button Scrolling Button' 10"))
          (start-process-shell-command
           "Trackball Setup" nil (concat "xinput set-prop " trackball-id
                                         "'libinput Scroll Method Enabled' 0 0 1"))
          (start-process-shell-command
           "Trackball Setup" nil (concat "xinput set-button-map " trackball-id
                                         "1 2 3 4 5 6 7 8 9 2 1 2")))
        ;; Keyboard
        (start-process "Keyboard Setup" nil "setxkbmap"
                       "-option" "ctrl:nocaps"))
    #+end_src

*** Bringing it all together

    Finally, I can make my generic display-and-dock setup function.

    #+begin_src emacs-lisp
      (defun display-and-dock-setup ()
        "Configure displays and dock if applicable."
        (interactive)
        (unless (get-process "Monitor Settings")
          (if (member "LVDS1" (get-connected-monitors))
              (display-setup-x230)
            (progn
              (display-setup-w541)
              (peripheral-setup)))))
    #+end_src

    Every time EXWM detects a change in the monitors connected or active, this
    function should be called, so it's hooked to =exwm-randr-screen-change-hook=.

    #+begin_src emacs-lisp :noweb-ref hooks
      (exwm-randr-screen-change . display-and-dock-setup)
    #+end_src

** X applications
   :properties:
   :header-args: :noweb-ref x-applications
   :end:
*** GIMP

    Until GIMP's functionality gets merged into Emacs, guess I'm stuck with it.

    #+begin_src emacs-lisp
      (defun run-gimp ()
        "Start GIMP."
        (interactive)
        (start-process "GIMP" nil "gimp"))
    #+end_src

*** Steam

    Gaming is possible with EXWM, if you run games windowed. I used to run it
    floating, but honestly just having it tile is so much easier to manage.

    #+begin_src emacs-lisp
      (defun run-steam ()
        "Start Steam."
        (interactive)
        (start-process "Steam" nil "steam"))
    #+end_src

*** Firefox

    Firefox has some unique abilities when it comes to how to make windows
    behave which work better for me. I don't use tabs, and I don't want
    anything to do with them, and Firefox lets me hide the tab bar and force all
    tabs to actually open as new windows. It's like Suckless Surf, but orders of
    magnitude better.

    #+begin_src emacs-lisp
      (defun run-firefox ()
        "Start Firefox."
        (interactive)
        (start-process "Firefox" nil "firefox"))
    #+end_src

*** Discord

    It's kinda trashy but my friends use it.

    #+begin_src emacs-lisp
      (defun run-discord ()
        "Start Discord."
        (interactive)
        (start-process "Discord" nil "discord"))
    #+end_src

*** Telegram

    Another trashy messenger my friends use.

    #+begin_src emacs-lisp
      (defun run-telegram ()
        "Start Telegram."
        (interactive)
        (start-process "Telegram" nil "telegram-desktop"))
    #+end_src

*** MuseScore

    I haven't figured out how to engrave in Emacs, so for now...

    #+begin_src emacs-lisp
      (defun run-musescore ()
        "Start MuseScore."
        (interactive)
        (start-process "MuseScore" nil "musescore"))
    #+end_src

*** LibreOffice

    Shame me all you want.

    #+begin_src emacs-lisp
      (defun run-libreoffice ()
        "Start LibreOffice."
        (interactive)
        (start-process "LibreOffice" nil "libreoffice"))
    #+end_src

*** Transmission

    #+begin_src emacs-lisp
      (defun run-transmission ()
        "Start Transmission."
        (interactive)
        (start-process "Transmission" nil "transmission-gtk"))
    #+end_src

** DE components
   :properties:
   :header-args: :noweb-ref desktop-environment
   :end:
*** System package management

    This one is a pleasant surprise to have honestly. Having Emacs handle system
    packages as well as its own makes life a million times easier. Since I use
    ~yay~ on Arch, I configure an entry for it and use it if it's installed.

    #+begin_src emacs-lisp
      (use-package system-packages
        :ensure t
        :defer t
        :init
        (when (executable-find "yay")
          (pdumper-require 'system-packages)
          (add-to-list 'system-packages-supported-package-managers
                       '(yay .
                             ((default-sudo . nil)
                              (install . "yay -S")
                              (search . "yay -Ss")
                              (uninstall . "yay -Rs")
                              (update . "yay -Syu")
                              (clean-cache . "yay -Sc")
                              (log . "car /var/log/pacman.log")
                              (get-info . "yay -Qi")
                              (get-info-remote . "yay -Si")
                              (list-files-provided-by . "yay -Ql")
                              (verify-all-packages . "yay -Qkk")
                              (verify-all-dependencies . "yay -Dk")
                              (remove-orphaned . "yay -Rns $(yay -Qtdq)")
                              (list-installed-packages . "yay -Qe")
                              (list-installed-packages-all . "yay -Q")
                              (list-dependencies-of . "yay -Qi")
                              (noconfirm . "--noconfirm"))))
          (setq system-packages-use-sudo nil
                system-packages-package-manager 'yay))
        (setq system-packages-noconfirm t)
        :bind (("C-c p i" . system-packages-install)
               ("C-c p e" . system-packages-ensure)
               ("C-c p u" . system-packages-update)
               ("C-c p r" . system-packages-uninstall)
               ("C-c p o" . system-packages-remove-orphaned)
               ("C-c p c" . system-packages-clean-cache)
               ("C-c p l" . system-packages-log)
               ("C-c p s" . system-packages-search)
               ("C-c p g" . system-packages-get-info)
               ("C-c p d" . system-packages-list-dependencies-of)
               ("C-c p f" . system-packages-list-files-provided-by)
               ("C-c p p" . system-packages-list-installed-packages)
               ("C-c p f" . system-packages-verify-all-dependencies)
               ("C-c p v" . system-packages-verify-all-packages)))
    #+end_src

*** ~desktop-environment-mode~

    Previously I had to define a lot of functions to do these things, now I just
    change settings within ~desktop-environment-mode~.

    #+begin_src emacs-lisp :noweb yes
      (use-package desktop-environment
        :ensure t
        :defer t
        :init
        (pdumper-require 'desktop-environment)
        (setq desktop-environment-update-exwm-global-keys :prefix)
        <<brightness-adjustment>>
        <<volume-adjustment>>
        <<lock-screen>>
        <<screenshots>>
        :hook (exwm-init . desktop-environment-mode)
        :bind (:map desktop-environment-mode-map
               <<de-binds>>
               )
        )
    #+end_src

**** Brightness adjustment

     This one is the simplest: all I needed to do was change the increment and
     decrement values.

     #+begin_src emacs-lisp :noweb-ref brightness-adjustment
       (setq desktop-environment-brightness-normal-increment "5%+"
             desktop-environment-brightness-normal-decrement "5%-")
     #+end_src

**** Volume adjustment

     The only things I really don't like about how ~desktop-environment~'s volume
     controlling is ~desktop-environment-toggle-mute~, which gives way too much
     output when you mute or unmute the speakers or microphone, so I set up
     basic scripts to give much more concise output.

     #+begin_src emacs-lisp :noweb-ref volume-adjustment
       (setq desktop-environment-volume-toggle-command
             (concat "[ \"$(amixer set Master toggle | grep off)\" ] "
                     "&& echo Volume is now muted. | tr '\n' ' ' "
                     "|| echo Volume is now unmuted. | tr '\n' ' '")
             desktop-environment-volume-toggle-microphone-command
             (concat "[ \"$(amixer set Capture toggle | grep off)\" ] "
                     "&& echo Microphone is now muted. | tr '\n' ' ' "
                     "|| echo Microphone is now unmuted | tr '\n' ' '"))
     #+end_src

**** Lock screen

     Haha yes, this is very long and very very stupid.

     #+begin_src emacs-lisp :noweb-ref lock-screen
       (setq desktop-environment-screenlock-command
             (concat
              "i3lock -nmk --color=000000 --timecolor=ffffffff "
              " --datecolor=ffffffff --wrongcolor=ffffffff "
              "--ringcolor=00000000 --insidecolor=00000000 "
              "--keyhlcolor=00000000 --bshlcolor=00000000 "
              "--separatorcolor=00000000 --ringvercolor=00000000 "
              "--insidevercolor=00000000 --linecolor=00000000 "
              "--ringwrongcolor=00000000 --insidewrongcolor=00000000 "
              "--timestr=%H:%M --datestr='%a %d %b' --time-font=Iosevka "
              "--date-font=Iosevka --wrong-font=Iosevka --timesize=128 "
              "--datesize=64 --wrongsize=32 --time-align 0 --date-align 0 "
              "--wrong-align 0 --indpos=-10:-10 --timepos=200:125 "
              "--datepos=200:215 --wrongpos=200:155 --locktext='' "
              "--lockfailedtext='' --noinputtext='' --veriftext='' "
              "--wrongtext='WRONG' --force-clock --radius 1 --ring-width 1 "))
     #+end_src

     I also have to bind an extra key for this function.

     #+begin_src emacs-lisp :noweb-ref de-binds
       ("<XF86ScreenSaver>" . desktop-environment-lock-screen)
     #+end_src

**** Screenshots
     :properties:
     :header-args: :noweb-ref screenshots
     :end:

     This one was the least straightforward because the way it's implemented by
     ~desktop-environment~ is *SUPER* wonky. Here are the binds:

     #+begin_src emacs-lisp :noweb-ref de-binds
       ("<print>" . farl-de/desktop-environment-screenshot-part-clip)
       ("<S-print>" . farl-de/desktop-environment-screenshot-clip)
       ("<C-print>" . farl-de/desktop-environment-screenshot-part)
       ("<C-S-print>" . farl-de/desktop-environment-screenshot)
     #+end_src

     First, I set what directory to store screenshots in.

     #+begin_src emacs-lisp
       (setq desktop-environment-screenshot-directory "~/screenshots")
     #+end_src

     Then, I can set the commands for taking a full or partial screenshot and
     saving it to a file.

     #+begin_src emacs-lisp
       (setq desktop-environment-screenshot-command
             "FILENAME=$(date +'%Y-%m-%d-%H:%M:%S').png && maim $FILENAME"
             desktop-environment-screenshot-partial-command
             "FILENAME=$(date +'%Y-%m-%d-%H:%M:%S').png && maim -s $FILENAME")
     #+end_src

     The functions which ~desktop-environment~ comes with are kinda garbage, so I
     made my own to replace them.

     #+begin_src emacs-lisp
       (defun farl-de/desktop-environment-screenshot ()
         "Take a screenshot and store it in a file."
         (interactive)
         (desktop-environment-screenshot)
         (message "Screenshot saved in ~/screenshots."))

       (defun farl-de/desktop-environment-screenshot-part ()
         "Take a capture of a portion of the screen and store it in a file."
         (interactive)
         (desktop-environment-screenshot-part)
         (message "Screenshot saved in ~/screenshots."))

       (defun farl-de/desktop-environment-screenshot-clip ()
         "Take a screenshot and put it in the clipboard."
         (interactive)
         (shell-command
          (concat desktop-environment-screenshot-command
                  " && xclip $FILENAME -selection clipboard "
                  "-t image/png &> /dev/null && rm $FILENAME"))
         (message "Screenshot copied to clipboard."))

       (defun farl-de/desktop-environment-screenshot-part-clip ()
         "Take a shot of a portion of the screen and put it in the clipboard."
         (interactive)
         (shell-command
          (concat desktop-environment-screenshot-partial-command
                  " && xclip $FILENAME -selection clipboard "
                  "-t image/png &> /dev/null && rm $FILENAME"))
         (message "Screenshot copied to clipboard."))
     #+end_src

*** Setting the wallpaper

    I've been working on [[https://github.com/farlado/emacs-wallpaper][an easy way to configure wallpapers]] which makes for way
    less hassle. It only relies on ~feh~ as a backend for applying wallpapers, so
    if you use Emacs as a daemon it can manage your wallpapers even if it isn't
    the window manager.

    #+begin_src emacs-lisp
      (use-package wallpaper
        :load-path "lisp/wallpaper"
        :defer t
        :hook ((exwm-randr-screen-change . wallpaper-set-wallpaper)
               (exwm-init . wallpaper-cycle-mode)))
    #+end_src

*** Monitor settings

    Calling ~arandr~ to adjust monitors is useful when I am preparing to present
    something using my computer or need to adjust how monitors are set up in a
    unique way that isn't a preset from my dotfiles.

    #+begin_src emacs-lisp
      (defun monitor-settings ()
        "Open arandr to configure monitors."
        (interactive)
        (start-process "Monitor Settings" nil "arandr"))
    #+end_src

*** Network settings

    This one uses two windows: one to open the NetworkManager connection editor,
    and another to list WiFi networks nearby.

    #+begin_src emacs-lisp
      (defun network-settings ()
        "Open a NetworkManager connection editor."
        (interactive)
        (start-process "Network Settings" nil "nm-connection-editor")
        (async-shell-command "nmcli dev wifi list" "*Wi-Fi Networks*"))
    #+end_src

*** Volume mixer

    For when you need to do volume mixing.

    #+begin_src emacs-lisp
      (defun volume-settings ()
        "Open pavucontrol to adjust volume."
        (interactive)
        (start-process "Volume Mixer" nil "pavucontrol"))
    #+end_src

*** Audio loop-back

    Used when I play Jackbox Party Pack with friends. Also set up to launch
    ~pavucontrol~ to set up which programs to pass through to Discord.

    #+begin_src emacs-lisp
      (defun audio-loopback ()
        "Loop desktop audio into a null sink alongside the primary input."
        (interactive)
        (dolist (command '(;; Create null sink `loop'
                           "load-module module-null-sink sink_name=loop"
                           "update-sink-proplist loop device.description=loop"
                           ;; Create null sink `out'
                           "load-module module-null-sink sink_name=out"
                           "update-sink-proplist out device.description=out"
                           ;; Loop `loop' to primary output
                           "load-module module-loopback source=loop.monitor"
                           ;; Pipe it into `out'
                           "load-module module-loopback source=loop.monitor sink=out"
                           ;; Loop primary input into `out'
                           "load-module module-loopback sink=out"))
          (shell-command (concat "pacmd " command)))
        ;; Run `pavucontrol' and then unload the modules after it completes
        (start-process-shell-command
         "Audio Loop" nil (concat "pavucontrol;"
                                  "pacmd unload-module module-null-sink;"
                                  "pacmd unload-module module-loopback")))
    #+end_src

*** Keyboard layout selection

    It's [[https://github.com/farlado/emacs-xkb][its own package]] now. Check it out, I think it's pretty nice.

    #+begin_src emacs-lisp
      (use-package xkb
        :load-path "lisp/xkb"
        :defer t
        :init
        (setq xkb-cycle-layouts '("us"
                                  "epo"
                                  "de")
              xkb-options '("ctrl:nocaps"))
        :hook (exwm-init . xkb-cycle-mode))
    #+end_src

*** Shutting down

    #+begin_src emacs-lisp
      (defun shut-down--computer ()
        "Shut down the computer."
        (shell-command "shutdown now"))

      (defun shut-down-computer ()
        "Shut down the computer."
        (interactive)
        (add-hook 'kill-emacs-hook #'shut-down--computer)
        (save-buffers-kill-emacs)
        (remove-hook 'kill-emacs-hook #'shut-down--computer))
    #+end_src

    This function is globally bound to =C-x C-M-c=.

    #+begin_src emacs-lisp :noweb-ref exwm-global-binds
      ("C-x C-M-c" . shut-down-computer)
    #+end_src

*** Rebooting

    #+begin_src emacs-lisp
      (defun reboot--computer ()
        "Run the reboot command."
        (shell-command "reboot"))

      (defun reboot-computer ()
        "Reboot the computer."
        (interactive)
        (add-hook 'kill-emacs-hook #'reboot--computer)
        (save-buffers-kill-emacs)
        (remove-hook 'kill-emacs-hook #'reboot--computer))
    #+end_src

    This function is globally bound to =C-x C-M-r=.

    #+begin_src emacs-lisp :noweb-ref exwm-global-binds
      ("C-x C-M-r" . reboot-computer)
    #+end_src

*** Suspending

    #+begin_src emacs-lisp
      (defun suspend-computer ()
        (interactive)
        (when (yes-or-no-p "Really suspend? ")
          (shell-command "systemctl suspend -i")))
    #+end_src

    This function is globally bound to =C-x C-M-s=.

    #+begin_src emacs-lisp :noweb-ref exwm-global-binds
      ("C-x C-M-s" . suspend-computer)
    #+end_src

** Keybindings
   :properties:
   :header-args: :noweb-ref de-keys
   :end:
*** Global binds to use across everything

    Since I'm very lazy and don't feel like writing a whole bunch of lambdas for
    multiple workspaces, presented here are instead some ~mapcar~ calls, like the
    one in [[https://github.com/ch11ng/exwm/wiki/Configuration-Example][this example]].

    #+begin_src emacs-lisp
      (setq exwm-input-global-keys `(;; Switching workspace focus
                                     ;; s-1 for 1, s-2 for 2, etc...
                                     ,@(mapcar
                                        (lambda (i)
                                          `(,(kbd (format "s-%d" (% (1+ i) 10))) .
                                            (lambda ()
                                              (interactive)
                                              (exwm-workspace-switch-create ,i))))
                                        (number-sequence 0 9))

                                     ;; Switching window to a workspace
                                     ;; This was annoying to get working
                                     ;; s-! for 1, s-@ for 2, etc...
                                     ,@(mapcar
                                        (lambda (i)
                                          `(,(kbd (format "s-%s" (nth i '("!" "@"
                                                                          "#" "$"
                                                                          "%" "^"
                                                                          "&" "*"
                                                                          "(" ")")))) .
                                            (lambda ()
                                              (interactive)
                                              (exwm-workspace-move-window ,i))))
                                        (number-sequence 0 9))

                                     ;; Toggle how input is sent to X windows
                                     ([?\s-q] . exwm-input-toggle-keyboard)

                                     ;; Window size adjustment
                                     (,(kbd "C-s-w") . shrink-window)
                                     (,(kbd "C-s-s") . enlarge-window)
                                     (,(kbd "C-s-a") . shrink-window-horizontally)
                                     (,(kbd "C-s-d") . enlarge-window-horizontally)

                                     ;; Opening programs
                                     ([XF86Calculator] . calc)
                                     ([s-return]       . vterm)
                                     ([?\s-g]          . run-gimp)
                                     ([?\s-s]          . run-steam)
                                     ([?\s-f]          . run-firefox)
                                     ([?\s-d]          . run-discord)
                                     ([?\s-t]          . run-telegram)
                                     ([?\s-m]          . run-musescore)
                                     ([?\s-b]          . run-libreoffice)
                                     ([?\s-o]          . run-transmission)
                                     ([?\s-r]          . monitor-settings)
                                     ([?\s-n]          . network-settings)
                                     ([?\s-v]          . volume-settings)

                                     ;; Other desktop environment things
                                     ([?\s-x]           . dmenu)
                                     ([s-tab]           . audio-loopback)
                                     ([?\s-w]           . xkb-set-layout)

                                     ;; Controlling EMMS
                                     ([XF86AudioNext] . emms-next)
                                     ([XF86AudioPrev] . emms-previous)
                                     ([XF86AudioPlay] . emms-pause)
                                     ([XF86AudioStop] . emms-stop)))
    #+end_src

*** Emacs key bindings in X windows

    This is super nice, because I love these key bindings and they are just
    intuitive to me, and now they can carry over safely to other programs.

    #+begin_src emacs-lisp
      (setq exwm-input-simulation-keys `(;; Navigation
                                         ([?\M-<] . [C-home])
                                         ([?\M->] . [C-end])
                                         ([?\C-a] . [home])
                                         ([?\C-e] . [end])
                                         ([?\C-v] . [next])
                                         ([?\M-v] . [prior])

                                         ([?\C-b] . [left])
                                         ([?\C-f] . [right])
                                         ([?\C-p] . [up])
                                         ([?\C-n] . [down])

                                         ([?\M-b] . [C-left])
                                         ([?\M-f] . [C-right])
                                         ([?\M-n] . [C-down])
                                         ([?\M-p] . [C-up])

                                         ;; Selecting via navigation
                                         (,(kbd "C-S-b") . [S-left])
                                         (,(kbd "C-S-f") . [S-right])
                                         (,(kbd "C-S-n") . [S-down])
                                         (,(kbd "C-S-p") . [S-up])

                                         ;; Copy/Paste
                                         ([?\C-w] . [?\C-x])
                                         ([?\M-w] . [?\C-c])
                                         ([?\C-y] . [?\C-v])
                                         ([?\C-s] . [?\C-f])
                                         ([?\C-\/] . [?\C-z])

                                         ;; Other
                                         ([?\C-d] . [delete])
                                         ([?\M-d] . [C-delete])
                                         ([?\C-k] . [S-end delete])
                                         ([?\C-g] . [escape])))
    #+end_src

    Key sequences cannot be defined in =exwm-input-simulation-keys=, so they are
    functions which are called.

    #+begin_src emacs-lisp
      (defun farl-exwm/C-s ()
        "Pass C-s to the EXWM window."
        (interactive)
        (execute-kbd-macro (kbd "C-q C-s")))

      (defun farl-exwm/C-k ()
        "Pass C-k to the EXWM window."
        (interactive)
        (execute-kbd-macro (kbd "C-q C-k")))
    #+end_src

    These functions are bound to keys in =exwm-mode-map=.

    #+begin_src emacs-lisp :noweb-ref exwm-mode-binds
      ("C-x C-s" . farl-exwm/C-s)
      ("C-c C-l" . farl-exwm/C-k)
    #+end_src

*** Send a key verbatim more easily

    This means there's one less key needed to send a verbatim key to an EXWM
    buffer. It is obviously bound in =exwm-mode-map=.

    #+begin_src emacs-lisp :noweb-ref exwm-mode-binds
      ("C-q" . exwm-input-send-next-key)
      ("C-c C-q" . nil)
    #+end_src

*** Inhibit keys I don't use

    This removes the following from =exwm-mode-map=:
    - Toggling fullscreen
    - Toggling floating
    - Toggling hiding
    - Toggling the mode line

    #+begin_src emacs-lisp :noweb-ref exwm-mode-binds
      ("C-c C-f" . nil)
      ("C-c C-t C-f" . nil)
      ("C-c C-t C-v" . nil)
      ("C-c C-t C-m" . nil)
    #+end_src

** On startup
   :properties:
   :header-args: :noweb-ref init
   :end:
*** Make Emacs start fullscreen

    This makes setting the wallpaper and everything look a heck of a lot more
    natural, e.g. Emacs filling the screen looks a heck of a lot less jarring
    before the wallpaper sets than after.

    #+begin_src emacs-lisp
      (set-frame-parameter nil 'fullscreen 'fullboth)
    #+end_src

*** XDG compliance and WM settings

    I have to set a few environment variables for the sake of compliance with
    various XDG specifications, most notably the XDG Base Directory
    specification. Also in this block I set an environment variable signaling to
    Java applications that the window manager is not a reparenting window manager.

    #+begin_src emacs-lisp :tangle no
      (setenv "XDG_CURRENT_DESKTOP" "emacs")
      (setenv "GTK2_RC_FILES" (user-config-file "gtk-2.0/gtkrc"))
      (setenv "QT_QPA_PLATFORMTHEME" "gtk2")
      (setenv "_JAVA_AWT_WM_NONREPARENTING" "1")
    #+end_src

*** Disable screen blanking

    I don't need my laptop's screen shutting off just because I'm sitting and
    watching a video with the laptop idle too long.

    #+begin_src emacs-lisp :tangle no
      (start-process "Disable Blanking" nil "xset"
                     "s" "off" "-dpms")
    #+end_src

*** Disable the trackpad

    This thing is disgusting, and I prefer trackpoints way more.

    #+begin_src emacs-lisp :tangle no
      (start-process "Trackpad Setup" nil "xinput"
                     "disable" (shell-command-to-string
                                (concat "xinput | grep Synap | head -n 1 | "
                                        "sed -r 's/.*id=([0-9]+).*/\\1/' | "
                                        "tr '\n' ' ' | sed 's/ //'")))
    #+end_src

*** Keyboard configuration

    This block sets the keyboard layout to US and give Caps Lock the
    functionality of Control. I was hesitant to do this at first, but it's
    significantly more comfortable. I almost never used caps lock as it is,
    given my keyboards have no indicator for it on my laptops, but this gives me
    a much easier way to do commands without shifting my hand too far. Ideally,
    however, I configure my keyboards so that this setting is nothing more than
    an afterthought.

    #+begin_src emacs-lisp :tangle no
      (start-process "Keyboard Layout" nil "setxkbmap"
                     "us" "-option" "ctrl:nocaps")
    #+end_src

*** Start the compositor

    I don't need it, but having basic compositing is very nice.

    #+begin_src emacs-lisp :tangle no
      (start-process "Compositor" nil "xcompmgr")
    #+end_src

*** Set fallback cursor

    Some X windows will have weird cursors if this isn't done.

    #+begin_src emacs-lisp :tangle no
      (start-process "Fallback Cursor" nil "xsetroot"
                     "-cursor_name" "left_ptr")
    #+end_src

*** Start EXWM

    #+begin_src emacs-lisp :tangle no
      (exwm-enable)
      (exwm-config-ido)
      (exwm-randr-enable)
      (exwm-systemtray-enable)
    #+end_src

** On logout
   :properties:
   :header-args: :noweb-ref on-logout
   :end:

   When exiting, these are things I want done.

   #+begin_src emacs-lisp :noweb yes :noweb-ref logout
     (defun farl-exwm/on-logout ()
       "Run this when logging out as part of `kill-emacs-hook'."
       <<on-logout>>)
   #+end_src

   This is hooked into when Emacs is killed.

   #+begin_src emacs-lisp :noweb-ref hooks
     (kill-emacs . farl-exwm/on-logout)
   #+end_src

*** Black out the root window

    This way, it looks good when exiting Emacs.

    #+begin_src emacs-lisp
      (shell-command "hsetroot -solid '#000000'")
    #+end_src

* Making Emacs an ~mpd~-based music player

  I am big on doing as much in Emacs as possible. Having my music player moved
  to Emacs was a HUGE step. When I first started using it, it was weird, but now
  I have come to absolutely love it. We only configure EMMS if ~mpd~ is found.
  Environment variables are set here as well.

  #+begin_src emacs-lisp :noweb yes :tangle (user-emacs-file "init.el")
    (use-package emms
      :if (executable-find "mpd")
      :ensure t
      :defer t
      :init
      <<emms-load>>
      <<emms-conf>>
      <<emms-func>>
      <<emms-keys>>)
  #+end_src

** Loading

   This loads the necessary files to ensure ~emms~ starts properly.

   #+begin_src emacs-lisp :noweb-ref emms-load
     (pdumper-require 'emms-setup)
     (require 'emms-player-mpd)
     (emms-all)
   #+end_src

** Functions
  :properties:
  :header-args: :noweb-ref emms-func
  :end:
*** Starting the daemon
    
    #+begin_src emacs-lisp
      (defun mpd/start-music-daemon ()
        "Start MPD, connect to it and sync the metadata cache"
        (interactive)
        (shell-command "mpd")
        (mpd/update-database)
        (emms-player-mpd-connect)
        (emms-cache-set-from-mpd-all)
        (message "MPD started!"))
    #+end_src

*** Stopping the daemon

    #+begin_src emacs-lisp
      (defun mpd/kill-music-daemon ()
        "Stop playback and kill the music daemon."
        (interactive)
        (emms-stop)
        (call-process "killall" nil nil nil "mpd")
        (message "MPD killed!"))
    #+end_src

*** Updating the database

    #+begin_src emacs-lisp
      (defun mpd/update-database ()
        "Update the MPD database synchronously."
        (interactive)
        (call-process "mpc" nil nil nil "update")
        (message "MPD database updated!"))
    #+end_src

*** Shuffling the playlist

    #+begin_src emacs-lisp
      (defun farl-emms/shuffle-with-message ()
        "Shuffle the playlist and say so in the echo area."
        (interactive)
        (emms-shuffle)
        (message "Playlist has been shuffled."))
    #+end_src

** Keybindings
   :properties:
   :header-args: :noweb-ref emms-keys
   :end:
  
   Now using a keymap in place of that wonky as crap binding system. The new
   binds let me use ~emms~ in a terminal.

   #+begin_src emacs-lisp
     (defvar emms-map
       (let ((map (make-sparse-keymap)))
         ;; Opening playlist and music browser
         (define-key map (kbd "v") #'emms)
         (define-key map (kbd "b") #'emms-smart-browse)
         ;; Track navigation
         (define-key map (kbd "n n") #'emms-next)
         (define-key map (kbd "n p") #'emms-previous)
         (define-key map (kbd "p")   #'emms-pause)
         (define-key map (kbd "s")   #'emms-stop)
         ;; Repeat/shuffle
         (define-key map (kbd "t C-r") #'emms-toggle-repeat-track)
         (define-key map (kbd "t r")   #'emms-toggle-repeat-playlist)
         (define-key map (kbd "t s")   #'farl-emms/shuffle-with-message)
         ;; Refreshing various things
         (define-key map (kbd "r c") #'emms-player-mpd-update-all-reset-cache)
         (define-key map (kbd "r d") #'mpd/update-database)
         ;; mpd-specific functions
         (define-key map (kbd "d s") #'mpd/start-music-daemon)
         (define-key map (kbd "d q") #'mpd/kill-music-daemon)
         (define-key map (kbd "d u") #'mpd/update-database)
         map)
       "A keymap for controlling `emms'.")
     (global-set-key (kbd "C-c a") emms-map)
   #+end_src

** Configuring

   This is where ~emms~ is configured to use ~mpd~, and some environment variables
   are set to ensure ~mpd~ is usable.

   #+begin_src emacs-lisp :noweb-ref emms-conf
     (setq emms-seek-seconds 5
           emms-player-list '(emms-player-mpd)
           emms-info-functions '(emms-info mpd)
           emms-player-mpd-server-name "localhost"
           emms-player-mpd-server-port "6601"
           mpc-host "localhost:6601")
     (setenv "MPD_HOST" "localhost")
     (setenv "MPD_PORT" "6601")
   #+end_src

* Giving files their footers

  Since we gave files their headers, I see no reason not to give them footers.

*** =early-init.el=

    #+begin_src emacs-lisp :tangle (user-emacs-file "early-init.el")
      ;;; early-init.el ends here
    #+end_src

*** =init.el=

    #+begin_src emacs-lisp :tangle (user-emacs-file "init.el")
      ;;; init.el ends here
    #+end_src

*** =pdumper.el=

    #+begin_src emacs-lisp :tangle (user-emacs-file "lisp/pdumper.el")
      ;;; pdumper.el ends here
    #+end_src

