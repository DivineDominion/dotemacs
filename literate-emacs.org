#+title: Farlado's Illiterate GNU Emacs üêâ
#+subtitle: A far-from-sane literate GNU Emacs configuration
#+author: Farlado
#+language: en
#+startup: hideblocks
#+options: num:nil toc:2
#+property: header-args :results none
#+html: <p align="center"><img src="logo.png" /></p>

#+begin_quote
Personally, I feel inspired whenever I open Emacs. Like a craftsman entering his
workshop, I feel a realm of possibility open before me. I feel the comfort of an
environment that has evolved over time to fit me perfectly -- an assortment of
packages and keybindings which help me bring ideas to life day after day.
-- [[https://www.braveclojure.com/basic-emacs/][Daniel Higginbotham]]
#+end_quote

* Table of Contents :toc:quote:
#+BEGIN_QUOTE
- [[#about-this-configuration][About this configuration]]
  - [[#okay-thats-pretty-neat-why-though][Okay, that's pretty neat. Why though?]]
  - [[#installation][Installation]]
  - [[#dependencies][Dependencies]]
  - [[#license][License]]
- [[#making-emacs-start-quickly][Making Emacs start quickly]]
  - [[#starting-emacs-fast][Starting Emacs FAST]]
  - [[#do-these-things-asap][Do these things ASAP]]
  - [[#early-package-management][Early package management]]
  - [[#later-package-management][Later package management]]
  - [[#final-considerations][Final considerations]]
- [[#making-emacs-much-less-ugly][Making Emacs much less ugly]]
  - [[#font][Font]]
  - [[#theme][Theme]]
  - [[#mode-line][Mode line]]
  - [[#in-buffers][In buffers]]
  - [[#start-screen][Start screen]]
- [[#making-emacs-more-comfortable][Making Emacs more comfortable]]
  - [[#general-functionality][General functionality]]
  - [[#completion-helpers][Completion helpers]]
  - [[#functionsmacros][Functions/macros]]
  - [[#bufferswindows][Buffers/windows]]
  - [[#key-binds][Key binds]]
- [[#making-emacs-a-good-text-editor][Making Emacs a good text editor]]
  - [[#additional-major-modes][Additional major modes]]
  - [[#personal-save-hooks][Personal save hooks]]
  - [[#general-editing][General editing]]
  - [[#programming][Programming]]
  - [[#org-mode][Org-mode]]
- [[#making-emacs-more-than-an-editor][Making Emacs more than an editor]]
  - [[#not-built-in][Not built-in]]
  - [[#built-in][Built-in]]
  - [[#games][Games]]
- [[#making-emacs-manageplay-my-music][Making Emacs manage/play my music]]
  - [[#loading][Loading]]
  - [[#functions][Functions]]
  - [[#keybindings][Keybindings]]
  - [[#configuring][Configuring]]
- [[#making-emacs-a-desktop-environment][Making Emacs a desktop environment]]
  - [[#window-management][Window management]]
  - [[#workspace-configuration][Workspace configuration]]
  - [[#multi-head-configuration][Multi-head configuration]]
  - [[#x-applications][X applications]]
  - [[#de-components][DE components]]
  - [[#keybindings-1][Keybindings]]
  - [[#on-startup][On startup]]
  - [[#on-logout][On logout]]
#+END_QUOTE

* About this configuration

  This file is an attempt at a literate GNU Emacs (henceforth "Emacs")
  configuration.

  Literate programming is a method in which programming is worked on in parallel
  with the development of documentation specifically pertaining to how said
  program was written, alongside how to use the program at times. The end result
  is a file that can be /tangled/ into source code and /weaved/ into documentation.
  The benefits of this practice are far easier maintenance of a rapidly growing
  project, and far greater control in the flow of when code is introduced in
  documentation and where it is included in resultant source code.

  This configuration is /incredibly/ opinionated, and it is very likely that most 
  changes will not be friendly towards the typical Emacs user. Hopefully this
  file will contain enough commentary for you to understand everything within
  it. Regardless, the idea is that this file, when tangled, generates my entire
  configuration. I would /highly/ recommend you *NOT* try to read the =.el= files on
  their own. It's a jungle, especially since all of the commentary regarding the
  configuration is in this file and this file alone.

** Okay, that's pretty neat. Why though?

   The answer is rather simple. Before I used a fully literate file, I had an
   =init.el= which tangled blocks from a =config.org= on the fly (read: on startup).
   It turns out this was abysmally slow, making for a startup time of around 4.5
   seconds when loading into my desktop environment, even if saving was much
   faster since no tangling took place when saving the file, much less use of
   ~noweb~ causing massive slowdowns in the tangling process.

   Tangling blocks from a =literate-emacs.org= into byte-compiled =early-init.el=
   and =init.el= alongside the use of portable dumping (plus multiple other
   efficiency improvements, of course) cuts this time down to around 1.1 seconds
   to load into my desktop environment. This also comes with the advantage of
   being a hub for /all/ things related to my Emacs configuration, where
   previously I had to check multiple files when I thought I might have changed
   something for the worse.

   There has been some degree more complexity in managing this configuration,
   since I am having to juggle many more moving parts which may be in different
   places of the file, but the rewards for this kind of configuration are
   significantly outweighing the minor inconveniences which come with it.

** Installation

   1) Clone the repo into where you store your Emacs configuration.
   2) Make sure you have all the right dependencies. See below for more details.

** Dependencies

   #+begin_center
   *THIS CONFIGURATION IS MEANT FOR EMACS 27 AND LATER. IT WILL LIKELY /NOT/ LOAD
   PROPERLY ON EMACS 26 OR EARLIER. THE BRANCH FOR EMACS 26 OR EARLIER IS [[https://github.com/farlado/dotemacs/tree/emacs26-end][HERE]].*
   #+end_center

   Everything has different dependencies so make sure you have what you need.
   The quick and dirty route to getting all these dependencies installed and
   configured is to deploy [[https://github.com/farlado/dotfiles][my dotfiles]].

*** For EXWM

    - ~xorg~: For obvious reasons.
    - ~font-awesome~: For workspace names.
    - ~xcompmgr~: My compositor of choice.
    - ~arandr~: For monitor configuration.
    - ~nm-connection-editor~: For network configuration.
    - ~pavucontrol~: For volume mixing.
    - Various X applications: Launched by Emacs.

*** For ~desktop-environment~

    - ~alsa-utils~: For volume adjustment.
    - ~brightnessctl~: For laptop backlight adjustment.
    - ~maim~: For screenshots.
    - ~xclip~: For copying screenshots to the clipboard.
    - ~i3lock-color~: For the lock screen.

*** Other

    - ~aspell~: For spell-checking.
    - ~mpd~: For playing music with ~emms~.
    - ~ebook-tools~: For reading ebooks with ~nov~.
    - ~pylint~: For syntax checking within Python.
    - ~python-jedi~: For Python auto-complete.
    - ~curl~: For getting weather with ~wttrin~.
    - ~graphviz~: For creating diagrams.
    - ~stack~: Haskell tools.
    - ~sudo~: Duh.

** License

   Because I +am a lazy piece of shit who doesn't like long licenses+ don't think
   much harm could come from using a pushover license for a configuration, I am
   publishing this literate Emacs configuration under the WTFPL.

* Making Emacs start quickly

  This is everything related to starting Emacs quickly. First things first is
  setting up a batch script used to create a custom portable dump image,
  followed by what to execute at startup to make initialization faster.

** Starting Emacs FAST
   :properties:
   :header-args: :tangle (locate-user-emacs-file "lisp/pdumper.el")
   :end:

   Even with the "small" amount I ask of Emacs, it's a lot of beef to start up
   as fast as I demand it to start up. The portable dumper is an amazing thing.
   This is just a minimal script for utilizing the portable dumper added to
   Emacs 27 to make Emacs load faster. Every single ~require~ that doesn't create
   a =LispObject= incompatible with the portable dumper can now be skipped while
   loading. Before I started using the portable dumper, I saw start times of
   around 2.5 seconds. Now I am down 1.1 seconds, having cut about half of the
   start time out.

   This script must be run while Emacs is *not* open, otherwise it will *crash*
   Emacs and (if you're using ~vterm~ or another virtual terminal inside of Emacs
   to run the script) *the dump image will be corrupted*. To run the script, from
   the shell enter the following, substituting =$USER_EMACS_DIR= for wherever you
   store your Emacs configuration:

   #+begin_src sh :tangle no
     emacs --batch -q -l $USER_EMACS_DIR/lisp/pdumper.el
   #+end_src

*** Load packages

    In order to load anything, first packages must be loaded.

    #+begin_src emacs-lisp
      (require 'package)
      (package-initialize)

      (setq load-path `(,@load-path
                        (locate-user-emacs-file "lisp/xkb")
                        (locate-user-emacs-file "lisp/wallpaper")))
    #+end_src

*** Store =load-path=

    For some reason, the dump image doesn't store =load-path=, so it needs to be
    stored here, to be restored when =early-init.el= is loaded. A boolean is also
    set to indicate a portable dump image was used when Emacs is loaded.

    #+begin_src emacs-lisp
      (setq pdumper-load-path load-path
            pdumper-dumped t)
    #+end_src

*** ~require~ packages

    A considerable amount of time is spent loading packages during startup. The
    portable dump image is meant to load as many features at once as possible.
    These features are loaded so that they will be added to the dump image.

    #+begin_src emacs-lisp
      (dolist (package `(;; Core
                         async
                         use-package
                         auto-package-update
                         server

                         ;; Looks
                         dracula-theme
                         mood-line
                         page-break-lines
                         display-line-numbers
                         rainbow-mode
                         rainbow-delimiters
                         dashboard

                         ;; Functionality
                         which-key
                         company
                         company-emoji
                         counsel
                         ibuffer
                         buffer-move
                         sudo-edit

                         ;; Editing
                         graphviz-dot-mode
                         markdown-mode
                         flyspell
                         swiper
                         popup-kill-ring
                         hungry-delete
                         avy

                         ;; Programming
                         haskell-mode
                         highlight-indent-guides
                         company-jedi
                         flycheck
                         flycheck-package
                         flycheck-posframe
                         avy-flycheck

                         ;; `org-mode'
                         org
                         toc-org
                         org-bullets
                         epresent
                         org-tempo

                         ;; Other
                         nov
                         wttrin

                         ;; games
                         yahtzee
                         sudoku
                         tetris
                         chess
                         2048-game

                         ;; Media
                         emms
                         emms-setup

                         ;; Desktop Environment
                         exwm
                         exwm-randr
                         exwm-config
                         exwm-systemtray
                         exwm-mff
                         dmenu
                         minibuffer-line
                         system-packages
                         desktop-environment
                         wallpaper
                         xkb))
          (require package))
    #+end_src

*** Pre-load the theme

    A *HUGE* amount of time is spent loading the theme during startup. Loading the
    theme ahead of time saves a significant portion of the time cut by using a
    portable dump image.

    #+begin_src emacs-lisp
      (load-theme 'dracula t t)
    #+end_src

*** Write the dump image

    This is where the magic happens.

    #+begin_src emacs-lisp
      (dump-emacs-portable (locate-user-emacs-file "emacs.pdmp"))
    #+end_src

** Do these things ASAP
   :properties:
   :header-args: :tangle (locate-user-emacs-file "early-init.el")
   :end:

   Emacs 27 introduced =early-init.el=, allowing configuration of multiple items
   before Emacs has graphically loaded. Either I want these configured as soon
   as possible, or they are related to Emacs starting up. Which are which is
   left as an exercise to the reader.

*** Prepare GUI (Part 1)

    I want to get GUI elements out of my face as soon as I possibly can. They
    just take up space. If I'm running Emacs as my desktop environment (see
    further below), I want Emacs to immediately take on the background color of
    the theme I use to make startup marginally more aesthetically pleasing.

    #+begin_src emacs-lisp
      (menu-bar-mode -1)
      (tool-bar-mode -1)
      (scroll-bar-mode -1)
    #+end_src

*** Handling portable dumping

    For some reason, the portable dumper has odd behaviors. This block aims to
    address each of these behaviors so that using a custom dump image does not
    behave any different from not using one.

    This block is supposed to:
    - Recover =load-path= from the dump image
    - Restore modes not preserved in the dump image
    - Fix the scratch buffer
    - Create a function to ~require~ a feature only if =pdumper-dumped= is nil

    #+begin_src emacs-lisp
      (defvar pdumper-dumped nil
        "Non-nil if a custom dump image was loaded.")

      (defvar pdumper-load-path nil
        "Contains `load-path' if a custom dump image was loaded.")

      (defun pdumper-require (feature &optional filename noerror)
        "Call `require' to load FEATURE if `pdumper-dumped' is nil.

      FILENAME and NOERROR are also passed to `require'."
        (unless pdumper-dumped
          (require feature filename noerror)))

      (defun pdumper-fix-scratch-buffer ()
        "Ensure the scratch buffer is properly loaded."
        (with-current-buffer "*scratch*"
          (lisp-interaction-mode)))

      (when pdumper-dumped
        (add-hook 'after-init-hook #'pdumper-fix-scratch-buffer)
        (setq load-path pdumper-load-path)
        (global-font-lock-mode 1)
        (transient-mark-mode 1)
        (blink-cursor-mode 1))
    #+end_src

*** Byte-compile on first run

    It's done after =after-init-hook= so that we don't actually do it in the
    middle of loading files. That would be disastrous.

    #+begin_src emacs-lisp
      (defun farl-init/compile-user-emacs-directory ()
        "Recompile all files in `user-emacs-directory'."
        (byte-recompile-directory user-emacs-directory 0))

      (unless (file-exists-p (locate-user-emacs-file "init.elc"))
        (add-hook 'after-init-hook #'farl-init/compile-user-emacs-directory))
    #+end_src

*** Prefer the newest files

    If there's a difference in time between a file and its byte-compiled
    counterpart, prefer the newer one.

    #+begin_src emacs-lisp
      (setq load-prefer-newer t)
    #+end_src

*** More complete apropos

    This way, apropos does things more thoroughly, even if it's slower.

    #+begin_src emacs-lisp
      (setq-default apropos-do-all t)
    #+end_src

*** File name handling setup

    For whatever reason, setting =file-name-handler-alist= to =nil= helps Emacs load
    faster. After Emacs finishes loading, it's reverted to its original value.

    #+begin_src emacs-lisp
      (defvar startup/file-name-handler-alist file-name-handler-alist
        "Temporary storage for `file-name-handler-alist' during startup.")

      (defun startup/revert-file-name-handler-alist ()
        "Revert `file-name-handler-alist' to its default value after startup."
        (setq file-name-handler-alist startup/file-name-handler-alist))

      (setq file-name-handler-alist nil)
      (add-hook 'emacs-startup-hook #'startup/revert-file-name-handler-alist)
    #+end_src

*** Garbage collection setup

    Garbage collection shouldn't happen during startup, as that will slow Emacs
    down. Do it later. This is also where more ideal garbage collection settings
    are chosen. The functions used to defer and restore garbage collection are
    used later on.

    #+begin_src emacs-lisp
      (defun garbage-collect-defer ()
        "Defer garbage collection."
        (setq gc-cons-threshold most-positive-fixnum
              gc-cons-percentage 0.6))

      (defun garbage-collect-restore ()
        "Return garbage collection to normal parameters."
        (setq gc-cons-threshold 16777216
              gc-cons-percentage 0.1))

      (garbage-collect-defer)
      (add-hook 'emacs-startup-hook #'garbage-collect-restore)
    #+end_src

** Early package management
   :properties:
   :header-args: :tangle (locate-user-emacs-file "early-init.el")
   :end:

   Because I am writing this configuration to be as independent/portable as
   possible (e.g. I should be able to dump this onto any machine and run it), I
   manage all packages through Emacs. All of this is done leading up to the call
   of ~package-initialize~ between that =early-init.el= and =init.el=, which makes for
   faster loading.

*** Disable ~customize~, keep ~package-autoremove~ working

    I /hate/ ~customize~. I configure everything in this file, so I don't need
    anything messing with my =init.el=, much less changing settings on me. Even
    though I do not use ~customize~ but really like protecting packages used in my
    configuration from ~package-autoremove~, I need to still set the variable
    =package-selected-packages= so that it'll work. Packages are listed in the
    order in which they are mentioned in this configuration.

    #+begin_src emacs-lisp
      (setq custom-file "/tmp/custom.el"
            package-selected-packages '(;; Core
                                        async
                                        use-package
                                        auto-package-update

                                        ;; Looks
                                        dashboard
                                        dracula-theme
                                        mood-line
                                        page-break-lines
                                        rainbow-mode
                                        rainbow-delimiters

                                        ;; Functionality
                                        which-key
                                        company
                                        company-emoji
                                        counsel
                                        buffer-move
                                        sudo-edit

                                        ;; Text Editing
                                        graphviz-dot-mode
                                        markdown-mode
                                        swiper
                                        popup-kill-ring
                                        hungry-delete
                                        avy

                                        ;; Programming
                                        magit
                                        haskell-mode
                                        highlight-indent-guides
                                        company-jedi
                                        flycheck
                                        flycheck-package
                                        flycheck-posframe
                                        avy-flycheck

                                        ;; `org-mode'
                                        toc-org
                                        org-bullets
                                        epresent

                                        ;; Extend
                                        vterm
                                        nov
                                        wttrin

                                        ;; Games
                                        yahtzee
                                        sudoku
                                        chess
                                        2048-game

                                        ;; Other
                                        emms

                                        ;; Desktop Environment
                                        exwm
                                        dmenu
                                        exwm-mff
                                        minibuffer-line
                                        system-packages
                                        desktop-environment))
    #+end_src

*** Disable an annoying ~customize~ function

    Since I don't use ~customize~, we don't need to mess with it every time a
    package is installed or uninstalled. Because of this, I need to first load
    everything related to package management.

    #+begin_src emacs-lisp
      (pdumper-require 'package)
      (defun package--save-selected-packages (&rest opt)
        "Return nil, ignoring OPT.

      This function was altered to inhibit a specific undesired behavior."
        nil)
    #+end_src

*** Configure package repositories

    Next, we have to add our package repositories to the list. The GNU and MELPA
    repositories should be enough to last me decades.

    #+begin_src emacs-lisp
      (setq package-archives '(("gnu"   . "https://elpa.gnu.org/packages/")
                               ("melpa" . "https://melpa.org/packages/")))
    #+end_src

** Later package management
   :properties:
   :header-args: :tangle (locate-user-emacs-file "init.el")
   :end:

   This part of package management is meant to be done after ~package-initialize~
   has been called. At this point, we can leave =early-init.el= and move into
   =init.el= to continue Emacs startup.

*** Bootstrap ~async~

    Asynchronous execution of bytecode compilation and various other actions
    makes Emacs lock SIGNIFICANTLY less often. This is a very good thing.

    #+begin_src emacs-lisp
      (unless (package-installed-p 'async)
        (package-refresh-contents)
        (package-install 'async))

      (dired-async-mode 1)
      (async-bytecomp-package-mode 1)
      (setq async-bytecomp-allowed-packages '(all))
    #+end_src

*** Bootstrap ~use-package~

    Since I manage all Emacs packages in Emacs itself, ~use-package~ makes it much
    easier to manage the packages I need. It also means I can see what packages
    take the longest to load, alongside configure packages in a significantly
    more declarative manner.

    #+begin_src emacs-lisp
      (unless (package-installed-p 'use-package)
        (package-refresh-contents)
        (package-install 'use-package))

      (pdumper-require 'use-package)
      (setq use-package-compute-statistics t)
    #+end_src

*** Automatically update packages

    I don't want to have to manually update my stuff. This solution is literally
    plop-and-forget, and updates packages on a regular interval of two days.

    #+begin_src emacs-lisp
      (use-package auto-package-update
        :ensure t
        :defer t
        :custom ((auto-package-update-interval 2)
                 (auto-package-update-hide-results t)
                 (auto-package-update-delete-old-versions t))
        :hook (after-init . auto-package-update-maybe))
    #+end_src

** Final considerations
   :properties:
   :header-args: :tangle (locate-user-emacs-file "init.el")
   :end:

   These are other startup-specific things to be done after package management
   is finished being configured, e.g. put into =init.el= instead of =early-init.el=
   for any of it to take effect.

*** Start Emacs server

    Having the Emacs server running allows for a lot of neat integration with
    other parts of my desktop environment. I don't want to try to start a server
    if one is already running, though.

    #+begin_src emacs-lisp
      (pdumper-require 'server)
      (unless (server-running-p)
        (server-start))
    #+end_src

*** Prepare GUI (Part 2)

    These settings would be great to include in =early-init.el=, but they don't
    seem to go into effect unless they are in =init.el= instead. What a bummer.

    #+begin_src emacs-lisp
      (tooltip-mode -1)
      (setq use-dialog-box nil
            use-file-dialog nil)
    #+end_src

* Making Emacs much less ugly

  Stock Emacs is /ugly/. Just straight up ugly. Suffice to say it leaves much to
  be desired. This section is specifically meant for fixing Emacs visually and
  making it much more desirable for everyday use.

** Font
   :properties:
   :header-args: :noweb-ref theme-init
   :end:

*** Use UTF-8 encoding

    This makes for a much easier time editing files and working with text. Why
    isn't this the default to begin with since it's basically standard?

    #+begin_src emacs-lisp
      (prefer-coding-system 'utf-8)
      (setq locale-coding-system 'utf-8)
      (set-language-environment "UTF-8")
      (set-default-coding-systems 'utf-8)
      (set-terminal-coding-system 'utf-8)
      (set-keyboard-coding-system 'utf-8)
      (set-selection-coding-system 'utf-8)
    #+end_src

*** Setting the font style

    Originally I had this set up by means of ~custom-set-faces~, but frankly that
    is less easily configured than this method. Every part of ~customize~ simply
    isn't all that useful when trying to make things easier to edit directly
    from the configuration files.

    #+begin_src emacs-lisp
      (when (member "Iosevka" (font-family-list))
        (set-face-attribute 'default nil
                            :font "Iosevka"
                            :height 100))
    #+end_src

*** Getting emoji to work properly

    God does this one feel great to have now that I use an Emacs version that
    can handle it! Emoji now render properly in documents! üê≤

    #+begin_src emacs-lisp
      (when (member "Noto Color Emoji" (font-family-list))
        (set-fontset-font t 'symbol
                          (font-spec :family "Noto Color Emoji")
                          nil 'prepend))
    #+end_src

*** Don't unload fonts when not in use

    This solves a number of hanging issues related to a number of different
    packages and symbols. Emacs gets annoyingly slow if this is not set.

    #+begin_src emacs-lisp
      (setq inhibit-compacting-font-caches t)
    #+end_src

** Theme

   For the longest time I thought Leuven was seriously my best choice. As time
   has gone by, I've gotten less and less fond of Leuven. It served me well at
   the beginning of my exploration, but after so long using dark themes and
   having wallpapers behind my Emacs, Leuven stopped cutting it. Currently the
   theme I've stuck with is Dracula. It is the most comfortable and there are
   GTK themes that match it very well.

   #+begin_src emacs-lisp :noweb yes :tangle (locate-user-emacs-file "init.el")
     (use-package dracula-theme
       :if window-system
       :ensure t
       :defer t
       :init
       (if pdumper-dumped
           (enable-theme 'dracula)
         (load-theme 'dracula t))
       <<theme-init>>)
   #+end_src

*** Fringes

    Having fringes helps keep things looking good and gives the opportunity to
    have nice indicators on the edges of buffers. I prefer when fringes are the
    same color as the rest of the window, a choice which many themes seem not to
    agree with unfortunately.

    #+begin_src emacs-lisp :noweb-ref theme-init
      (set-face-background 'fringe (face-background 'default))
      (fringe-mode 10)
    #+end_src

*** Line numbers

    For some reason, some themes like to give line numbers a different color
    background from the rest of a window. I hate that. It distracts me and looks
    extremely tacky. Keeping the line numbers' background color the same color
    as the background of the rest of the window leaves little in the way of
    distractions.

    #+begin_src emacs-lisp :noweb-ref theme-init
      (set-face-background 'line-number (face-background 'default))
    #+end_src

*** Window dividers

    Windows dividers make Emacs look far less sloppy. The color is grabbed from
    the mode line for consistency. Three pixels seems to be the best looking
    width for window dividers.

    #+begin_src emacs-lisp :noweb-ref theme-init
      (setq window-divider-default-right-width 3)
      (let ((color (face-background 'mode-line)))
        (dolist (face '(window-divider-first-pixel
                        window-divider-last-pixel
                        window-divider))
          (set-face-foreground face color)))
      (window-divider-mode 1)
    #+end_src

*** Transparent frames

    If there's a gimmick I can't get enough of, it's having a transparent frame.
    At first, I thought it would look dumb, but it would make things hard to
    read since Emacs doesn't seem to differentiate between foreground and
    background when setting alpha values, but now that I have used it for a
    while, going back to an opaque frame seems tacky.

    #+begin_src emacs-lisp :noweb-ref theme-init
      (dolist (frame (frame-list))
        (set-frame-parameter frame 'alpha 90))
      (add-to-list 'default-frame-alist '(alpha . 90))
    #+end_src

*** Better ~org-mode~ headers

    For some reason, theme creators don't really think of formatting ~org-mode~
    past colors, so I have instead taken matters into my own hands. This way, I
    can use whatever color scheme I want with some peace of mind that at the
    least I don't have to look for ~org~-aware themes. +It also means I can
    override some of the dumber choices of ~org~-aware themes!+

    #+begin_src emacs-lisp :noweb-ref theme-init
      (pdumper-require 'org)
      (set-face-attribute 'org-level-1 nil
                          :height 1.3)
      (set-face-attribute 'org-level-2 nil
                          :height 1.1)
      (set-face-attribute 'org-level-3 nil
                          :height 1.0)
      (set-face-attribute 'org-document-title nil
                          :weight 'extra-bold
                          :height 1.8)
    #+end_src

** Mode line

   I hate the default mode line with a burning passion. This mode line is sleek
   and minimalist for a quick startup and a compact look and saved frustration.

   #+begin_src emacs-lisp :noweb yes :tangle (locate-user-emacs-file "init.el")
     (use-package mood-line
       :ensure t
       :defer t
       :init
       (mood-line-mode 1)
       <<mode-line-init>>)
   #+end_src

*** Show line/column numbers on the mode line

    Why isn't this enabled by default on a /text editor/? What line and column the
    point is on should always be visible on the mode line.

    #+begin_src emacs-lisp :noweb-ref mode-line-init
      (line-number-mode 1)
      (column-number-mode 1)
    #+end_src

*** Show clock and battery level on mode line

    I used to use ~fancy-battery~ for battery level but it constantly disappeared
    on my teeny tiny screens so I just decided not to bother with it. Plus it's
    one less package to configure lol. The clock should be in 24-hour time, and
    the date should also be shown.

    #+begin_src emacs-lisp :noweb-ref mode-line-init
      (display-time-mode 1)
      (display-battery-mode 1)
      :custom ((display-time-24hr-format t)
               (display-time-day-and-date t)
               (display-time-format "%a %m/%d %H:%M"))
    #+end_src

** In buffers
   :properties:
   :header-args: :tangle (locate-user-emacs-file "init.el")
   :end:

*** Word wrapping

    This is a more point of convenience than aesthetic, even in programming
    language buffers. Wrapping words makes for a heck of a lot more readability
    of any kind of text, whether a program or just normal language.

    #+begin_src emacs-lisp
      (global-visual-line-mode 1)
    #+end_src

*** Turn ^L into pretty lines

    This is used in a number of places in Emacs. Better to have it on all the
    time than never on. I didn't know it was an external package.

    #+begin_src emacs-lisp
      (use-package page-break-lines
        :ensure t
        :defer t
        :hook (after-init . global-page-break-lines-mode))
    #+end_src

*** Line numbers (on most buffers)

    I like having line numbers and indicators for lines past the EOF. However, I
    don't like line numbers in modes where it breaks the mode.

    #+begin_src emacs-lisp
      (use-package display-line-numbers
        :defer t
        :custom (indicate-empty-lines t)
        :hook ((text-mode
                prog-mode
                conf-mode) . display-line-numbers-mode))
    #+end_src

*** Highlight matching parentheses

    For when I can't figure out what's going on with parentheses...

    #+begin_src emacs-lisp
      (show-paren-mode 1)
      (set-face-attribute 'show-paren-match nil
                          :weight 'extra-bold
                          :underline t)
      (setq show-paren-style 'parentheses
            show-paren-delay 0)
    #+end_src

*** Color the background of text based on the color/hex typed

    I don't use it too much, but it's nice to have it around.

    #+begin_src emacs-lisp
      (use-package rainbow-mode
        :if window-system
        :ensure t
        :defer t
        :hook (prog-mode . rainbow-mode))
    #+end_src

*** Change the color of various delimiters based on how deep they go

    It's subtle on my theme, but it still helps me keep track of my brackets and
    parentheses and other important delimiters.

    #+begin_src emacs-lisp
      (use-package rainbow-delimiters
        :ensure t
        :defer t
        :hook (prog-mode . rainbow-delimiters-mode))
    #+end_src

** Start screen

   I like the default start screen, but it just doesn't cut it for me. I just
   use this to have a nice screen when I start Emacs or close all my buffers.

   #+begin_src emacs-lisp :noweb yes :tangle (locate-user-emacs-file "init.el")
     (use-package dashboard
       :ensure t
       :defer t
       :init
       <<dashboard-immortal>>
       <<dashboard-or-scratch>>
       (dashboard-setup-startup-hook)
       :custom ((inhibit-start-screen t)
                (dashboard-set-footer nil)
                (dashboard-startup-banner (locate-user-emacs-file "logo.png"))
                (dashboard-items '((recents . 10)))
                (initial-buffer-choice #'dashboard-or-scratch)
                (dashboard-banner-logo-title
                 "Welcome to Farlado's Illiterate GNU Emacs!"))
       :hook (dashboard-mode . dashboard-immortal))
   #+end_src

   When Emacs or ~emacsclient~ starts, the first buffer shown should be either
   dashboard or a scratch buffer. To prevent use of a lambda (something I
   have come to try to avoid where I can for a number of good reasons).

   #+begin_src emacs-lisp :noweb-ref dashboard-or-scratch
     (defun dashboard-or-scratch ()
       "Open either dashboard or the scratch buffer."
       (or (get-buffer "*dashboard*")
           (get-buffer "*scratch*")))
   #+end_src

   The dashboard buffer itself should be immortal. I used to close it all the
   time, and this is meant to prevent that by hooking ~emacs-lock-mode~ into
   =dashboard-mode-hook= to lock the buffer from being killed.

   #+begin_src emacs-lisp :noweb-ref dashboard-immortal
     (defun dashboard-immortal ()
       "Make the dashboard buffer immortal."
       (emacs-lock-mode 'kill))
   #+end_src

* Making Emacs more comfortable
  :properties:
  :header-args: :tangle (locate-user-emacs-file "init.el")
  :end:

  Anyone who has used Emacs for any period of time can attest to the fact that
  it can take a lot to make Emacs comfortable for one's use. That is not to say
  that Emacs is /bad/, but it definitely isn't the most usable piece of software
  straight out of the box. These settings make some of the things I personally
  dislike about defaults in Emacs somewhat better.

** General functionality
*** No suspending Emacs

    Why is this even something bound to begin with? I really dislike this and
    when I first did it I genuinely thought I broke something.

    #+begin_src emacs-lisp
      (global-unset-key (kbd "C-x C-z"))
      (global-unset-key (kbd "C-z"))
    #+end_src

*** No more training wheels

    I'm a big boy now, no need for anyone to hold my hand.

    #+begin_src emacs-lisp
      (setq disabled-command-function nil)
    #+end_src

*** Don't hang the minibuffer

    When using the minibuffer, never do garbage collection.

    #+begin_src emacs-lisp
      (add-hook 'minibuffer-setup-hook #'garbage-collect-defer)
      (add-hook 'minibuffer-exit-hook #'garbage-collect-restore)
    #+end_src

*** Always confirm closing Emacs

    I constantly kill Emacs on accident when running it in terminals, so this
    prevents me from doing that +as easily+. Having to always confirm when I quit
    Emacs is way better than accidentally killing Emacs when I don't want to.

    #+begin_src emacs-lisp
      (setq confirm-kill-emacs #'yes-or-no-p)
    #+end_src

*** Make scrolling a little less crazy

    Not sure why the mouse wheel gets acceleration, but thankfully I don't have
    to worry about that anymore. The goal is to make scrolling more friendly,
    e.g. it always scrolls one line at a time and the cursor stays where it is
    on the display.

    #+begin_src emacs-lisp
      (setq scroll-margin 0
            auto-window-vscroll nil
            scroll-conservatively 100000
            scroll-preserve-screen-position 1
            mouse-wheel-scroll-amount '(1 ((shift) . 1))
            mouse-wheel-progressive-speed nil
            mouse-wheel-follow-mouse t)
    #+end_src

*** Use a visual bell instead of making noise

    Sound is obnoxious and it should be visibly obvious without flashing the
    frame or mode line that something has gone wrong.

    #+begin_src emacs-lisp
      (setq ring-bell-function 'ignore)
    #+end_src

*** Replace "yes or no" prompts with "y or n" prompts

    Beauty in brevity, the less keystrokes the better.

    #+begin_src emacs-lisp
      (defalias 'yes-or-no-p #'y-or-n-p
        "Use `y-or-n-p' instead of a yes/no prompt.")
    #+end_src

** Completion helpers
*** ~which-key~ (small menus to help with commands)

    Even as I've gotten used to Emacs key bindings, it is always nice to have
    this around so that if I want to know, I can easily see what's what.

    #+begin_src emacs-lisp
      (use-package which-key
        :ensure t
        :defer t
        :hook (after-init . which-key-mode))
    #+end_src

*** Auto-complete in documents

    This is the base package. I changed some key bindings to make it more
    pleasant to use. It's not just for programming anymore, as seen in the next
    block. I don't want it to start recommending things unless I've typed more
    than three characters and let it sit for a little under a second.

    #+begin_src emacs-lisp
      (use-package company
        :ensure t
        :defer t
        :custom ((company-idle-delay 0.75)
                 (company-minimum-prefix-length 3))
        :hook (after-init . global-company-mode)
        :bind (:map company-active-map
               ("M-n" . nil)
               ("M-p" . nil)
               ("C-n" . company-select-next)
               ("C-p" . company-select-previous)
               ("SPC" . company-abort)))
    #+end_src

*** Typing Emoji using Emacs

    Thanks to ~company~ above, this is possible now!

    #+begin_src emacs-lisp
      (use-package company-emoji
        :after company
        :ensure t
        :defer t
        :init
        (add-to-list 'company-backends #'company-emoji))
    #+end_src

*** Auto-completion for commands

    I /love/ ~ido-mode~, but sometimes it just doesn't cut it. For those times, I
    instead use ~counsel~, which provides a fancier completion experience than
    ~ido-mode~ does currently. It's also way more ubiquitous than ~ido-mode~.

    #+begin_src emacs-lisp :noweb yes
      (use-package counsel
        :ensure t
        :defer t
        :init
        <<fix-ido>>
        :hook (after-init . farl-init/ivy-mode)
        :bind (("M-x" . counsel-M-x)
               ("C-x C-f" . counsel-find-file)
               ("C-c d" . counsel-cd)))
    #+end_src

    For some reason, ~ido-mode~ is enabled when ~ivy-mode~ is, which makes other
    packages I use break. I don't want that to happen, so I hook a function
    into =after-init-hook= to prevent that clash.

    #+begin_src emacs-lisp :tangle no :noweb-ref fix-ido
      (defun farl-init/ivy-mode ()
        "Start `ivy-mode' while disabling `ido-mode'."
        (ivy-mode 1)
        (ido-mode -1)
        (counsel-mode 1)
        (setq ivy-initial-inputs-alist nil))
    #+end_src

** Functions/macros
*** Find a string in a buffer's file name

    This is relied upon at multiple points of this configuration.

    #+begin_src emacs-lisp
      (defun buffer-file-match (string)
        "Find STRING in variable `buffer-file-name'."
        (string-match-p string buffer-file-name))
    #+end_src

*** Reference a file in the home directory

    This macro is meant to make referring to files in the home directory easier.

    #+begin_src emacs-lisp
      (defmacro user-home-file (file)
        "Find FILE in the user's home directory."
        (expand-file-name file (getenv "HOME")))
    #+end_src

*** Reference a file in =$XDG_CONFIG_HOME=

    This is also crucial for my literate dotfiles, since I am maximizing the
    compliance of my dotfiles with the XDG Base Directory Specification.

    #+begin_src emacs-lisp
      (defmacro user-config-file (file)
        "Find a FILE in the user's $XDG_CONFIG_HOME directory."
        (expand-file-name file (getenv "XDG_CONFIG_HOME")))
    #+end_src

** Buffers/windows
*** Buffer management

    Buffer management is done using ~ibuffer~, which is orders of magnitude more
    comfortable than other ways I've seen of managing buffers. Packages like
    ~helm~ can probably do good, but I personally like using what's already
    available to me. Buffer names should also be made unique. This looks a lot
    fancier than the default behavior, and makes buffer names far easier to read
    at a glance.

    #+begin_src emacs-lisp
      (use-package ibuffer
        :defer t
        :init
        (defun farl-ibuffer/use-default-filter-group ()
          "Switch to the intended filter group."
          (ibuffer-switch-to-saved-filter-groups "default"))
        :custom ((ibuffer-saved-filter-groups
                  (quote (("default"
                           ("firefox" (name . "Firefox$"))
                           ("exwm" (or (mode . exwm-mode)
                                       (name . "^\\*XELB-DEBUG\\*$")))
                           ("emms" (or (mode . emms-mode)
                                       (mode . emms-browser-mode)
                                       (mode . emms-playlist-mode)))
                           ("vterm" (mode . vterm-mode))
                           ("magit" (name . "^magit.*:"))
                           ("dired" (mode . dired-mode))
                           ("elisp" (mode . emacs-lisp-mode))
                           ("emacs" (or (name . "^\\*dashboard\\*$")
                                        (name . "^\\*scratch\\*$")
                                        (name . "^\\*Messages\\*$")
                                        (name . "^\\*Backtrace\\*$")
                                        (name . "^\\*Compile-Log\\*$")
                                        (name . "^\\*Shell.*Output\\*$")))))))
                 (uniquify-buffer-name-style 'forward)
                 (uniquify-after-kill-buffer-p t))
        :hook (ibuffer-mode . farl-ibuffer/use-default-filter-group)
        :bind (("C-x b" . ibuffer)
               ("C-x C-b" . nil)))
    #+end_src

*** Follow when making new windows

      When forming a new window, it should be followed and ~ibuffer~ should be
      opened. This replaces the other not particularly friendly behavior.

      #+begin_src emacs-lisp :noweb-ref window-management :tangle no
        :init
        (defun split-and-follow-vertical ()
          "Open a new window vertically."
          (interactive)
          (split-window-below)
          (other-window 1)
          (ibuffer))
        (defun split-and-follow-horizontal ()
          "Open a new window horizontally."
          (interactive)
          (split-window-right)
          (other-window 1)
          (ibuffer))
        :bind (("C-x 2" . split-and-follow-vertical)
               ("C-x 3" . split-and-follow-horizontal))
    #+end_src

*** Changing focus and moving windows

    There are built-in functions for changing focus between windows, but there
    are not good built-in functions for swapping two windows and moving buffers
    between windows. Since ~other-window~ is hot garbage, I instead use =C-x o= as a
    prefix for the commands related to moving focus or moving windows.

    #+begin_src emacs-lisp :noweb yes
      (use-package buffer-move
        :ensure t
        :defer t
        <<window-management>>
        :bind (("C-x o" . nil)
               ("C-x o w" . windmove-up)
               ("C-x o a" . windmove-left)
               ("C-x o s" . windmove-down)
               ("C-x o d" . windmove-right)
               ("C-x o C-w" . buf-move-up)
               ("C-x o C-a" . buf-move-left)
               ("C-x o C-s" . buf-move-down)
               ("C-x o C-d" . buf-move-right)))
    #+end_src

*** Sloppy focus (focus by mouse hover)

    Changing focus can also be done through sloppy focus, e.g. moving the cursor
    between windows. I hate having to click to focus a different window, so I
    would rather just have windows sloppily focus. This has some flaws when
    using Emacs as a desktop environment, but it's still cozier than the
    alternative behavior.

    #+begin_src emacs-lisp :noweb-ref window-management :tangle no
        :custom ((focus-follows-mouse t)
                 (mouse-autoselect-window t))
    #+end_src

*** Make the scratch buffer immortal and start blank

    I kill the scratch buffer way too often if I don't do this. While I'm here,
    I might as well also make the scratch buffer blank.

    #+begin_src emacs-lisp
      (with-current-buffer "*scratch*"
        (emacs-lock-mode 'kill))

      (setq initial-scratch-message "")
    #+end_src

** Key binds
*** Open Emacs configuration with =C-c e=

    #+begin_src emacs-lisp
      (defun config-visit ()
        "Open the configuration file."
        (interactive)
        (find-file (locate-user-emacs-file "literate-emacs.org")))

      (global-set-key (kbd "C-c e") #'config-visit)
    #+end_src

*** Open dotfiles configuration with =C-c M-e=

    #+begin_src emacs-lisp
      (defun literate-dotfiles-visit ()
        "Open the literate dotfiles."
        (interactive)
        (find-file (user-config-file "dotfiles/literate-dotfiles.org")))

      (when (file-exists-p (user-config-file "dotfiles/literate-dotfiles.org"))
        (global-set-key (kbd "C-c M-e") #'literate-dotfiles-visit))
    #+end_src

*** Open system configuration with =C-c C-M-e=

    #+begin_src emacs-lisp
      (defun sys-config-visit ()
        "Open the literate system configuration"
        (interactive)
        (find-file (user-config-file "dotfiles/literate-sysconfig.org")))

      (when (file-exists-p (user-config-file "dotfiles/literate-sysconfig.org"))
        (global-set-key (kbd "C-c C-M-e") #'sys-config-visit))
    #+end_src

*** Balance window sizes with =C-c b=

    #+begin_src emacs-lisp
      (global-set-key (kbd "C-c b") #'balance-windows)
    #+end_src

*** Kill the current buffer with =C-x k=

    #+begin_src emacs-lisp
      (global-set-key (kbd "C-x k") #'kill-this-buffer)
    #+end_src

*** Kill both the buffer and window with =C-x C-k=

    I had to adjust the function which kills both the current buffer and the
    current window, because it did not cooperate with EXWM buffers.

    #+begin_src emacs-lisp
      (defun kill-this-buffer-and-window ()
        "Kill the current buffer and delete the selected window.

      This function has been altered to accomodate `exwm-mode'."
        (interactive)
        (let ((window-to-delete (selected-window))
              (buffer-to-kill (current-buffer))
              (delete-window-hook (lambda ()
                                    (ignore-errors
                                      (delete-window)))))
          (unwind-protect
              (progn
                (add-hook 'kill-buffer-hook delete-window-hook t t)
                (if (kill-buffer (current-buffer))
                    ;; If `delete-window' failed before, we repeat
                    ;; it to regenerate the error in the echo area.
                    (when (eq (selected-window) window-to-delete)
                      (delete-window)))))))

      (global-set-key (kbd "C-x C-k") #'kill-this-buffer-and-window)
    #+end_src

*** Kill all buffers and all windows with =C-x C-M-k=

    #+begin_src emacs-lisp
      (defun close-buffers-and-windows ()
        "Kill every buffer and close all windows, then restart dashboard."
        (interactive)
        (when (yes-or-no-p "Really kill all buffers? ")
          (save-some-buffers)
          (mapc 'kill-buffer (buffer-list))
          (delete-other-windows)))

      (global-set-key (kbd "C-x C-M-k") #'close-buffers-and-windows)
    #+end_src

*** Edit files with superuser privileges using =C-x C-M-f=

    This is especially useful when I need to edit system files.

    #+begin_src emacs-lisp
      (use-package sudo-edit
        :ensure t
        :defer t
        :bind ("C-x C-M-f" . sudo-edit))
    #+end_src

* Making Emacs a good text editor
  :properties:
  :header-args: :tangle (locate-user-emacs-file "init.el")
  :end:

  Emacs /is/ a text editor... right? This used to be a +somewhat bigger+ mess of
  different sections, but I've been working to categorize these settings far
  better, so much of what was previously elsewhere is now set up in here.
  Everything in here /should/ be about making Emacs pleasant to use for editing
  text of various kinds. If it isn't, I have failed.

** Additional major modes

   These are modes that enable Emacs to edit different kinds of files
   differently. Programming major modes are further down, in the
   programming section.

*** ~graphviz-dot-mode~ (diagram creation)

    A nice way to make diagrams.

    #+begin_src emacs-lisp
      (use-package graphviz-dot-mode
        :ensure t
        :defer t
        :mode ("\\.dot\\'" . graphviz-dot-mode))
    #+end_src

*** ~markdown-mode~ (bootleg org-mode for GitHub)

    I really don't like Markdown but I have to use it, so...

    #+begin_src emacs-lisp
      (use-package markdown-mode
        :ensure t
        :defer t
        :mode ("\\.md\\'" . markdown-mode))
    #+end_src

** Personal save hooks

   When I save a file, sometimes I want specific things to be done.

*** Tangle literate programming files

    I've gotten really into literate programming lately, so this makes it much
    easier to tangle files. Every time =after-save-hook= is run, if the filename
    contains "literate" and is an org-mode file, call ~org-babel-tangle~.

    #+begin_src emacs-lisp
      (defun tangle-literate-program ()
        "Tangle a file if it's a literate programming file."
        (interactive)
        (when (buffer-file-match "literate.*.org$")
          (org-babel-tangle)))

      (add-hook 'after-save-hook #'tangle-literate-program -100)
    #+end_src

*** Automatically byte-compile Emacs files

    This is meant to happen when I save my Emacs configuration, so that all
    bytecode is up to date. It adds some time to each save, but it is worth it
    for never having to recompile my Emacs configuration manually again.

    #+begin_src emacs-lisp
      (defun byte-compile-config-files ()
        "Byte-compile Emacs configuration files."
        (when (string-match-p "literate-emacs.org" (buffer-file-name))
          (byte-recompile-directory user-emacs-directory 0)))

      (add-hook 'after-save-hook #'byte-compile-config-files 100)
    #+end_src

** General editing
*** Spell-checking

    Just a useful little tool to check spelling while editing a buffer. Only
    configured if ~aspell~ is installed. It's not super great, but it does the
    trick well enough for me.

    #+begin_src emacs-lisp
      (use-package flyspell
        :if (executable-find "aspell")
        :defer t
        :custom ((ispell-program-name "aspell")
                 (ispell-dictionary "american"))
        :hook ((flyspell-mode . flyspell-buffer)
               ((prog-mode
                 conf-mode) . flyspell-prog-mode)
               (text-mode . flyspell-mode)))
    #+end_src

*** Better search behavior

    This search behavior is *SO* much nicer than the default.

    #+begin_src emacs-lisp
      (use-package swiper
        :ensure t
        :defer t
        :bind ("C-s" . swiper))
    #+end_src

*** No backups or auto-saving

    I love living on the edge.

    #+begin_src emacs-lisp
      (setq backup-inhibited t
            make-backup-files nil
            auto-save-default nil)
    #+end_src

*** Automatically revert files on change

    This way if files get modified in the middle of editing them, I don't
    overwrite the changes. This can also change ~dired~ and ~ibuffer~ buffers if I
    am not mistaken. However, I don't need to hear every last thing about it.

    #+begin_src emacs-lisp
      (global-auto-revert-mode 1)

      (setq global-auto-revert-non-file-buffers t
            auto-revert-remote-files t
            auto-revert-verbose nil)
    #+end_src

*** End-of-file newlines and indent tabs

    Screw indent tabs, spaces all the way. Also, if there is no end-of-file
    newline, add it. Things that help me keep my files nice and clean.

    #+begin_src emacs-lisp
      (setq require-final-newline t)
      (setq-default indent-tabs-mode nil)
    #+end_src

*** Manage the kill ring using a pop-up menu

    Having the whole kill ring easy to scroll through is much less hassle than
    default behavior. We also set up some yanking behavior while we're at it.

    #+begin_src emacs-lisp
      (use-package popup-kill-ring
        :ensure t
        :defer t
        :custom ((save-interprogram-paste-before-kill t)
                 (mouse-drag-copy-region t)
                 (mouse-yank-at-point t))
        :bind ("M-y" . popup-kill-ring))
    #+end_src

*** Delete whatever is selected if typing starts

    This is to reflect behavior in other programs.

    #+begin_src emacs-lisp
      (delete-selection-mode 1)
    #+end_src

*** Hungrily remove all whitespace when deleting

    This saves me tons of time when it comes to managing whitespace. Instead of
    having to repeatedly press delete or backspace, a single keystroke decimates
    all the whitespace between the point and whatever is in the direction the
    deletion happens. Currently broken.

    #+begin_src emacs-lisp
      (use-package hungry-delete
        :ensure t
        :defer t
        :init
        (global-hungry-delete-mode 1))
    #+end_src

*** Move around visible portions of files faster

    If I want to hop around in a document without calling swiper, ~avy~ is
    definitely the way to go.

    #+begin_src emacs-lisp
      (use-package avy
        :ensure t
        :defer t
        :bind ("M-s" . avy-goto-char))
    #+end_src

*** Move between SubWords as well as between words

    This allows for much easier navigation between words when in programming
    language buffers, but also has utility outside of programming so it's
    enabled globally.

    #+begin_src emacs-lisp
      (global-subword-mode 1)
    #+end_src

*** electric-pair-mode (OH MY GOD THIS IS SO GREAT)

    I have no words for how convenient this has been and how much faster I get
    things done thanks to these six lines of elisp.

    #+begin_src emacs-lisp
      (setq electric-pair-pairs '((?\{ . ?\})
                                  (?\( . ?\))
                                  (?\[ . ?\])
                                  (?\" . ?\")))
      (electric-pair-mode 1)
      (minibuffer-electric-default-mode 1)
    #+end_src

** Programming

   It's slowly growing, but I still truly do not need all that much when it
   comes to programming, mostly because I don't actually do all that much
   programming outside what I do for fun... and editing this file.

*** Use SBCL for inferior Lisp mode

    #+begin_src emacs-lisp
      (setq inferior-lisp-program "sbcl")
    #+end_src

*** ~magit~ (git but in Emacs)

    I used to use a terminal for this, but holy crap this is a lot easier, a lot
    faster, and a whole lot nicer to use overall.

    #+begin_src emacs-lisp
      (use-package magit
        :ensure t
        :defer t
        :bind ("C-x g" . magit-status))
    #+end_src

*** ~haskell-mode~

    I have started to mess around with Haskell, so I needed to grab a mode for
    that. This supplies basically everything I need as far as I know, e.g.
    company autocompletion and flycheck information.

    #+begin_src emacs-lisp
      (use-package haskell-mode
        :ensure t
        :defer t
        :custom (haskell-stylish-on-save t)
        :hook ((haskell-mode . interactive-haskell-mode)
               (haskell-mode . haskell-doc-mode)
               (haskell-mode . haskell-indentation-mode)
               (haskell-mode . haskell-auto-insert-module-template)))
    #+end_src

*** Indent guides

    This is really nice to have, because I screw up indentation all the time.

    #+begin_src emacs-lisp
      (use-package highlight-indent-guides
        :if window-system
        :ensure t
        :defer t
        :custom (highlight-indent-guides-method 'character)
        :hook (prog-mode . highlight-indent-guides-mode))
    #+end_src

*** Python autocomplete

    #+begin_src emacs-lisp
      (use-package company-jedi
        :after company
        :ensure t
        :defer t
        :init
        (add-to-list 'company-backends 'company-jedi))
    #+end_src

*** On-the-fly syntax checking

    This is nice to have so I can be told right away when something's wrong.

    #+begin_src emacs-lisp
      (use-package flycheck
        :ensure t
        :defer t
        :hook (prog-mode . flycheck-mode))
    #+end_src

*** On-the-fly package linting

    Now that I'm dabbling in writing Emacs packages, I need to be able to lint
    packages more thoroughly. Adding a linter specifically for packages is very
    comfy and cool and good.

    #+begin_src emacs-lisp
      (use-package flycheck-package
        :after flycheck
        :ensure t
        :defer t
        :init
        (flycheck-package-setup))
    #+end_src

*** Move ~flycheck~ issues out of the minibuffer

    I want errors to be in their own area, not polluting the minibuffer.

    #+begin_src emacs-lisp
      (use-package flycheck-posframe
        :if window-system
        :after flycheck
        :ensure t
        :defer t
        :custom ((posframe-mouse-banish nil)
                 (flycheck-posframe-position 'window-bottom-left-corner))
        :hook ((flycheck-mode . flycheck-posframe-mode)
               (flycheck-posframe-mode . flycheck-posframe-configure-pretty-defaults)))
    #+end_src

*** ~avy~-style navigation but between syntax errors

    This one is *SUPER COOL*. Being able to jump straight to a problem is comfy.

    #+begin_src emacs-lisp
      (use-package avy-flycheck
        :ensure t
        :defer t
        :bind (:map prog-mode-map
               ("C-c C-'" . avy-flycheck-goto-error)))
    #+end_src

** Org-mode
   :properties:
   :header-args: :tangle no :noweb yes :noweb-ref org-init
   :end:

   As I spend more time in Org-mode, the more I need from it.

   #+begin_src emacs-lisp :noweb-ref no :tangle (locate-user-emacs-file "init.el")
     (use-package org
       :defer t
       :init
       <<org-init>>
       <<org-custom>>
       <<org-hook>>
       <<org-binds>>)
   #+end_src

*** Table of Contents

    This automates creating the table of contents for an ~org-mode~ document. It
    also works in ~markdown-mode~ too if I ever have to use Markdown.

    #+begin_src emacs-lisp
      (use-package toc-org
        :ensure t
        :defer t
        :hook ((org-mode . toc-org-mode)
               (markdown-mode . toc-org-mode)))
    #+end_src

*** Fancier bullet points

    It's kinda slow, but bullet points are very nice, better than asterisks.

    #+begin_src emacs-lisp
      (use-package org-bullets
        :if window-system
        :ensure t
        :defer t
        :hook (org-mode . org-bullets-mode))
    #+end_src

*** Presentations in Emacs

    It's gonna need more polish, but it works.

    #+begin_src emacs-lisp
      (use-package epresent
        :if window-system
        :ensure t
        :defer t
        :bind (:map org-mode-map
               ("C-c r" . epresent-run)))
    #+end_src

*** Quality-of-life settings

    These are just quick things that make ~org-mode~ much easier to use. Other
    settings are pulled into here for a cleaner tangle.

    #+begin_src emacs-lisp :noweb yes :noweb-ref org-custom
      :custom ((org-pretty-entities t)
               (org-src-fontify-natively t)
               (org-agenda-use-time-grid nil)
               (org-fontify-done-headline t)
               (org-src-tab-acts-natively t)
               (org-enforce-todo-dependencies t)
               (org-fontify-whole-heading-line t)
               (org-agenda-skip-deadline-if-done t)
               (org-agenda-skip-scheduled-if-done t)
               (org-fontify-quote-and-verse-blocks t)
               (org-src-window-setup 'current-window)
               (org-highlight-latex-and-related '(latex))
               (org-ellipsis (if window-system "‚§µ" "..."))
               (org-hide-emphasis-markers window-system)
               <<org-vars>>)
    #+end_src

*** Evaluating Graphviz blocks

    Since obviously dot snippets are purely harmless +as far as I know+, I just
    don't bother with having to confirm evaluation every time I try to update a
    graphic.

    #+begin_src emacs-lisp
      (org-babel-do-load-languages 'org-babel-load-languages '((dot . t)))
    #+end_src

*** Execute some code without having to confirm

    Since obviously dot snippets are purely harmless +as far as I know+, I just
    don't bother with having to confirm evaluation every time I try to update a
    graphic. I also don't need to confirm evaluation of snippets in use in my
    literate files.

    #+begin_src emacs-lisp
      (defun farl-org/confirm-babel-evaluate (lang body)
        "Don't ask to evaluate graphviz blocks or literate programming blocks."
        (not (or (string= lang "dot")
                 (buffer-file-match "literate.*.org$"))))
    #+end_src

    The variable for confirming whether to evaluate a block is set later on.

    #+begin_src emacs-lisp :noweb-ref org-vars
      (org-confirm-babel-evaluate #'farl-org/confirm-babel-evaluate)
    #+end_src

*** Shortcuts for various snippets

    First, we load ~org-tempo~, the extension that allows the old way of doing
    things, and add it to =org-modules=. Then, we add shortcuts for the individual
    blocks of code. Finally, we can add shortcuts for other items that aren't
    blocks. I've grown somewhat fond of this way of organizing my shortcuts,
    because it separates the blocks from the one-liners.

    #+begin_src emacs-lisp
      (use-package org-tempo
        :defer t
        :init
        (add-to-list 'org-modules 'org-tempo)
        :custom ((org-structure-template-alist '(;; General blocks
                                                 ("c" . "center")
                                                 ("C" . "comment")
                                                 ("e" . "example")
                                                 ("q" . "quote")
                                                 ("v" . "verse")

                                                 ;; Export blocks
                                                 ("a"   . "export ascii")
                                                 ("h"   . "export html")
                                                 ("css" . "export css")
                                                 ("l"   . "export latex")

                                                 ;; Code blocks
                                                 ("s"   . "src")
                                                 ("sh"  . "src sh")
                                                 ("cf"  . "src conf")
                                                 ("cu"  . "src conf-unix")
                                                 ("cs"  . "src conf-space")
                                                 ("cx"  . "src conf-xdefaults")
                                                 ("cjp" . "src conf-javaprop")
                                                 ("el"  . "src emacs-lisp")
                                                 ("py"  . "src python")
                                                 ("dot" . "src dot :file")
                                                 ("txt" . "src text :tangle")))
                 (org-tempo-keywords-alist '(;; Title/subtitle/author
                                             ("t"  . "title")
                                             ("st" . "subtitle")
                                             ("au" . "author")

                                             ;; Language
                                             ("la" . "language")

                                             ;; Name/caption
                                             ("n"  . "name")
                                             ("ca" . "caption")

                                             ;; Property/options/startup
                                             ("p"  . "property")
                                             ("o"  . "options")
                                             ("su" . "startup")

                                             ;; Other
                                             ("L" . "latex")
                                             ("H" . "html")
                                             ("A" . "ascii")
                                             ("i" . "index")))))
    #+end_src

*** Don't give angle brackets syntax

    For some reason, starting with ~org-mode~ 9.3 or so, all symbols that are
    brackets, i.e. ={}=, =()=, =<>=, are given syntax as pairs. This isn't a problem
    on its own (especially since it makes quotations and parentheses far easier
    to work with), but /angle brackets specifically/ cause issues since they
    specifically are inequality operators in my books and =<= is the prefix for
    the shortcuts provided by ~org-tempo~.

    #+begin_src emacs-lisp
      (defun farl-org/disable-angle-bracket-syntax ()
        "Disable angle bracket syntax."
        (modify-syntax-entry ?< ".")
        (modify-syntax-entry ?> "."))
    #+end_src

    This function is hooked in =org-mode-hook=. Other hooks are pulled into here
    for a significantly cleaner tangle.

    #+begin_src emacs-lisp :noweb-ref org-hook
      :hook ((org-mode . farl-org/disable-angle-bracket-syntax)
             <<org-hooks>>)
    #+end_src

*** Agenda (only enabled if an agenda is found)

    I store my agendas in =$HOME/agendas=.

    #+begin_src emacs-lisp
      (defun open-agenda-file ()
        "Open the agenda file."
        (interactive)
        (find-file (ivy-read
                    "Open agenda: "
                    (all-completions "" org-agenda-files))))

      (when (file-directory-p "~/agendas")
        (setq org-agenda-files (directory-files-recursively
                                (user-home-file "agendas")
                                ".org$" nil t t)))
    #+end_src

    I open the agenda with =C-c M-a= and open a specific agenda file with =C-c s-a=.
    These are the only binds done in this entire section.

    #+begin_src emacs-lisp :noweb-ref org-binds
      :bind (("C-c s-a" . open-agenda-file)
             ("C-c M-a" . org-agenda))
    #+end_src

*** Automatically fix inline images generated for diagrams

    This is exactly what I was looking for lmao

    #+begin_src emacs-lisp :noweb-ref org-hooks
      (org-babel-after-execute . org-redisplay-inline-images)
    #+end_src

* Making Emacs more than an editor
  :properties:
  :header-args: :tangle (locate-user-emacs-file "init.el")
  :end:

  Emacs is also more than just an editor, right? If it isn't about editing text
  but also isn't a major thing, it will probably be found in here.

** Not built-in
*** Emacs is my terminal

    I've been jumping between ~vterm~ and ~ansi-term~. In the end ~vterm~ blows
    ~ansi-term~ clean out of the water. In the off-chance I'm running Emacs in the
    terminal, =C-c t= can open ~vterm~.

    #+begin_src emacs-lisp
      (use-package vterm
        :ensure t
        :defer t
        :bind ("C-c t" . vterm))
    #+end_src

*** Reading ebooks in Emacs

    Not the best way to do epub reading, but at least it's in Emacs.

    #+begin_src emacs-lisp
      (use-package nov
        :ensure t
        :defer t
        :mode ("\\.epub\\'" . nov-mode))
    #+end_src

*** Getting the weather using Emacs

    Picking a service to use for this was a pain. I ended up settling for wttrin
    because it is the fastest and easiest to use, and plays nice with my setup.

    #+begin_src emacs-lisp
      (use-package wttrin
        :ensure t
        :defer t
        :custom (wttrin-default-cities '("Indianapolis"))
        :bind ("C-c w" . wttrin))
    #+end_src

** Built-in
*** Calendar

    Weeks start on Monday.

    #+begin_src emacs-lisp
      (setq calendar-week-start-day 1)
      (global-set-key (kbd "C-c l") #'calendar)
    #+end_src

*** Reading the manpages

    Wow, there's actually an Emacs mode for this! I put these into the =C-h=
    binds, since it is a way of getting help, after all. If for some reason ~man~
    is working, ~woman~ can still grab a manpage without calling ~man~.

    #+begin_src emacs-lisp
      (global-set-key (kbd "C-h 4 m") #'man)
      (global-set-key (kbd "C-h 4 w") #'woman)
    #+end_src

** Games

   To make running games easier, I set up a keymap to which I add the games.

   #+begin_src emacs-lisp
     (defvar games-map (make-sparse-keymap)
       "A keymap to which games can be added.")

     (global-set-key (kbd "C-c g") games-map)
   #+end_src

*** Yahtzee

    Fun dice game. Now I can get mad at Emacs instead of my sister.

    #+begin_src emacs-lisp
      (use-package yahtzee
        :ensure t
        :defer t
        :bind (:map games-map
               ("y" . yahtzee)))
    #+end_src

*** Sudoku

    I /love/ sudoku puzzles.

    #+begin_src emacs-lisp
      (use-package sudoku
        :ensure t
        :defer t
        :bind (:map games-map
               ("s" . sudoku)))
    #+end_src

*** Tetris

    Tetris is my childhood. No way I wouldn't set it up to be nice and comfy.

    #+begin_src emacs-lisp
      (use-package tetris
        :defer t
        :bind (:map games-map
               ("t" . 'tetris)
               :map tetris-mode-map
               ("w" . tetris-move-bottom)
               ("a" . tetris-move-left)
               ("s" . tetris-mode-down)
               ("d" . tetris-move-right)
               ([left] . tetris-rotate-next)
               ([right] . tetris-rotate-prev)
               ([?\t] . tetris-pause-game)
               ("r" . tetris-start-game)
               ("e" . tetris-end-game)))
    #+end_src

*** Chess

    Just for fun. I suck at chess but it's nice to have.

    #+begin_src emacs-lisp
      (use-package chess
        :ensure t
        :defer t
        :bind (:map games-map
               ("c" . chess)))
    #+end_src

*** 2048

    A simple and fun game. Was a big deal when I was in high school. I still
    play it from time to time.

    #+begin_src emacs-lisp
      (use-package 2048-game
        :ensure t
        :defer t
        :bind (:map games-map
               ("2" . 2048-game)))
    #+end_src

* Making Emacs manage/play my music

  I am big on doing as much in Emacs as possible. Having my music player moved
  to Emacs was a HUGE step. When I first started using it, it was weird, but now
  I have come to absolutely love it. We only configure EMMS if ~mpd~ is found.

  #+begin_src emacs-lisp :noweb yes :tangle (locate-user-emacs-file "init.el")
    (use-package emms
      :if (executable-find "mpd")
      :ensure t
      :defer t
      :init
      <<emms-init>>
      <<emms-vars>>
      <<emms-keys>>)
  #+end_src

** Loading

   This loads the necessary files to ensure ~emms~ starts properly.

   #+begin_src emacs-lisp :noweb-ref emms-init
     (pdumper-require 'emms-setup)
     (require 'emms-player-mpd)
     (emms-all)
   #+end_src

** Functions
   :properties:
   :header-args: :noweb-ref emms-init
   :end:
*** Starting the daemon

    #+begin_src emacs-lisp
      (defun mpd/start-music-daemon ()
        "Start MPD, connect to it and sync the metadata cache"
        (interactive)
        (shell-command "mpd")
        (mpd/update-database)
        (emms-player-mpd-connect)
        (emms-cache-set-from-mpd-all)
        (message "MPD started!"))
    #+end_src

*** Stopping the daemon

    #+begin_src emacs-lisp
      (defun mpd/kill-music-daemon ()
        "Stop playback and kill the music daemon."
        (interactive)
        (emms-stop)
        (call-process "killall" nil nil nil "mpd")
        (message "MPD killed!"))
    #+end_src

*** Updating the database

    #+begin_src emacs-lisp
      (defun mpd/update-database ()
        "Update the MPD database synchronously."
        (interactive)
        (call-process "mpc" nil nil nil "update")
        (message "MPD database updated!"))
    #+end_src

*** Shuffling the playlist

    #+begin_src emacs-lisp
      (defun farl-emms/shuffle-with-message ()
        "Shuffle the playlist and say so in the echo area."
        (interactive)
        (emms-shuffle)
        (message "Playlist has been shuffled."))
    #+end_src

** Keybindings
  
   Making a keymap was a mistake. This is so much comfier and looks a lot nicer
   when using ~which-key~, and does not require the creation of an entire keymap.

   #+begin_src emacs-lisp :noweb-ref emms-keys
     :bind (;; Opening playlist and music browser
            ("C-c a v" . emms)
            ("C-c a b" . emms-smart-browse)

            ;; Track navigation
            ("C-c a C-n" . emms-next)
            ("C-c a C-p" . emms-previous)
            ("C-c a p" . emms-pause)
            ("C-c a C-s" . emms-stop)

            ;; Repeat/shuffle
            ("C-c a C-r" . emms-toggle-repeat-track)
            ("C-c a r" . emms-toggle-repeat-playlist)
            ("C-c a s" . farl-emms/shuffle-with-message)

            ;; Refreshing the emms cache
            ("C-c a c" . emms-player-mpd-update-all-reset-cache)

            ;; mpd related functions
            ("C-c a d" . mpd/start-music-daemon)
            ("C-c a q" . mpd/kill-music-daemon)
            ("C-c a u" . mpd/update-database))
   #+end_src

** Configuring

   This is where ~emms~ is configured to use ~mpd~.

   #+begin_src emacs-lisp :noweb-ref emms-vars
     :custom ((emms-seek-seconds 5)
              (emms-player-list '(emms-player-mpd))
              (emms-info-functions '(emms-info mpd))
              (emms-completing-read #'ivy-completing-read)
              (emms-player-mpd-server-name "localhost")
              (emms-player-mpd-server-port "6601"))
   #+end_src

   A couple environment variables are also set.

   #+begin_src emacs-lisp :noweb-ref emms-init
     (setenv "MPD_HOST" "localhost")
     (setenv "MPD_PORT" "6601")
   #+end_src

* Making Emacs a desktop environment
  :properties:
  :header-args: :noweb yes :noweb-ref exwm-init
  :end:

  Yes, Emacs is my *entire desktop environment*. You should probably remove this
  section if you don't plan to use Emacs as your desktop environment, but
  including it doesn't have any disadvantages either, since it only loads if an
  environment variable =_RUN_EXWM= exists, which it promptly unsets. Make a note
  of this when writing your =.xinitrc= or writing a =.desktop= file to load Emacs as
  your desktop environment. EXWM should replace the current window manager.

  #+begin_src emacs-lisp :noweb-ref no :tangle (locate-user-emacs-file "init.el")
    (use-package exwm
      :if (getenv "_RUN_EXWM")
      :ensure t
      :defer t
      :init
      (setenv "_RUN_EXWM")
      <<exwm-init>>
      :custom ((exwm-replace t)
               <<exwm-vars>>)
      <<exwm-hook>>
      <<exwm-binds>>)
  #+end_src

** Window management

   #+begin_src emacs-lisp
     (pdumper-require 'exwm)
     (pdumper-require 'exwm-randr)
     (pdumper-require 'exwm-config)
     (pdumper-require 'exwm-systemtray)
   #+end_src

*** Name EXWM buffers after the window title

    This was annoying when I first installed EXWM. Thankfully it's easy to fix.

    #+begin_src emacs-lisp
      (defun farl-exwm/name-buffer-after-window-title ()
        "Rename the current `exwm-mode' buffer after the X window's title."
        (exwm-workspace-rename-buffer exwm-title))
    #+end_src

    We hook setting the buffer name into when EXWM picks up a change in the
    window title, aptly titled =exwm-update-title-hook=. Other hooks are pulled
    into this block for a cleaner tangle.

    #+begin_src emacs-lisp :noweb-ref exwm-hook
      :hook ((exwm-update-title . farl-exwm/name-buffer-after-window-title)
             <<exwm-hooks>>)
    #+end_src

*** Configure floating window borders

    Uses the same color as my mode line, uses the same width as window dividers. For
    whatever reason, when changed via ~customize-set-variable~ these will break statup.

    #+begin_src emacs-lisp :noweb-ref exwm-init
      (setq exwm-floating-border-width window-divider-default-right-width
            exwm-floating-border-color (face-background 'mode-line))
    #+end_src

*** Getting a ~rofi~ equivalent

    Since I'm using Emacs as a window manager, I need something comparable to
    ~rofi~ so I can open X windows I haven't bound to keys. It will be bound
    elsewhere. I really don't want one named after +a project made by Nazis+ a
    Suckless project, but laziness makes that hard. At some point I will make my
    own function, preferably one considerably more minimalist.

    #+begin_src emacs-lisp
      (use-package dmenu
        :ensure t
        :defer t
        :custom (dmenu-prompt-string "s-x "))
    #+end_src

*** Mouse follows focus

    This is something I keep adding and removing repeatedly, into perpetuity. I
    really like this behavior, even in spite of the troubled history I have with
    this specific implementation.

    #+begin_src emacs-lisp
      (use-package exwm-mff
        :ensure t
        :defer t
        :hook (exwm-init . exwm-mff-mode))
    #+end_src

** Workspace configuration
*** Load all workspaces on startup

    I do not want to have to load all of them individually on my own...

    #+begin_src emacs-lisp :noweb-ref exwm-vars
      (exwm-workspace-number 10)
    #+end_src

*** Assign workspaces to monitors

    This section is only to ensure the proper workspaces are placed on the right
    monitors when my W541 is docked.

    #+begin_src emacs-lisp :noweb-ref exwm-vars
      (exwm-randr-workspace-monitor-plist '(0 "DP2-2"
                                            1 "DP2-1"
                                            2 "DP2-3"
                                            3 "DP2-2"
                                            4 "DP2-1"
                                            5 "DP2-3"
                                            6 "DP2-2"
                                            7 "DP2-1"
                                            8 "DP2-3"
                                            9 "DP2-2"))
    #+end_src

*** Assign programs to workspaces

    ...and also have some launch floating and/or without a mode line or borders.

    #+begin_src emacs-lisp :noweb-ref exwm-vars
      (exwm-manage-configurations '(((string= exwm-class-name "Steam")
                                     workspace 9)
                                    ((string= exwm-class-name "hl2_linux")
                                     floating-mode-line nil)
                                    ((string= exwm-class-name "TelegramDesktop")
                                     workspace 8)
                                    ((string= exwm-class-name "discord")
                                     workspace 7)
                                    ((or (string-match-p "libreoffice"
                                                         exwm-class-name)
                                         (string= exwm-class-name "MuseScore3")
                                         (string= exwm-class-name "Gimp"))
                                     workspace 6)
                                    ((string= exwm-title "Event Tester")
                                     floating-mode-line nil
                                     floating t)))
    #+end_src

*** Name workspaces a little more intuitively

    No clue why you have to do so much just to give workspaces names, but at
    least you can do it.

    #+begin_src emacs-lisp
      (defcustom farl-exwm/workspace-names '("Ôî•" "Ôî®" "Ôîß" "Ôî§" "Ôî£"
                                             "Ôî¶" "Ôñ¨" "Ôéí" "ÔãÜ" "ÔÜ∂")
        "The names assigned to workspaces through `exwm-workspace-index-map'."
        :tag "Workspace names"
        :group 'exwm
        :type 'list)

      (defun farl-exwm/workspace-index-map (index)
        "Return either a workspace name for a given INDEX or INDEX itself."
        (or (elt farl-exwm/workspace-names index) index))
    #+end_src

    The variable =exwm-workspace-index-map= points to the function used to
    determine the names of workspaces.

    #+begin_src emacs-lisp :noweb-ref exwm-vars
      (exwm-workspace-index-map #'farl-exwm/workspace-index-map)
    #+end_src

*** Show a list of workspaces in the echo area

    Because I now use so many workspaces, I need to be able to see what
    workspace I am currently on. This makes it easier to do that. It's rather
    buggy at times, but it does what it needs to do.

    #+begin_src emacs-lisp
      (use-package minibuffer-line
        :ensure t
        :defer t
        :init
        <<list-workspaces>>
        :custom-face (minibuffer-line ((t (:inherit default))))
        :custom (minibuffer-line-format '((:eval (farl-exwm/list-workspaces))))
        :hook ((exwm-init . minibuffer-line-mode)
               (exwm-workspace-switch . minibuffer-line--update)))
    #+end_src

    A function is used to grab the current state of the workspaces.

    #+begin_src emacs-lisp :noweb-ref list-workspaces
      (defun farl-exwm/list-workspaces ()
        "List EXWM workspaces."
        (exwm-workspace--update-switch-history)
        (elt exwm-workspace--switch-history
             (exwm-workspace--position exwm-workspace--current)))
    #+end_src

** Multi-head configuration

   Thankfully, EXWM comes with hooks to handle when monitors are connected and
   disconnected, so I can do monitor configuration entirely in Emacs Lisp. I
   have two laptops: a ThinkPad X230 and a ThinkPad W541. Each has different
   displays and is used for different purposes. Due to now not-so-recent updates
   to Arch Linux and the fact that the original code here was a dumpster fire,
   this section had to be reworked.

*** Getting the currently connected monitors

    The first thing to do is set up a function to return a list of currently
    connected monitors.

    #+begin_src emacs-lisp
      (defun get-connected-monitors ()
        "Return a list of the currently connected monitors."
        (split-string
         (shell-command-to-string
          "xrandr | grep ' connected ' | awk '{print $1}'")))
    #+end_src

*** Configuring monitor arrangement on my X230

    This one is straightforward. I never do any kind of split-monitor setup on
    my ThinkPad X230, so every monitor looks over the same screen.

    #+begin_src emacs-lisp
      (defun display-setup-x230 ()
        "Set up the connected monitors on a ThinkPad X230."
        (let ((monitors (get-connected-monitors))
              (possible '("LVDS1"
                          "VGA1")))
          (dolist (monitor possible)
            (if (member monitor monitors)
                (start-process "xrandr" nil "xrandr"
                               "--output" monitor
                               "--mode" "1366x768"
                               "--pos" "0x0")
              (start-process "xrandr" nil "xrandr"
                             "--output" monitor
                             "--off")))))
    #+end_src

*** Configuring monitor arrangement on my W541

    This is where it gets really fun. This ThinkPad /does/ get docked, so I handle
    very different outputs.

    #+begin_src emacs-lisp
      (defun display-setup-w541 ()
        "Set up the connected monitors on a ThinkPad W541."
        (let* ((connected-monitors (get-connected-monitors))
               (docked-p (member "DP2-1" connected-monitors))
               (possible-monitors '("eDP1"
                                    "VGA1"
                                    "DP2-1"
                                    "DP2-2"
                                    "DP2-3")))
          (dolist (monitor possible-monitors)
            (if (and (member monitor connected-monitors)
                     (not (and docked-p (string= "eDP1" monitor))))
                (progn
                  (start-process "xrandr" nil "xrandr"
                                 "--output" monitor
                                 ;; Any enabled monitor needs a resolution.
                                 "--mode" "1920x1080"
                                 ;; DP2-1 and DP2-3 are rotated.
                                 "--rotate" (if (string= "DP2-1" monitor)
                                                "left"
                                              (if (string= "DP2-3" monitor)
                                                  "right"
                                                "normal"))
                                 ;; Every enabled monitor needs a position.
                                 "--pos" (if (string-match-p "1" monitor)
                                             "0x0"
                                           (if (string= monitor "DP2-2")
                                               "1080x0"
                                             "3000x0")))
                  ;; Setting a monitor as primary occurs outside enabling it.
                  ;; This is due to how `start-process' takes arguments.
                  (when (or (string= "DP2-2" monitor)
                            (string= "eDP1" monitor))
                    (start-process "xrandr" nil "xrandr"
                                   "--output" monitor
                                   "--primary")))
              (start-process "xrandr" nil "xrandr"
                             "--output" monitor
                             "--off")))))
    #+end_src

*** Configuring peripherals while docked

    Because I use a dock on my W541, there are some things I need to do
    alongside setting up my monitors.

    #+begin_src emacs-lisp
      (defun peripheral-setup ()
        "Configure peripherals I connect to my dock."
        ;; Trackball
        (let ((trackball-id (shell-command-to-string
                             (concat "xinput | grep ELECOM | head -n 1 "
                                     "| sed -r 's/.*id=([0-9]+).*/\\1/' | "
                                     "tr '\\n' ' '"))))
          (start-process-shell-command
           "Trackball Setup" nil (concat "xinput set-prop " trackball-id
                                         "'libinput Button Scrolling Button' "
                                         "10"))
          (start-process-shell-command
           "Trackball Setup" nil (concat "xinput set-prop " trackball-id
                                         "'libinput Scroll Method Enabled' "
                                         "0 0 1"))
          (start-process-shell-command
           "Trackball Setup" nil (concat "xinput set-button-map " trackball-id
                                         "1 2 3 4 5 6 7 8 9 2 1 2")))
        ;; Keyboard
        (start-process "Keyboard Setup" nil "setxkbmap"
                       "-option" "ctrl:nocaps"))
    #+end_src

*** Bringing it all together

    Finally, I can make my generic display-and-dock setup function.

    #+begin_src emacs-lisp
      (defun display-and-dock-setup ()
        "Configure displays and dock if applicable."
        (interactive)
        (unless (get-process "Monitor Settings")
          (if (member "LVDS1" (get-connected-monitors))
              (display-setup-x230)
            (progn
              (display-setup-w541)
              (peripheral-setup)))))
    #+end_src

    Every time EXWM detects a change in the monitors connected or active, this
    function should be called, so it's hooked to =exwm-randr-screen-change-hook=.

    #+begin_src emacs-lisp :noweb-ref exwm-hooks
      (exwm-randr-screen-change . display-and-dock-setup)
    #+end_src

** X applications
*** GIMP

    Until GIMP's functionality gets merged into Emacs, guess I'm stuck with it.

    #+begin_src emacs-lisp
      (defun run-gimp ()
        "Start GIMP."
        (interactive)
        (start-process "GIMP" nil "gimp"))
    #+end_src

*** Steam

    Gaming is possible with EXWM, if you run games windowed. I used to run it
    floating, but honestly just having it tile is so much easier to manage.

    #+begin_src emacs-lisp
      (defun run-steam ()
        "Start Steam."
        (interactive)
        (start-process "Steam" nil "steam"))
    #+end_src

*** Firefox

    Firefox has some unique abilities when it comes to how to make windows
    behave which work better for me. I don't use tabs, and I don't want
    anything to do with them, and Firefox lets me hide the tab bar and force all
    tabs to actually open as new windows. It's like Suckless Surf, but +not made
    by Nazis+ orders of magnitude faster and more comfortable.

    #+begin_src emacs-lisp
      (defun run-firefox ()
        "Start Firefox."
        (interactive)
        (start-process "Firefox" nil "firefox"))
    #+end_src

*** Discord

    It's kinda trashy but my friends use it.

    #+begin_src emacs-lisp
      (defun run-discord ()
        "Start Discord."
        (interactive)
        (start-process "Discord" nil "discord"))
    #+end_src

*** Telegram

    Another trashy messenger my friends use.

    #+begin_src emacs-lisp
      (defun run-telegram ()
        "Start Telegram."
        (interactive)
        (start-process "Telegram" nil "telegram-desktop"))
    #+end_src

*** MuseScore

    I haven't figured out how to engrave in Emacs, so for now...

    #+begin_src emacs-lisp
      (defun run-musescore ()
        "Start MuseScore."
        (interactive)
        (start-process "MuseScore" nil "musescore"))
    #+end_src

*** LibreOffice

    Shame me all you want.

    #+begin_src emacs-lisp
      (defun run-libreoffice ()
        "Start LibreOffice."
        (interactive)
        (start-process "LibreOffice" nil "libreoffice"))
    #+end_src

*** Transmission

    #+begin_src emacs-lisp
      (defun run-transmission ()
        "Start Transmission."
        (interactive)
        (start-process "Transmission" nil "transmission-gtk"))
    #+end_src

** DE components
*** System package management

    This one is a pleasant surprise to have honestly. Having Emacs handle system
    packages as well as its own makes life a million times easier. Since I use
    ~yay~ on Arch, I configure an entry for it and use it if it's installed.

    #+begin_src emacs-lisp
      (use-package system-packages
        :ensure t
        :defer t
        :init
        (when (executable-find "yay")
          (pdumper-require 'system-packages)
          (add-to-list 'system-packages-supported-package-managers
                       '(yay .
                             ((default-sudo . nil)
                              (install . "yay -S")
                              (search . "yay -Ss")
                              (uninstall . "yay -Rs")
                              (update . "yay -Syu")
                              (clean-cache . "yay -Sc")
                              (log . "car /var/log/pacman.log")
                              (get-info . "yay -Qi")
                              (get-info-remote . "yay -Si")
                              (list-files-provided-by . "yay -Ql")
                              (verify-all-packages . "yay -Qkk")
                              (verify-all-dependencies . "yay -Dk")
                              (remove-orphaned . "yay -Rns $(yay -Qtdq)")
                              (list-installed-packages . "yay -Qe")
                              (list-installed-packages-all . "yay -Q")
                              (list-dependencies-of . "yay -Qi")
                              (noconfirm . "--noconfirm"))))
          (setq system-packages-use-sudo nil
                system-packages-package-manager 'yay))
        :custom (system-packages-noconfirm t)
        :bind (("C-c p i" . system-packages-install)
               ("C-c p e" . system-packages-ensure)
               ("C-c p u" . system-packages-update)
               ("C-c p r" . system-packages-uninstall)
               ("C-c p o" . system-packages-remove-orphaned)
               ("C-c p c" . system-packages-clean-cache)
               ("C-c p l" . system-packages-log)
               ("C-c p s" . system-packages-search)
               ("C-c p g" . system-packages-get-info)
               ("C-c p d" . system-packages-list-dependencies-of)
               ("C-c p f" . system-packages-list-files-provided-by)
               ("C-c p p" . system-packages-list-installed-packages)
               ("C-c p f" . system-packages-verify-all-dependencies)
               ("C-c p v" . system-packages-verify-all-packages)))
    #+end_src

*** ~desktop-environment-mode~

    Previously I had to define a lot of functions to do these things, now I just
    change settings within ~desktop-environment-mode~.

    The way ~desktop-environment-mode~ passes its keys through EXWM's mode is one
    of two options: either the keys are directly bound to =exwm-mode-map=, or the
    keys are added to EXWM's prefix key set. I prefer the latter, because it
    means the keys associated with ~desktop-environment-mode~ will be properly
    unbound when the mode is toggled off.

    #+begin_src emacs-lisp
      (use-package desktop-environment
        :ensure t
        :defer t
        :init
        <<de-init>>
        :custom ((desktop-environment-update-exwm-global-keys :prefix)
                 <<de-vars>>)
        :hook (exwm-init . desktop-environment-mode)
        :bind (:map desktop-environment-mode-map
               <<de-binds>>))
    #+end_src

**** Brightness adjustment

     This one is the simplest: all I needed to do was change the increment and
     decrement values.

     #+begin_src emacs-lisp :noweb-ref de-vars
       (desktop-environment-brightness-normal-increment "5%+")
       (desktop-environment-brightness-normal-decrement "5%-")
     #+end_src

**** Volume adjustment

     The only things I really don't like about how ~desktop-environment~'s volume
     controlling is ~desktop-environment-toggle-mute~, which gives way too much
     output when you mute or unmute the speakers or microphone, so I set up
     basic scripts to give much more concise output.

     #+begin_src emacs-lisp :noweb-ref de-vars
       (desktop-environment-volume-toggle-command
        (concat "[ \"$(amixer set Master toggle | grep off)\" ] "
                "&& echo Volume is now muted. | tr '\n' ' ' "
                "|| echo Volume is now unmuted. | tr '\n' ' '"))
       (desktop-environment-volume-toggle-microphone-command
        (concat "[ \"$(amixer set Capture toggle | grep off)\" ] "
                "&& echo Microphone is now muted. | tr '\n' ' ' "
                "|| echo Microphone is now unmuted | tr '\n' ' '"))
     #+end_src

**** Lock screen

     Haha yes, this is very long and very very stupid.

     #+begin_src emacs-lisp :noweb-ref de-vars
       (desktop-environment-screenlock-command
        (concat "i3lock -nmk --color=000000 --timecolor=ffffffff "
                " --datecolor=ffffffff --wrongcolor=ffffffff "
                "--ringcolor=00000000 --insidecolor=00000000 "
                "--keyhlcolor=00000000 --bshlcolor=00000000 "
                "--separatorcolor=00000000 --ringvercolor=00000000 "
                "--insidevercolor=00000000 --linecolor=00000000 "
                "--ringwrongcolor=00000000 --insidewrongcolor=00000000 "
                "--timestr=%H:%M --datestr='%a %d %b' --time-font=Iosevka "
                "--date-font=Iosevka --wrong-font=Iosevka --timesize=128 "
                "--datesize=64 --wrongsize=32 --time-align 0 --date-align 0 "
                "--wrong-align 0 --indpos=-10:-10 --timepos=200:125 "
                "--datepos=200:215 --wrongpos=200:155 --locktext='' "
                "--lockfailedtext='' --noinputtext='' --veriftext='' "
                "--wrongtext='WRONG' --force-clock --radius 1 --ring-width 1 "))
     #+end_src

     I also have to bind an extra key for this function.

     #+begin_src emacs-lisp :noweb-ref de-binds
       ("<XF86ScreenSaver>" . desktop-environment-lock-screen)
     #+end_src

**** Screenshots

     This one was the least straightforward because the way it's implemented by
     ~desktop-environment~ is *SUPER* wonky. Here are the binds:

     #+begin_src emacs-lisp :noweb-ref de-binds
       ("<print>" . farl-de/desktop-environment-screenshot-part-clip)
       ("<S-print>" . farl-de/desktop-environment-screenshot-clip)
       ("<C-print>" . farl-de/desktop-environment-screenshot-part)
       ("<C-S-print>" . farl-de/desktop-environment-screenshot)
     #+end_src

     First, I set what directory to store screenshots in.

     #+begin_src emacs-lisp :noweb-ref de-vars
       (desktop-environment-screenshot-directory "~/screenshots")
     #+end_src

     Then, I can set the commands for taking a full or partial screenshot and
     saving it to a file.

     #+begin_src emacs-lisp :noweb-ref de-vars
       (desktop-environment-screenshot-command
        "FILENAME=$(date +'%Y-%m-%d-%H:%M:%S').png && maim $FILENAME")
       (desktop-environment-screenshot-partial-command
        "FILENAME=$(date +'%Y-%m-%d-%H:%M:%S').png && maim -s $FILENAME")
     #+end_src

     The functions which ~desktop-environment~ comes with are kinda garbage, so I
     made my own to replace them.

     #+begin_src emacs-lisp :noweb-ref de-init
       (defun farl-de/desktop-environment-screenshot ()
         "Take a screenshot and store it in a file."
         (interactive)
         (desktop-environment-screenshot)
         (message "Screenshot saved in ~/screenshots."))

       (defun farl-de/desktop-environment-screenshot-part ()
         "Take a capture of a portion of the screen and store it in a file."
         (interactive)
         (desktop-environment-screenshot-part)
         (message "Screenshot saved in ~/screenshots."))

       (defun farl-de/desktop-environment-screenshot-clip ()
         "Take a screenshot and put it in the clipboard."
         (interactive)
         (shell-command
          (concat desktop-environment-screenshot-command
                  " && xclip $FILENAME -selection clipboard "
                  "-t image/png &> /dev/null && rm $FILENAME"))
         (message "Screenshot copied to clipboard."))

       (defun farl-de/desktop-environment-screenshot-part-clip ()
         "Take a shot of a portion of the screen and put it in the clipboard."
         (interactive)
         (shell-command
          (concat desktop-environment-screenshot-partial-command
                  " && xclip $FILENAME -selection clipboard "
                  "-t image/png &> /dev/null && rm $FILENAME"))
         (message "Screenshot copied to clipboard."))
     #+end_src

*** Setting the wallpaper

    I've been working on [[https://github.com/farlado/emacs-wallpaper][an easy way to configure wallpapers]] which makes for way
    less hassle. It only relies on ~feh~ as a backend for applying wallpapers, so
    if you use Emacs as a daemon it can manage your wallpapers even if it isn't
    the window manager.

    #+begin_src emacs-lisp
      (use-package wallpaper
        :load-path "lisp/wallpaper"
        :defer t
        :hook ((exwm-randr-screen-change . wallpaper-set-wallpaper)
               (exwm-init . wallpaper-cycle-mode)))
    #+end_src

*** Monitor settings

    Calling ~arandr~ to adjust monitors is useful when I am preparing to present
    something using my computer or need to adjust how monitors are set up in a
    unique way that isn't a preset from my dotfiles.

    #+begin_src emacs-lisp
      (defun monitor-settings ()
        "Open arandr to configure monitors."
        (interactive)
        (start-process "Monitor Settings" nil "arandr"))
    #+end_src

*** Network settings

    This one uses two windows: one to open the NetworkManager connection editor,
    and another to list WiFi networks nearby.

    #+begin_src emacs-lisp
      (defun network-settings ()
        "Open a NetworkManager connection editor."
        (interactive)
        (start-process "Network Settings" nil "nm-connection-editor")
        (async-shell-command "nmcli dev wifi list" "*Wi-Fi Networks*"))
    #+end_src

*** Volume mixer

    For when you need to do volume mixing.

    #+begin_src emacs-lisp
      (defun volume-settings ()
        "Open pavucontrol to adjust volume."
        (interactive)
        (start-process "Volume Mixer" nil "pavucontrol"))
    #+end_src

*** Audio loop-back

    Used when I play Jackbox Party Pack with friends. Also set up to launch
    ~pavucontrol~ to set up which programs to pass through to Discord.

    #+begin_src emacs-lisp
      (defun audio-loopback ()
        "Loop desktop audio into a null sink alongside the primary input."
        (interactive)
        (dolist (command
                 '(;; Create null sink `loop'
                   "load-module module-null-sink sink_name=loop"
                   "update-sink-proplist loop device.description=loop"
                   ;; Create null sink `out'
                   "load-module module-null-sink sink_name=out"
                   "update-sink-proplist out device.description=out"
                   ;; Loop `loop' to primary output
                   "load-module module-loopback source=loop.monitor"
                   ;; Pipe it into `out'
                   "load-module module-loopback source=loop.monitor sink=out"
                   ;; Loop primary input into `out'
                   "load-module module-loopback sink=out"))
          (shell-command (concat "pacmd " command)))
        ;; Run `pavucontrol' and then unload the modules after it completes
        (start-process-shell-command
         "Audio Loop" nil (concat "pavucontrol;"
                                  "pacmd unload-module module-null-sink;"
                                  "pacmd unload-module module-loopback")))
    #+end_src

*** Keyboard layout selection

    It's [[https://github.com/farlado/emacs-xkb][its own package]] now. Check it out, I think it's pretty nice.

    #+begin_src emacs-lisp
      (use-package xkb
        :load-path "lisp/xkb"
        :defer t
        :custom ((xkb-cycle-layouts '("us"
                                      "epo"
                                      "de"))
                 (xkb-options '("ctrl:nocaps")))
        :hook (exwm-init . xkb-cycle-mode))
    #+end_src

*** Shutting down

    #+begin_src emacs-lisp
      (defun shut-down--computer ()
        "Shut down the computer."
        (shell-command "shutdown now"))

      (defun shut-down-computer ()
        "Shut down the computer."
        (interactive)
        (add-hook 'kill-emacs-hook #'shut-down--computer)
        (save-buffers-kill-emacs)
        (remove-hook 'kill-emacs-hook #'shut-down--computer))
    #+end_src

    This function is globally bound to =C-x C-M-c=. Other binds are pulled into
    here for a cleaner end result upon tangling.

    #+begin_src emacs-lisp :noweb-ref exwm-binds
      :bind (("C-x C-M-c" . shut-down-computer)
             <<exwm-global-binds>>
             :map exwm-mode-map
             <<exwm-mode-binds>>)
    #+end_src

*** Rebooting

    #+begin_src emacs-lisp
      (defun reboot--computer ()
        "Run the reboot command."
        (shell-command "reboot"))

      (defun reboot-computer ()
        "Reboot the computer."
        (interactive)
        (add-hook 'kill-emacs-hook #'reboot--computer)
        (save-buffers-kill-emacs)
        (remove-hook 'kill-emacs-hook #'reboot--computer))
    #+end_src

    This function is globally bound to =C-x C-M-r=.

    #+begin_src emacs-lisp :noweb-ref exwm-global-binds
      ("C-x C-M-r" . reboot-computer)
    #+end_src

*** Suspending

    #+begin_src emacs-lisp
      (defun suspend-computer ()
        (interactive)
        (when (yes-or-no-p "Really suspend? ")
          (shell-command "systemctl suspend -i")))
    #+end_src

    This function is globally bound to =C-x C-M-s=.

    #+begin_src emacs-lisp :noweb-ref exwm-global-binds
      ("C-x C-M-s" . suspend-computer)
    #+end_src

** Keybindings
*** Global binds to use across everything

    Since I'm very lazy and don't feel like writing a whole bunch of lambdas for
    multiple workspaces, presented here are instead some ~mapcar~ calls, like the
    one in [[https://github.com/ch11ng/exwm/wiki/Configuration-Example][this example]].

    #+begin_src emacs-lisp :noweb-ref exwm-vars
      (exwm-input-global-keys `(;; Switching workspace focus
                                ;; s-1 for 1, s-2 for 2, etc...
                                ,@(mapcar
                                   (lambda (i)
                                     `(,(kbd (format "s-%d" (% (1+ i) 10)))
                                       .
                                       (lambda ()
                                         (interactive)
                                         (exwm-workspace-switch-create ,i))))
                                   (number-sequence 0 9))

                                ;; Switching window to a workspace
                                ;; This was annoying to get working
                                ;; s-! for 1, s-@ for 2, etc...
                                ,@(mapcar
                                   (lambda (i)
                                     `(,(kbd (format "s-%s" (nth i '("!"
                                                                     "@"
                                                                     "#"
                                                                     "$"
                                                                     "%"
                                                                     "^"
                                                                     "&"
                                                                     "*"
                                                                     "("
                                                                     ")"))))
                                       .
                                       (lambda ()
                                         (interactive)
                                         (exwm-workspace-move-window ,i))))
                                   (number-sequence 0 9))

                                ;; Toggle how input is sent to X windows
                                ([?\s-q] . exwm-input-toggle-keyboard)

                                ;; Window size adjustment
                                (,(kbd "C-s-w") . shrink-window)
                                (,(kbd "C-s-s") . enlarge-window)
                                (,(kbd "C-s-a") . shrink-window-horizontally)
                                (,(kbd "C-s-d") . enlarge-window-horizontally)

                                ;; Opening programs
                                ([XF86Calculator] . calc)
                                ([s-return]       . vterm)
                                ([?\s-g]          . run-gimp)
                                ([?\s-s]          . run-steam)
                                ([?\s-f]          . run-firefox)
                                ([?\s-d]          . run-discord)
                                ([?\s-t]          . run-telegram)
                                ([?\s-m]          . run-musescore)
                                ([?\s-b]          . run-libreoffice)
                                ([?\s-o]          . run-transmission)
                                ([?\s-r]          . monitor-settings)
                                ([?\s-n]          . network-settings)
                                ([?\s-v]          . volume-settings)

                                ;; Other desktop environment things
                                ([?\s-x]           . dmenu)
                                ([s-tab]           . audio-loopback)
                                ([?\s-w]           . xkb-set-layout)

                                ;; Controlling EMMS
                                ([XF86AudioNext] . emms-next)
                                ([XF86AudioPrev] . emms-previous)
                                ([XF86AudioPlay] . emms-pause)
                                ([XF86AudioStop] . emms-stop)))
    #+end_src

*** Emacs key bindings in X windows

    This is super nice, because I love these key bindings and they are just
    intuitive to me, and now they can carry over safely to other programs.

    #+begin_src emacs-lisp :noweb-ref exwm-vars
      (exwm-input-simulation-keys `(;; Navigation
                                    ([?\M-<] . [C-home])
                                    ([?\M->] . [C-end])
                                    ([?\C-a] . [home])
                                    ([?\C-e] . [end])
                                    ([?\C-v] . [next])
                                    ([?\M-v] . [prior])

                                    ([?\C-b] . [left])
                                    ([?\C-f] . [right])
                                    ([?\C-p] . [up])
                                    ([?\C-n] . [down])

                                    ([?\M-b] . [C-left])
                                    ([?\M-f] . [C-right])
                                    ([?\M-n] . [C-down])
                                    ([?\M-p] . [C-up])

                                    ;; Selecting via navigation
                                    (,(kbd "C-S-b") . [S-left])
                                    (,(kbd "C-S-f") . [S-right])
                                    (,(kbd "C-S-n") . [S-down])
                                    (,(kbd "C-S-p") . [S-up])

                                    ;; Copy/Paste
                                    ([?\C-w] . [?\C-x])
                                    ([?\M-w] . [?\C-c])
                                    ([?\C-y] . [?\C-v])
                                    ([?\C-s] . [?\C-f])
                                    ([?\C-\/] . [?\C-z])

                                    ;; Other
                                    ([?\C-d] . [delete])
                                    ([?\M-d] . [C-delete])
                                    ([?\C-k] . [S-end delete])
                                    ([?\C-g] . [escape])))
    #+end_src

    Key sequences cannot be defined in =exwm-input-simulation-keys=, so they are
    functions which are called.

    #+begin_src emacs-lisp
      (defun farl-exwm/C-s ()
        "Pass C-s to the EXWM window."
        (interactive)
        (execute-kbd-macro (kbd "C-q C-s")))

      (defun farl-exwm/C-k ()
        "Pass C-k to the EXWM window."
        (interactive)
        (execute-kbd-macro (kbd "C-q C-k")))
    #+end_src

    These functions are bound to keys in =exwm-mode-map=.

    #+begin_src emacs-lisp :noweb-ref exwm-mode-binds
      ("C-x C-s" . farl-exwm/C-s)
      ("C-c C-l" . farl-exwm/C-k)
    #+end_src

*** Send a key verbatim more easily

    This means there's one less key needed to send a verbatim key to an EXWM
    buffer. It is obviously bound in =exwm-mode-map=.

    #+begin_src emacs-lisp :noweb-ref exwm-mode-binds
      ("C-q" . exwm-input-send-next-key)
      ("C-c C-q" . nil)
    #+end_src

*** Inhibit keys I don't use

    This removes the following from =exwm-mode-map=:
    - Toggling fullscreen
    - Toggling floating
    - Toggling hiding
    - Toggling the mode line

    #+begin_src emacs-lisp :noweb-ref exwm-mode-binds
      ("C-c C-f" . nil)
      ("C-c C-t C-f" . nil)
      ("C-c C-t C-v" . nil)
      ("C-c C-t C-m" . nil)
    #+end_src

** On startup
*** Make Emacs start fullscreen

    This makes Emacs startup look a lot more natural.

    #+begin_src emacs-lisp
      (set-frame-parameter nil 'fullscreen 'fullboth)
    #+end_src

*** XDG compliance and WM settings

    I have to set a few environment variables for the sake of compliance with
    various specifications, most notably the XDG Base Directory Specification.
    Also in this block I set an environment variable signaling to Java
    applications that the window manager is not a reparenting window manager.

    #+begin_src emacs-lisp :tangle no
      (setenv "XDG_CURRENT_DESKTOP" "emacs")
      (setenv "GTK2_RC_FILES" (user-config-file "gtk-2.0/gtkrc"))
      (setenv "QT_QPA_PLATFORMTHEME" "gtk2")
      (setenv "_JAVA_AWT_WM_NONREPARENTING" "1")
    #+end_src

*** Disable screen blanking

    I don't need my laptop's screen shutting off just because I'm sitting and
    watching a video with the laptop idle too long.

    #+begin_src emacs-lisp :tangle no
      (start-process "Disable Blanking" nil "xset"
                     "s" "off" "-dpms")
    #+end_src

*** Keyboard configuration

    This block sets the keyboard layout to US and give Caps Lock the
    functionality of Control. I was hesitant to do this at first, but it's
    significantly more comfortable. I almost never used caps lock as it is,
    given my keyboards have no indicator for it on my laptops, but this gives me
    a much easier way to do commands without shifting my hand too far. Ideally,
    however, I configure my keyboards so that this setting is nothing more than
    an afterthought.

    #+begin_src emacs-lisp :tangle no
      (start-process "Keyboard Layout" nil "setxkbmap"
                     "us" "-option" "ctrl:nocaps")
    #+end_src

*** Disable the trackpad

    This thing is disgusting, and I prefer trackpoints way more.

    #+begin_src emacs-lisp :tangle no
      (start-process "Trackpad Setup" nil "xinput"
                     "disable" (shell-command-to-string
                                (concat "xinput | grep Synap | head -n 1 | "
                                        "sed -r 's/.*id=([0-9]+).*/\\1/' | "
                                        "tr '\n' ' ' | sed 's/ //'")))
    #+end_src

*** Start the compositor

    I don't need it, but having basic compositing is very nice.

    #+begin_src emacs-lisp :tangle no
      (start-process "Compositor" nil "xcompmgr")
    #+end_src

*** Set fallback cursor

    Some X windows will have weird cursors if this isn't done.

    #+begin_src emacs-lisp :tangle no
      (start-process "Fallback Cursor" nil "xsetroot"
                     "-cursor_name" "left_ptr")
    #+end_src

*** Banish the mouse

    I've always been mixed on this behavior but it seems like a good idea.

    #+begin_src emacs-lisp
      (start-process "Mouse banisher" nil "xbanish")
    #+end_src

*** Start EXWM

    #+begin_src emacs-lisp :tangle no
      (exwm-enable)
      (exwm-config-ido)
      (exwm-randr-enable)
      (exwm-systemtray-enable)
    #+end_src

** On logout
   :properties:
   :header-args: :noweb-ref on-logout
   :end:

   When exiting, these are things I want done.

   #+begin_src emacs-lisp :noweb yes :noweb-ref exwm-init
     (defun farl-exwm/on-logout ()
       "Run this when logging out as part of `kill-emacs-hook'."
       <<on-logout>>)
   #+end_src

   This is hooked into when Emacs is killed.

   #+begin_src emacs-lisp :noweb-ref exwm-hooks
     (kill-emacs . farl-exwm/on-logout)
   #+end_src

*** Black out the root window

    This way, it looks good when exiting Emacs.

    #+begin_src emacs-lisp
      (shell-command "hsetroot -solid '#000000'")
    #+end_src

