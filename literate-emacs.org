#+TITLE: Farlado's Illiterate GNU Emacs
#+SUBTITLE: A far-from-sane literate Emacs configuration
#+LANGUAGE: en
#+STARTUP: hideblocks
#+OPTIONS: num:2 toc:2
#+PROPERTY: header-args :tangle (concat user-emacs-directory "init.el")

#+BEGIN_QUOTE
I use Emacs, which might be thought of as a thermonuclear word processor.

-- Neal Stephenson, /In the Beginning... was the Command Line/
#+END_QUOTE
#+BEGIN_QUOTE
Overall, I think text editing is a solved problem. Text editors are like wine. The older the better. You do not want a shiny new text editor. You want the text editor that has been around long enough and used by enough geeks that every conceivable pattern of manipulating symbols on the screen has been thought of, and crystallized into a re-usable pack.

-- [[https://blog.vivekhaldar.com/post/31970017734/new-frontiers-in-text-editing][Vivek Haldar]]
#+END_QUOTE
#+BEGIN_QUOTE
Personally, I feel inspired whenever I open Emacs. Like a craftsman entering his workshop, I feel a realm of possibility open before me. I feel the comfort of an environment that has evolved over time to fit me perfectly â€“ an assortment of packages and keybindings which help me bring ideas to life day after day.

-- [[https://www.braveclojure.com/basic-emacs/][Daniel Higginbotham]]
#+END_QUOTE
#+BEGIN_QUOTE
an infinite number of monkeys typing into GNU emacs would never make a good program

-- [[https://www.kernel.org/doc/html/v4.10/process/coding-style.html][Linus Torvalds]]
#+END_QUOTE

* About this configuration
This file is an attempt at a literate GNU Emacs (henceforth "Emacs") configuration. Admittedly, much of the "documentation" in here is more commentary I provide about my choices and personal feelings about certain things in Emacs based on my admittedly very limited opinion of the program than honest-to-god documentation of what this file contains. Regardless, the idea is that this file, when tangled, generates everything in my git repository, from ~LICENSE~ to ~init.el~. I would /highly/ recommend you *NOT* try to read the ~init.el~ file itself. It's a jungle, especially since all of the commentary regarding the configuration is in this file and not in ~init.el~.

** Okay, that's pretty neat. Why though?
The answer is rather simple. Before I used a fully literate, I had an ~init.el~ which tangled blocks from a ~config.org~ on the fly (read: on startup). It turns out this was abysmally slow, making for a startup time of around 4.5 seconds when loading into my desktop environment. Tangling blocks from a ~literate-emacs.org~ into an ~init.el~ cuts this time by about a third, around 2.8 seconds to load into my desktop environment. This also comes with the advantage of being a hub for /all/ things related to my Emacs configuration, where previously I had to check both ~init.el~ and ~config.org~ when I thought I might have changed something for the worse.

** Installation
/Note: these instructions are for users of GNU/Linux or other *NIX systems. These instructions may not apply for users of Windows or macOS./
1) Clone the repo into your home directory as ~.emacs.d~.
2) Make sure you have all the right dependencies. See below for more details.
3) If using Emacs as a desktop environment, it may take a couple restarts to work right.

** Dependencies
Everything has different dependencies so make sure you have what you need. The easy route to getting all these dependencies installed and configured is to deploy [[https://github.com/farlado/dotfiles][my dotfiles]]:
#+BEGIN_SRC sh :tangle no
  sh -c "$(curl https://raw.githubusercontent.com/farlado/dotfiles/master/.config/deploy/deploy)"
#+END_SRC

*** For EXWM
|----------------------+--------------------------------------------|
| ~EXWM~ depends on...   | which is used for...                       |
|----------------------+--------------------------------------------|
| ~xorg~                 | obvious reasons                            |
| ~xbanish~              | hiding the mouse cursor                    |
| ~xcompmgr~             | compositor                                 |
| ~arandr~               | monitor configuration                      |
| ~nm-connection-editor~ | network configuration                      |
| ~pavucontrol~          | volume mixing                              |
| ~firefox~              | browsing the web                           |
| ~libreoffice~          | editing unfriendly documents               |
| ~gimp~                 | editing images (Emacs can't do this sadly) |
| ~musescore~            | editing music                              |
| ~telegram~             | crappy messenger                           |
| ~discord~              | crappier messenger                         |
| ~steam~                | games platform                             |
|----------------------+--------------------------------------------|

*** For ~desktop-environment~
|-----------------------------------+--------------------------------------|
| ~desktop-environment~ depends on... | which is used for...                 |
|-----------------------------------+--------------------------------------|
| ~alsa-utils~                        | volume adjustment                    |
| ~brightnessctl~                     | laptop backlight adjustment          |
| ~maim~                              | screenshots                          |
| ~xclip~                             | copying screenshots to the clipboard |
| ~i3lock-color~                      | lock screen                          |
|-----------------------------------+--------------------------------------|

*** Other
|-------------------+---------------------+------------------------------------|
| Emacs uses...     | which depends on... | which is used for...               |
|-------------------+---------------------+------------------------------------|
| ~EMMS~              | ~mpd~                 | playing music                      |
|-------------------+---------------------+------------------------------------|
| ~nov~               | ~ebook-tools~         | opening epub files                 |
|-------------------+---------------------+------------------------------------|
| ~graphviz-dot-mode~ | ~graphviz~            | process dot files                  |
|-------------------+---------------------+------------------------------------|
| ~flyspell-mode~     | ~aspell~              | spell checking                     |
|-------------------+---------------------+------------------------------------|
| ~wttrin~            | ~curl~                | get weather data from the internet |
|-------------------+---------------------+------------------------------------|
| ~sudo-edit~         | ~sudo~                | duh                                |
|-------------------+---------------------+------------------------------------|
| ~flycheck~          | ~pylint~              | Python syntax checking             |
|-------------------+---------------------+------------------------------------|
| ~company~           | ~jedi~                | Python autocomplete                |
|-------------------+---------------------+------------------------------------|
| ~haskell-mode~      | ~stack~               | everything about Haskell           |
|-------------------+---------------------+------------------------------------|

** License
Because I +am a lazy piece of shit who doesn't like long licenses+ do not think much harm could come from using a pushover license for an Emacs configuration, I am publishing this literate Emacs configuration under the WTFPL.
#+BEGIN_SRC text :tangle LICENSE
  DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
  Version 2, December 2004

  Copyright (c) 2019-20 Farlado

  Everyone is permitted to copy and distribute verbatim or modified
  copies of this license document, and changing it is allowed as long
  as the name is changed.

             DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

   0. You just DO WHAT THE FUCK YOU WANT TO.
#+END_SRC

** Files to ignore
Like mentioned above, this file is supposed to tangle into everything in my git repository. That includes ~.gitignore~
#+BEGIN_SRC text :tangle .gitignore
  .last-package-update-day
  auto-save-list
  dmenu-items
  smex-items
  nov-places
  transient
  ido.last
  recentf
  eshell
  tramp
  elpa
  emms
  url
#+END_SRC

* Giving ~init.el~ a header
In order to make the file look at least somewhat decent, and to warn those who are unfortunate enough to think they'll just mosey on into ~init.el~ if they want to understand the config, we create a header that tells people the reality of the file.
#+BEGIN_SRC emacs-lisp
  ;;; init.el --- Initializing Farlado's Illiterate GNU Emacs

  ;; This file is not part of GNU Emacs.
  
  ;;; Commentary:

  ;; This file has been automatically generated from `literate-emacs.org'.
  ;; If you don't have a copy of that file, it is best not to use this file!
  ;; All relevant commentary is in `literate-emacs.org', not here.
  ;; There may not be any comments past this point.
  ;; Abandon all hope, ye who enter here.
  
  ;;; Code:
#+END_SRC

* Making Emacs start quickly and smoothly
Even with the "small" amount I ask of Emacs, it's a lot of beef to start up as fast as I demand it start up. This is, of course, everything I want to run at startup, but also a few other settings which make more sense to set here, instead of later.

** Do these ASAP
Either I want these configured as soon as possible, or they are related to Emacs starting up. Which are which is left as an exercise to the reader.

*** Hide dumb stuff
I want to get GUI elements out of my face as soon as I possibly can. They just take up space.
#+BEGIN_SRC emacs-lisp
  (tooltip-mode -1)
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (setq use-dialog-box nil
        use-file-dialog nil)
#+END_SRC

*** Load newest bytecode
Always prefer the newest files when loading.
#+BEGIN_SRC emacs-lisp
  (setq load-prefer-newer t)
#+END_SRC

*** More complete apropos
This way, apropos does things more thoroughly, even if it's marginally slower.
#+BEGIN_SRC emacs-lisp
  (setq-default apropos-do-all t)
#+END_SRC

*** File name handling setup
For whatever reason, setting ~file-name-handler-alist~ to nil helps Emacs load faster. After Emacs finishes loading, it's reverted to its original value.
#+BEGIN_SRC emacs-lisp
  (defvar startup/file-name-handler-alist file-name-handler-alist
    "Temporary storage for `file-name-handler-alist' during startup.")

  (defun startup/revert-file-name-handler-alist ()
    "Revert `file-name-handler-alist' to its default value after startup."
    (setq file-name-handler-alist startup/file-name-handler-alist))

  (setq file-name-handler-alist nil)

  (add-hook 'emacs-startup-hook 'startup/revert-file-name-handler-alist)
#+END_SRC

*** Garbage collection postponing
Garbage collection shouldn't happen during startup, as that will slow Emacs down. Do it later. This is also where more ideal garbage collection settings are chosen.
#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6)

  (defun startup/reset-gc ()
    "Return garbage collection to normal parameters after startup."
    (setq gc-cons-threshold 16777216
          gc-cons-percentage 0.1))

  (add-hook 'emacs-startup-hook 'startup/reset-gc)
#+END_SRC

** Package management
Because I am writing this configuration to be as portable as possible (e.g. I should be able to dump this onto any machine and run it), I manage all packages through Emacs.

*** Disable ~customize~, keep ~package-autoremove~ working
I /hate/ ~customize~. I configure everything in this file, so I don't need anything messing with my ~init.el~, much less changing settings on me. Even though I do not use ~customize~ but really like protecting packages used in my configuration from ~package-autoremove~, I need to still set ~package-selected-packages~ so that it'll work. Packages are listed in the order in which they are installed.
#+BEGIN_SRC emacs-lisp
  (setq custom-file "/dev/null"
        package-selected-packages '(;; Core
                                    async
                                    use-package
                                    auto-package-update

                                    ;; Looks
                                    dashboard
                                    leuven-theme
                                    spaceline
                                    diminish
                                    rainbow-mode
                                    rainbow-delimiters

                                    ;; Desktop environment
                                    exwm
                                    dmenu
                                    minibuffer-line
                                    desktop-environment
                                    system-packages
                                    exwm-edit
                                    exwm-mff

                                    ;; Multimedia
                                    emms

                                    ;; Extra major modes
                                    graphviz-dot-mode
                                    markdown-mode

                                    ;; Functionality
                                    which-key
                                    ido-vertical-mode
                                    smex
                                    buffer-move
                                    swiper
                                    popup-kill-ring
                                    hungry-delete
                                    avy
                                    sudo-edit

                                    ;; Programming
                                    magit
                                    company
                                    haskell-mode
                                    company-jedi
                                    flycheck
                                    avy-flycheck

                                    ;; org-mode
                                    org-bullets
                                    epresent

                                    ;; Other
                                    vterm
                                    nov
                                    wttrin

                                    ;; Games
                                    yahtzee
                                    sudoku
                                    chess
                                    2048-game))
#+END_SRC

*** Disable an annoying ~customize~ function
Since I don't use ~customize~, we don't need to mess with it every time a package is installed or uninstalled. Because of this, I need to first load everything related to package management.
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (defun package--save-selected-packages (&rest opt) nil)
#+END_SRC

*** Configure package repositories
Next, we have to configure a setting for sanity and add our repositories to the list.
#+BEGIN_SRC emacs-lisp
  (setq package-enable-at-startup nil
        package-archives '(("gnu"   . "https://elpa.gnu.org/packages/")
                           ("melpa" . "https://melpa.org/packages/")
                           ("org"   . "https://orgmode.org/elpa/")))
#+END_SRC

*** Initialize package management
Finally, we call ~package-initialize~. We only need to do this if we're running on Emacs 26 or below. Emacs 27 and beyond no longer require this call.
#+BEGIN_SRC emacs-lisp
  (when (< emacs-major-version 27)
    (package-initialize))
#+END_SRC

*** Bootstrap ~async~
This package is super useful for making package installation significantly faster. It also allows for asynchronous ~dired~.
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'async)
    (package-refresh-contents)
    (package-install 'async))

  (dired-async-mode 1)
  (async-bytecomp-package-mode 1)
  (setq async-bytecomp-allowed-packages '(all))
#+END_SRC

*** Bootstrap ~use-package~
Since I manage all Emacs packages in Emacs via this file, ~use-package~ makes it much easier to install all the packages I need. It also means I can see what packages take the longest to load.
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (setq use-package-compute-statistics t)
#+END_SRC

*** Automatically update packages
I don't want to have to manually update my stuff. This solution is literally plop-and-forget, and updates packages once a certain number of days has passed since the last time I updated packages.
#+BEGIN_SRC emacs-lisp
  (use-package auto-package-update
    :ensure t
    :defer t
    :init
    (setq auto-package-update-interval 2
          auto-package-update-delete-old-versions t)
    (auto-package-update-maybe))
#+END_SRC

** After everything else
These are other startup specific things, but they are not necessarily as pressing to startup as everything else.

*** Start Emacs server
Having the Emacs server running allows for a lot of neat integration with other parts of my destop environment. However, I don't want it to start too soon.
#+BEGIN_SRC emacs-lisp
  (require 'server)

  (defun server-start-if-not-running ()
    "Call `server-start' if `server-running-p' returns nil."
    (unless (server-running-p)
      (server-start)))

  (add-hook 'after-init-hook 'server-start-if-not-running)
#+END_SRC
*** dashboard package (replacement start screen)
I like the default start screen, but it just doesn't cut it for me. I just use this to have a nice screen when I start Emacs or close all my buffers.
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :defer t
    :init
    (setq dashboard-set-footer nil
          inhibit-startup-screen t
          dashboard-items '((recents . 10))
          dashboard-startup-banner 'official
          initial-buffer-choice (lambda () (or (get-buffer "*dashboard*")
                                               (get-buffer "*scratch*")))
          dashboard-banner-logo-title "Welcome to Farlado's Illiterate GNU Emacs!")
    (dashboard-setup-startup-hook))
#+END_SRC

* Making Emacs significantly less ugly
Stock Emacs is /ugly/. Just straight up ugly. Suffice to say it leaves much to be desired.

** Font
*** Setting the font style
Originally I had this set up by means of ~custom-set-faces~, but frankly that is less easily configured than this method. First, we determine whether my preferred font is present on the system and set it if present. Otherwise, keep whatever default font Emacs chooses.
#+BEGIN_SRC emacs-lisp
  (when (member "Iosevka" (font-family-list))
    (set-face-attribute 'default nil :font "Iosevka"))
#+END_SRC

*** Determining a good font size
Next we need to determine what size to make the text. This is based on the width of the screens I regularly use. It uses shell commands for X window systems and built-in functions for Windows.
#+BEGIN_SRC emacs-lisp
  (let* ((res (if (eq window-system 'x)
                  (string-to-number
                   (shell-command-to-string
                    (concat "xrandr | grep \\* | "
                            "cut -d x -f 1 | "
                            "sort -n | head -n 1")))
                (/ (display-pixel-width) (display-screens))))
         (size (if (<= res 1366) 100
                 180)))
    (set-face-attribute 'default nil :height size))
#+END_SRC

*** Getting emoji to work properly
God does this one feel great to have. However, it only works if we're using Emacs 27 or later...
#+BEGIN_SRC emacs-lisp
  (when (and (member "Noto Color Emoji" (font-family-list))
             (not (< emacs-major-version 27)))
    (set-fontset-font t 'symbol (font-spec :family "Noto Color Emoji") nil 'prepend))
#+END_SRC

** Theme
*** Leuven
I used to hate light themes. I'm not in that camp anymore. This theme is /elegant/. I spent almost two entire weeks trying to find a dark theme that comes anywhere close to being as comfortable as Leuven, and even Leuven's dark alternative doesn't cut it.
#+BEGIN_SRC emacs-lisp
  (use-package leuven-theme
    :if window-system
    :ensure t
    :defer t
    :init
    (setq leuven-scale-org-agenda-structure t
          leuven-scale-outline-headlines t)
    (load-theme 'leuven t))
#+END_SRC

*** Fringes
Having fringes helps keep things looking good. However, I really do not want the fringes to have a color that is different from the default background.
#+BEGIN_SRC emacs-lisp
  (set-face-background 'fringe (face-attribute 'default :background))

  (fringe-mode 10)
#+END_SRC

*** Window dividers
Windows dividers make Emacs look far less sloppy. The color is grabbed from the mode line for consistency.
#+BEGIN_SRC emacs-lisp
  (setq window-divider-default-right-width 3)
  (dolist (face '(window-divider-first-pixel
                  window-divider-last-pixel
                  window-divider))
    (set-face-foreground face (face-attribute 'mode-line :background)))
  (window-divider-mode 1)
#+END_SRC

** Mode line
*** Use the mode line from Spacemacs
I *hate* the default mode line. The mode line from Spacemacs, ~spaceline~, is much less sucky. I also show and hide specific things when setting it up. In terminals, ~spaceline-emacs-theme~ just looks wrong, so I don't use it unless I'm in a graphical environment.
#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :ensure t
    :defer t
    :init
    (require 'spaceline-config)
    (setq powerline-default-separator 'wave
          spaceline-buffer-encoding-abbrev-p nil
          spaceline-buffer-size-p nil
          spaceline-line-column-p t
          column-number-indicator-zero-based nil)
    (if window-system
        (spaceline-emacs-theme)
      (spaceline-spacemacs-theme)))
#+END_SRC

*** Show clock and battery level on mode line
I use 24-hour time on all my clocks. I used to use ~fancy-battery~ for battery level but it constantly disappeared on my teeny tiny screens so I just decided not to bother with it. Plus it's one less package to configure lol.
#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format t)
  (display-time-mode 1)
  (display-battery-mode 1)
#+END_SRC

*** Hide various minor modes from the mode line
Works very nicely, makes the mode line far comfier. I set its installation as a hook so that I can keep the look section up a little higher.
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t
    :defer t
    :init
    (defun diminish-minor-modes ()
      "Diminish the minor modes in the list `minor-modes-to-diminish'."
      (dolist (mode minor-modes-to-diminish)
        (diminish mode)))
    (defvar minor-modes-to-diminish '(eldoc-mode
                                      subword-mode
                                      company-mode
                                      rainbow-mode
                                      flycheck-mode
                                      flyspell-mode
                                      which-key-mode
                                      auto-revert-mode
                                      visual-line-mode
                                      haskell-doc-mode
                                      flyspell-prog-mode
                                      hungry-delete-mode
                                      page-break-lines-mode
                                      desktop-environment-mode
                                      haskell-indentation-mode
                                      interactive-haskell-mode
                                      compilation-shell-minor-mode)
      "Minor modes to diminish using `diminish-minor-modes'.")
    (add-hook 'after-init-hook 'diminish-minor-modes))
#+END_SRC

** In buffers
*** Turn ^L into pretty lines
This is used in a number of places in Emacs. Better to have it on all the time than never on.
#+BEGIN_SRC emacs-lisp
  (global-page-break-lines-mode 1)
#+END_SRC

*** Line numbers (on most buffers)
I like having line numbers and indicators for lines past the EOF. However, I don't like line numbers in modes where it breaks the mode, and I want line numbers to look consistent.
#+BEGIN_SRC emacs-lisp
  (global-display-line-numbers-mode 1)
  (setq-default indicate-empty-lines t)

  (set-face-background 'line-number (face-attribute 'default :background))

  (dolist (hook '(Man-mode-hook
                  nov-mode-hook
                  help-mode-hook
                  shell-mode-hook
                  term-mode-hook
                  vterm-mode-hook
                  shell-mode-hook
                  snake-mode-hook
                  tetris-mode-hook
                  sudoku-mode-hook
                  custom-mode-hook
                  ibuffer-mode-hook
                  epresent-mode-hook
                  dashboard-mode-hook
                  package-menu-mode-hook))
    (add-hook hook (lambda () (display-line-numbers-mode -1))))
#+END_SRC

*** Highlight matching parentheses
For those moments where I can't figure out what is going on with the parentheses...
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (setq show-paren-style 'parenthesis
        show-paren-delay 0)
#+END_SRC

*** Color the background of text based on the color/hex typed
I don't use it too much, but it's nice to have it around.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :if window-system
    :ensure t
    :defer t
    :init
    (define-globalized-minor-mode global-rainbow-mode rainbow-mode rainbow-mode)
    (global-rainbow-mode 1))
#+END_SRC

*** Change the color of various delimiters based on how deep they go
It's subtle on my theme, but it still helps me keep track of my brackets and parentheses.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :if window-system
    :ensure t
    :defer t
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

* Making Emacs a desktop environment
Yes, Emacs is my *entire desktop environment*. You should probably remove this stuff if you don't plan to use Emacs as your desktop environment. It's loaded right after the startup commands so that I can bind keys more easily later on. I sometimes have to run Emacs in Windows and on systems that have a desktop environment already, so I really don't want this part loaded in those cases. The original solution was to call ~wmctrl~ and see if it failed in a specific way. The new solution is to look for the environment variable ~_RUN_EXWM~ and start EXWM if it is set. This means setting this variable somewhere in your ~.xinitrc~ or in the =.desktop= file your display manager uses.
#+BEGIN_SRC emacs-lisp
  (when (getenv "_RUN_EXWM")
    (set-frame-parameter nil 'fullscreen 'fullboth)
#+END_SRC

** Window management
*** Installing the base window manager
This isn't actually where we do all the configuration, it's just where we install EXWM and load what we need to configure it. Usually it is best to configure packages inside of ~use-package~, but that would be a horrible idea due to just how many different things there are that need configuring. However, we can do one useful thing here: set an environment variable that lets Java applications know that EXWM is not a reparenting window manager. If we don't, some games lock up really bad when changing focus.
#+BEGIN_SRC emacs-lisp
  (use-package exwm
    :ensure t
    :defer t
    :init
    (require 'exwm)
    (require 'exwm-randr)
    (require 'exwm-config)
    (require 'exwm-systemtray)
    (setenv "_JAVA_AWT_WM_NONREPARENTING" "1"))
#+END_SRC

*** Configure floating window borders
Uses the same color as my mode line, uses the same width as window divider width.
#+BEGIN_SRC emacs-lisp
  (setq exwm-floating-border-width 3
        exwm-floating-border-color (face-attribute 'mode-line :background))
#+END_SRC

*** Name EXWM buffers after the window title
This was annoying when I first installed EXWM. Thankfully this is a very easy fix.
#+BEGIN_SRC emacs-lisp
  (defun farl-exwm/name-buffer-after-window-title ()
    "Rename the current `exwm-mode' buffer after the X window's title."
    (exwm-workspace-rename-buffer exwm-title))

  (add-hook 'exwm-update-title-hook 'farl-exwm/name-buffer-after-window-title)
#+END_SRC

*** Edit text for an X window in Emacs
At first I questioned why I would do this, but now that I know the advantages of this, it's too good to pass up. This allows me to edit text from an X window using an Emacs buffer.
#+BEGIN_SRC emacs-lisp
  (use-package exwm-edit
    :ensure t
    :defer t
    :init
    (require 'exwm-edit))
#+END_SRC

*** Mouse follows on focus change
This is a setting I had back when I used ~dwm~. I really wanted it back so I'm glad I found this. When focus changes, unless the mouse caused the focus change, warp the mouse to the center of the newly focused window.
#+BEGIN_SRC emacs-lisp
  (use-package exwm-mff
    :ensure t
    :defer t
    :hook (exwm-init . exwm-mff-mode))
#+END_SRC

*** Getting a ~rofi~ equivalent
Since I'm using Emacs as a window manager, I need something comparable to ~rofi~ so I can open X windows I haven't bound to keys. It will be bound elsewhere. I really don't want one named after +a project made by Nazis+ a Suckless project, but laziness makes that hard.
#+BEGIN_SRC emacs-lisp
  (use-package dmenu
    :ensure t
    :defer t)
#+END_SRC

** Workspace configuration
*** Load all workspaces on startup
I do not want to have to load all of them on my own...
#+BEGIN_SRC emacs-lisp
  (setq exwm-workspace-number 10)
#+END_SRC

*** Assign workspaces to monitors
This section is only to ensure the proper workspaces are placed on the right monitors when my W541 is docked.
#+BEGIN_SRC emacs-lisp
  (setq exwm-randr-workspace-output-plist '(0 "DP2-2"
                                            1 "DP2-1"
                                            2 "DP2-3"
                                            3 "DP2-2"
                                            4 "DP2-1"
                                            5 "DP2-3"
                                            6 "DP2-2"
                                            7 "DP2-1"
                                            8 "DP2-3"
                                            9 "DP2-2"))
#+END_SRC

*** Assign programs to workspaces
...and also have some launch floating and/or without a mode line or borders.
#+BEGIN_SRC emacs-lisp
  (setq exwm-manage-configurations '(((string= exwm-class-name "Steam")
                                      floating-mode-line nil
                                      workspace 9)
                                     ((string= exwm-instance-name "telegram-desktop")
                                      workspace 8)
                                     ((string= exwm-class-name "discord")
                                      workspace 7)
                                     ((or (string-match-p "libreoffice" exwm-class-name)
                                          (string= exwm-class-name "MuseScore3")
                                          (string= exwm-class-name "Gimp"))
                                      workspace 6)
                                     ((string= exwm-title "Event Tester")
                                      floating-mode-line nil
                                      floating t)))
#+END_SRC

*** Name workspaces a little more intuitively
No clue why you have to do so much just to give workspaces names, but at least you can do it.
#+BEGIN_SRC emacs-lisp
  (setq exwm-workspace-index-map
        (lambda (index)
          (let ((named-workspaces ["1" "2" "3" "4" "5" "6"
                                   "office" "discord"
                                   "telegram" "games"]))
            (if (< index (length named-workspaces))
                (elt named-workspaces index)
              (number-to-string index)))))
#+END_SRC

*** Show a list of workspaces in the echo area
Because I now use so many workspaces, I need to be able to see what workspace I am currently on. This makes it easier to do that. It's rather buggy at times, but it does what it needs to do.
#+BEGIN_SRC emacs-lisp
  (defun farl-exwm/list-workspaces ()
    "List EXWM workspaces."
    (exwm-workspace--update-switch-history)
    (elt exwm-workspace--switch-history
         (exwm-workspace--position exwm-workspace--current)))

  (use-package minibuffer-line
    :ensure t
    :defer t
    :init
    (minibuffer-line-mode 1)
    (set-face-attribute 'minibuffer-line nil :inherit 'default)
    (setq minibuffer-line-format '((:eval (farl-exwm/list-workspaces))))
    (add-hook 'exwm-workspace-switch-hook 'minibuffer-line--update))
#+END_SRC

** Multi-head configuration
Thankfully, EXWM comes with hooks to handle when monitors are connected and disconnected, so I can do monitor configuration entirely in Emacs Lisp. I have two laptops: a ThinkPad X230 and a ThinkPad W541. Each has different displays and is used for different purposes. Due to recent updates to Arch Linux and the fact that the original code here was a dumpster fire, this section had to be reworked.

*** Getting the currently connected monitors
The first thing to do is set up a function to return a list of currently connected monitors.
#+BEGIN_SRC emacs-lisp
  (defun get-connected-monitors ()
    "Return a list of the currently connected monitors."
    (split-string (shell-command-to-string (concat "xrandr | "
                                                   "grep ' connected ' | "
                                                   "awk '{print $1}'"))))
#+END_SRC

*** Configuring monitor arrangement on my X230
This one is straightforward. I never do any kind of split-monitor setup on my ThinkPad X230, so every monitor looks over the same screen.
#+BEGIN_SRC emacs-lisp
  (defun display-setup-x230 ()
    "Set up the connected monitors on a ThinkPad X230."
    (let ((monitors (get-connected-monitors))
          (possible '("LVDS1"
                      "VGA1")))
      (dolist (monitor possible)
        (if (member monitor monitors)
            (start-process "xrandr" nil "xrandr"
                           "--output" monitor
                           "--mode" "1366x768"
                           "--pos" "0x0")
          (start-process "xrandr" nil "xrandr"
                         "--output" monitor
                         "--off")))))
#+END_SRC

*** Configuring monitor arrangement on my W541
This is where it gets really fun. This ThinkPad /does/ get docked, so I handle very different outputs.
#+BEGIN_SRC emacs-lisp
  (defun display-setup-w541 ()
    "Set up the connected monitors on a ThinkPad W541."
    (let* ((connected-monitors (get-connected-monitors))
           (docked-p (member "DP2-1" connected-monitors))
           (possible-monitors '("eDP1"
                                "VGA1"
                                "DP2-1"
                                "DP2-2"
                                "DP2-3")))
      (dolist (monitor possible-monitors)
        (if (and (member monitor connected-monitors)
                 (not (and docked-p (string= "eDP1" monitor))))
            (progn
              (start-process "xrandr" nil "xrandr"
                             "--output" monitor
                             ;; Any enabled monitor needs a resolution.
                             "--mode" (if (string= "eDP1" monitor)
                                          "2880x1620"
                                        "1920x1080")
                             ;; Scale all monitor output to 3K.
                             "--scale-from" "2880x1620"
                             ;; DP2-1 and DP2-3 are rotated.
                             "--rotate" (if (string= "DP2-1" monitor)
                                            "left"
                                          (if (string= "DP2-3" monitor)
                                              "right"
                                            "normal"))
                             ;; Every enabled monitor needs a position.
                             "--pos" (if (string-match-p "1" monitor)
                                         "0x0"
                                       (if (string= monitor "DP2-2")
                                           "1620x0"
                                         "4500x0")))
              ;; Setting a monitor as primary occurs outside enabling it.
              ;; This is due to how `start-process' takes arguments.
              (when (or (string= "DP2-2" monitor)
                        (string= "eDP1" monitor))
                (start-process "xrandr" nil "xrandr"
                               "--output" monitor
                               "--primary")))
          (start-process "xrandr" nil "xrandr"
                         "--output" monitor
                         "--off")))))
#+END_SRC

*** Configuring peripherals while docked
Because I use a dock on my W541, there are some things I need to do alongside setting up my monitors.
#+BEGIN_SRC emacs-lisp
  (defun peripheral-setup ()
    "Configure peripherals I connect to my dock."
    ;; Trackball
    (let ((trackball-id (shell-command-to-string
                         (concat "xinput | grep ELECOM | head -n 1 | sed -r "
                                 "'s/.*id=([0-9]+).*/\\1/' | tr '\\n' ' '"))))
      (dolist (command '("'libinput Button Scrolling Button' 10"
                         "'libinput Scroll Method Enabled' 0 0 1"))
        (start-process-shell-command
         "Trackball Setup" nil (concat "xinput set-prop "
                                       trackball-id command)))
      (start-process-shell-command
       "Trackball Setup" nil (concat "xinput set-button-map " trackball-id
                                     "1 2 3 4 5 6 7 8 9 2 1 2")))
    ;; Keyboard
    (start-process "Keyboard Setup" nil "setxkbmap"
                   "-option" "ctrl:nocaps"))
#+END_SRC

*** Bringing it all together
Finally, I can make my generic display-and-dock setup function.
#+BEGIN_SRC emacs-lisp
  (defun display-and-dock-setup ()
    "Configure displays and dock if applicable."
    (interactive)
    (if (member "LVDS1" (get-connected-monitors))
        (display-setup-x230)
      (progn
        (display-setup-w541)
        (peripheral-setup))))
#+END_SRC

*** Start ~exwm-randr~
This is where the real magic happens.
#+BEGIN_SRC emacs-lisp
  (add-hook 'exwm-randr-screen-change-hook 'display-and-dock-setup)
  (exwm-randr-enable)
#+END_SRC

** Desktop environment components
*** System package management
This one is a pleasant surprise to have honestly. Having Emacs handle system packages as well as its own makes life a million times easier. Since I use ~yay~ on Arch, I configure an entry for it and use it if it's installed.
#+BEGIN_SRC emacs-lisp
  (use-package system-packages
    :ensure t
    :defer t
    :init
    (when (executable-find "yay")
      (require 'system-packages)
      (add-to-list 'system-packages-supported-package-managers
                   '(yay .
                         ((default-sudo . nil)
                          (install . "yay -S")
                          (search . "yay -Ss")
                          (uninstall . "yay -Rs")
                          (update . "yay -Syu")
                          (clean-cache . "yay -Sc")
                          (log . "car /var/log/pacman.log")
                          (get-info . "yay -Qi")
                          (get-info-remote . "yay -Si")
                          (list-files-provided-by . "yay -Ql")
                          (verify-all-packages . "yay -Qkk")
                          (verify-all-dependencies . "yay -Dk")
                          (remove-orphaned . "yay -Rns $(yay -Qtdq)")
                          (list-installed-packages . "yay -Qe")
                          (list-installed-packages-all . "yay -Q")
                          (list-dependencies-of . "yay -Qi")
                          (noconfirm . "--noconfirm"))))
      (setq system-packages-use-sudo nil
            system-packages-package-manager 'yay))
    (setq system-packages-noconfirm t)
    :bind (("C-c p i" . system-packages-install)
           ("C-c p e" . system-packages-ensure)
           ("C-c p u" . system-packages-update)
           ("C-c p r" . system-packages-uninstall)
           ("C-c p o" . system-packages-remove-orphaned)
           ("C-c p c" . system-packages-clean-cache)
           ("C-c p l" . system-packages-log)
           ("C-c p s" . system-packages-search)
           ("C-c p g" . system-packages-get-info)
           ("C-c p d" . system-packages-list-dependencies-of)
           ("C-c p f" . system-packages-list-files-provided-by)
           ("C-c p p" . system-packages-list-installed-packages)
           ("C-c p f" . system-packages-verify-all-dependencies)
           ("C-c p v" . system-packages-verify-all-packages)))
#+END_SRC

*** ~desktop-environment-mode~
Previously I had to define a lot of functions to do these things, now I just change settings within ~desktop-environment-mode~.
#+BEGIN_SRC emacs-lisp
  (use-package desktop-environment
    :ensure t
    :defer t
    :init
    (desktop-environment-mode 1))
#+END_SRC

**** Volume adjustment
The only things I really don't like about how ~desktop-environment~'s volume controlling is ~desktop-environment-toggle-mute~, which gives way too much output when you mute or unmute the speakers or microphone, so I set up basic scripts to give much more concise output.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-volume-toggle-command
        (concat "[ \"$(amixer set Master toggle | grep off)\" ] "
                "&& echo Volume is now muted. | tr '\n' ' ' "
                "|| echo Volume is now unmuted. | tr '\n' ' '")
        desktop-environment-volume-toggle-microphone-command
        (concat "[ \"$(amixer set Capture toggle | grep off)\" ] "
                "&& echo Microphone is now muted. | tr '\n' ' ' "
                "|| echo Microphone is now unmuted | tr '\n' ' '"))
#+END_SRC

**** Brightness adjustment
This one all I needed to do was change the increment and decrement values.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-brightness-normal-increment "5%+"
        desktop-environment-brightness-normal-decrement "5%-")
#+END_SRC

**** Screenshots
This one was the least straightforward because the way it's implemented by ~desktop-environment~ is *SUPER* wonky. Here are the binds which will be relevant.
#+BEGIN_SRC emacs-lisp
  ;; Storing to clipboard
  (define-key desktop-environment-mode-map (kbd "<print>")
    'farl-de/desktop-environment-screenshot-part-clip)
  (define-key desktop-environment-mode-map (kbd "<S-print>")
    'farl-de/desktop-environment-screenshot-clip)

  ;; Storing to file
  (define-key desktop-environment-mode-map (kbd "<C-print>")
    'farl-de/desktop-environment-screenshot-part)
  (define-key desktop-environment-mode-map (kbd "<C-S-print>")
    'farl-de/desktop-environment-screenshot)
#+END_SRC

First, I set what directory to store screenshots in.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-screenshot-directory "~/screenshots")
#+END_SRC

Then, I can set the commands for taking a full or partial screenshot and saving it to a file.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-screenshot-command
        "FILENAME=$(date +'%Y-%m-%d-%H:%M:%S').png && maim $FILENAME"
        desktop-environment-screenshot-partial-command
        "FILENAME=$(date +'%Y-%m-%d-%H:%M:%S').png && maim -s $FILENAME")
#+END_SRC

The functions which ~desktop-environment~ comes with are kinda garbage, so I made my own.
#+BEGIN_SRC emacs-lisp
  (defun farl-de/desktop-environment-screenshot ()
    "Take a screenshot and store it in a file."
    (interactive)
    (desktop-environment-screenshot)
    (message "Screenshot saved in ~/screenshots."))

  (defun farl-de/desktop-environment-screenshot-part ()
    "Take a capture of a portion of the screen and store it in a file."
    (interactive)
    (desktop-environment-screenshot-part)
    (message "Screenshot saved in ~/screenshots."))

  (defun farl-de/desktop-environment-screenshot-clip ()
    "Take a screenshot and put it in the clipboard."
    (interactive)
    (shell-command (concat desktop-environment-screenshot-command
                           " && xclip $FILENAME -selection clipboard "
                           "-t image/png &> /dev/null && rm $FILENAME"))
    (message "Screenshot copied to clipboard."))

  (defun farl-de/desktop-environment-screenshot-part-clip ()
    "Take a shot of a portion of the screen and put it in the clipboard."
    (interactive)
    (shell-command (concat desktop-environment-screenshot-partial-command
                           " && xclip $FILENAME -selection clipboard "
                           "-t image/png &> /dev/null && rm $FILENAME"))
    (message "Screenshot copied to clipboard."))
#+END_SRC

**** Lock screen
Haha yes, this is very long and very very stupid.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-screenlock-command
        (concat "i3lock -nmk --color=000000 --timecolor=ffffffff --datecolor=ffffffff "
                "--wrongcolor=ffffffff --ringcolor=00000000 --insidecolor=00000000 "
                "--keyhlcolor=00000000 --bshlcolor=00000000 --separatorcolor=00000000 "
                "--ringvercolor=00000000 --insidevercolor=00000000 --linecolor=00000000 "
                "--ringwrongcolor=00000000 --insidewrongcolor=00000000 --timestr=%H:%M "
                "--datestr='%a %d %b' --time-font=Iosevka --date-font=Iosevka "
                "--wrong-font=Iosevka --timesize=128 --datesize=64 --wrongsize=32 "
                "--time-align 0 --date-align 0 --wrong-align 0 --indpos=-10:-10 "
                "--timepos=200:125 --datepos=200:215 --wrongpos=200:155 --locktext='' "
                "--lockfailedtext='' --noinputtext='' --radius 1 --ring-width 1 "
                " --veriftext='' --wrongtext='WRONG' --force-clock"))
#+END_SRC

*** Monitor settings
Calling ~arandr~ to adjust monitors is useful when I am preparing to present something using my computer or need to adjust how monitors are set up in a unique way that isn't a preset from my dotfiles.
#+BEGIN_SRC emacs-lisp
  (defun monitor-settings ()
    "Open arandr to configure monitors."
    (interactive)
    (start-process "Monitor Settings" nil "arandr"))
#+END_SRC

*** Network settings
This one uses two windows: one to open the NetworkManager connection editor, and another to list WiFi networks nearby.
#+BEGIN_SRC emacs-lisp
  (defun network-settings ()
    "Open a NetworkManager connection editor."
    (interactive)
    (start-process "Network Settings" nil "nm-connection-editor")
    (async-shell-command "nmcli dev wifi list" "*Wi-Fi Networks*"))
#+END_SRC

*** Volume mixer
For when you need to do volume mixing.
#+BEGIN_SRC emacs-lisp
  (defun volume-settings ()
    "Open pavucontrol to adjust volume."
    (interactive)
    (start-process "Volume Mixer" nil "pavucontrol"))
#+END_SRC

*** Audio loop-back
Used when I play Jackbox Party Pack with friends. Also set up to launch ~pavucontrol~ to set up which programs to pass through to Discord.
#+BEGIN_SRC emacs-lisp
  (defun audio-loopback ()
    "Loop desktop audio into a null sink alongside the primary input."
    (interactive)
    ;; Create two modules: `loop' and `out'
    (dolist (sink '("loop"
                    "out"))
      (shell-command (concat "pacmd load-module module-null-sink sink_name=" sink))
      (shell-command (concat "pacmd update-sink-proplist "
                             sink " device.description=" sink)))
    ;; Loop `loop' to primary output, pipe it to `out', loop primary into to `out'
    (dolist (command '("sink=out"
                       "source=loop.monitor"
                       "source=loop.monitor sink=out"))
      (shell-command (concat "pacmd load-module module-loopback " command)))
    ;; Run `pavucontrol' and then unload the modules after it completes
    (start-process-shell-command
     "Audio Loop" nil (concat "pavucontrol && "
                              "pacmd unload-module module-null-sink && "
                              "pacmd unload-module module-loopback")))
#+END_SRC

*** Keyboard layout selection
This will eventually be its own package, but for now, it's just in my config. First, I set up three custom variables:
#+BEGIN_SRC emacs-lisp
  (defgroup keyboard-layout nil
    "Keyboard layouts to cycle through."
    :group 'environment)

  (defcustom keyboard-layout-1 "us"
    "The first of three keyboard layouts to cycle through.

  Set to nil to have one less keyboard layout."
    :group 'keyboard-layout
    :type 'string)

  (defcustom keyboard-layout-2 "epo"
    "The second of three keyboard layouts to cycle through.

  Set to nil to have one less keyboard layout."
    :group 'keyboard-layout
    :type 'string)

  (defcustom keyboard-layout-3 "de"
    "The third of three keyboard layouts to cycle through.

  Set to nil to have one less keyboard layout."
    :group 'keyboard-layout
    :type 'string)
#+END_SRC

Then, I use these functions to control setting and cycling the keyboard layout:
#+BEGIN_SRC emacs-lisp
  (defun get-keyboard-layout ()
    "Get the current keyboard layout."
    (shell-command-to-string
     (concat "setxkbmap -query | "
             "grep -oP 'layout:\\s*\\K(\\w+)' | "
             "tr '\n' ' ' | sed 's/ //'")))

  (defun set-keyboard-layout (&optional layout)
    "Set the keyboard layout to LAYOUT."
    (interactive)
    (let ((layout (or layout (read-string "Enter keyboard layout: "))))
      (shell-command (concat "setxkbmap " layout " -option ctrl:nocaps"))
      (message "Keyboard layout is now: %s" layout)))

  (defun cycle-keyboard-layout ()
    "Cycle between `keyboard-layout-1', `keyboard-layout-2', and `keyboard-layout-3'."
    (interactive)
    (let* ((current-layout (get-keyboard-layout))
           (new-layout (if (string= current-layout keyboard-layout-1)
                           (or keyboard-layout-2 keyboard-layout-3)
                         (if (string= current-layout keyboard-layout-2)
                             (or keyboard-layout-3 keyboard-layout-1)
                           (or keyboard-layout-1 keyboard-layout-2)))))
      (if new-layout
          (set-keyboard-layout new-layout)
        (message "No keyboard layouts selected."))))

  (defun cycle-keyboard-layout-reverse ()
    "Cycle between `keyboard-layout-1', `keyboard-layout-2', and `keyboard-layout-3' in reverse."
    (interactive)
    (let* ((current-layout (get-keyboard-layout))
           (new-layout (if (string= current-layout keyboard-layout-3)
                           (or keyboard-layout-2 keyboard-layout-1)
                         (if (string= current-layout keyboard-layout-2)
                             (or keyboard-layout-1 keyboard-layout-3)
                           (or keyboard-layout-3 keyboard-layout-2)))))
      (if new-layout
          (set-keyboard-layout new-layout)
        (message "No keyboard layouts selected."))))
#+END_SRC

*** Suspending
#+BEGIN_SRC emacs-lisp
  (defun suspend-computer ()
    (interactive)
    (and (yes-or-no-p "Really suspend? ")
         (shell-command "systemctl suspend -i")))

  (global-set-key (kbd "C-x C-M-s") 'suspend-computer)
#+END_SRC

*** Rebooting
I copied the function for quitting Emacs to handle reboot too.
#+BEGIN_SRC emacs-lisp
  (defun save-buffers-reboot (&optional arg)
    "Offer to save each buffer, then shut down the computer.
  This function is literally just a copycat of `save-buffers-kill-emacs'.
  With prefix ARG, silently save all file-visiting buffers without asking.
  If there are active processes where `process-query-on-exit-flag'
  returns non-nil and `confirm-kill-processes' is non-nil,
  asks whether processes should be killed.
  Runs the members of `kill-emacs-query-functions' in turn and stops
  if any returns nil.  If `confirm-kill-emacs' is non-nil, calls it.
  Instead of just killing Emacs, shuts down the system."
    (interactive "P")
    ;; Don't use save-some-buffers-default-predicate, because we want
    ;; to ask about all the buffers before killing Emacs.
    (save-some-buffers arg t)
    (let ((confirm confirm-kill-emacs))
      (and
       (or (not (memq t (mapcar (function
                                 (lambda (buf) (and (buffer-file-name buf)
                                                    (buffer-modified-p buf))))
                                (buffer-list))))
           (progn (setq confirm nil)
                  (yes-or-no-p "Modified buffers exist; reboot anyway? ")))
       (or (not (fboundp 'process-list))
           ;; process-list is not defined on MSDOS.
           (not confirm-kill-processes)
           (let ((processes (process-list))
                 active)
             (while processes
               (and (memq (process-status (car processes)) '(run stop open listen))
                    (process-query-on-exit-flag (car processes))
                    (setq active t))
               (setq processes (cdr processes)))
             (or (not active)
                 (with-current-buffer-window
                  (get-buffer-create "*Process List*") nil
                  #'(lambda (window _value)
                      (with-selected-window window
                        (unwind-protect
                            (progn
                              (setq confirm nil)
                              (yes-or-no-p (concat "Active processes exist; kill "
                                                   "them and reboot anyway? ")))
                          (when (window-live-p window)
                            (quit-restore-window window 'kill)))))
                  (list-processes t)))))
       ;; Query the user for other things, perhaps.
       (run-hook-with-args-until-failure 'kill-emacs-query-functions)
       (or (null confirm)
           (funcall confirm "Really reboot? "))
       (shell-command "reboot")
       (kill-emacs))))

  (global-set-key (kbd "C-x C-M-r") 'save-buffers-reboot)
#+END_SRC

*** Shutting down
I copied the function for quitting Emacs to handle shutting down.
#+BEGIN_SRC emacs-lisp
  (defun save-buffers-shut-down (&optional arg)
    "Offer to save each buffer, then shut down the computer.
  This function is literally just a copycat of `save-buffers-kill-emacs'.
  With prefix ARG, silently save all file-visiting buffers without asking.
  If there are active processes where `process-query-on-exit-flag'
  returns non-nil and `confirm-kill-processes' is non-nil,
  asks whether processes should be killed.
  Runs the members of `kill-emacs-query-functions' in turn and stops
  if any returns nil.  If `confirm-kill-emacs' is non-nil, calls it.
  Instead of just killing Emacs, shuts down the system."
    (interactive "P")
    ;; Don't use save-some-buffers-default-predicate, because we want
    ;; to ask about all the buffers before killing Emacs.
    (save-some-buffers arg t)
    (let ((confirm confirm-kill-emacs))
      (and
       (or (not (memq t (mapcar (function
                                 (lambda (buf) (and (buffer-file-name buf)
                                                    (buffer-modified-p buf))))
                                (buffer-list))))
           (progn (setq confirm nil)
                  (yes-or-no-p "Modified buffers exist; shut down anyway? ")))
       (or (not (fboundp 'process-list))
           ;; process-list is not defined on MSDOS.
           (not confirm-kill-processes)
           (let ((processes (process-list))
                 active)
             (while processes
               (and (memq (process-status (car processes)) '(run stop open listen))
                    (process-query-on-exit-flag (car processes))
                    (setq active t))
               (setq processes (cdr processes)))
             (or (not active)
                 (with-current-buffer-window
                  (get-buffer-create "*Process List*") nil
                  #'(lambda (window _value)
                      (with-selected-window window
                        (unwind-protect
                            (progn
                              (setq confirm nil)
                              (yes-or-no-p (concat "Active processes exist; kill "
                                                   "them and shut down anyway? ")))
                          (when (window-live-p window)
                            (quit-restore-window window 'kill)))))
                  (list-processes t)))))
       ;; Query the user for other things, perhaps.
       (run-hook-with-args-until-failure 'kill-emacs-query-functions)
       (or (null confirm)
           (funcall confirm "Really shut down? "))
       (shell-command "shutdown now")
       (kill-emacs))))

  (global-set-key (kbd "C-x C-M-c") 'save-buffers-shut-down)
#+END_SRC

** X applications
*** GIMP
Until GIMP's functionality gets merged into Emacs, guess I'm stuck having it.
#+BEGIN_SRC emacs-lisp
  (defun run-gimp ()
    "Start GIMP."
    (interactive)
    (start-process "GIMP" nil "gimp"))
#+END_SRC

*** Steam
Gaming is possible with EXWM, if you run games windowed. I used to run it floating, but honestly just having it tile is so much easier to manage.
#+BEGIN_SRC emacs-lisp
  (defun run-steam ()
    "Start Steam."
    (interactive)
    (start-process "Steam" nil "steam"))
#+END_SRC

*** Firefox
Firefox has some unique abilities when it comes to how to make windows behave which work better for me. I don't use tabs, and I don't want anything to do with them, and Firefox lets me hide the tab bar and force all tabs to actually open as new windows. It's like Suckless Surf, but orders of magnitude better.
#+BEGIN_SRC emacs-lisp
  (defun run-firefox ()
    "Start Firefox."
    (interactive)
    (start-process "Firefox" nil "firefox"))
#+END_SRC

*** Discord
Yeah, I also use the light theme for Discord. It looks comfy, even if Discord is a garbage application.
#+BEGIN_SRC emacs-lisp
  (defun run-discord ()
    "Start Discord."
    (interactive)
    (start-process "Discord" nil "discord"))
#+END_SRC

*** Telegram
I have a painfully white theme which fits perfectly with my setup.
#+BEGIN_SRC emacs-lisp
  (defun run-telegram ()
    "Start Telegram."
    (interactive)
    (start-process "Telegram" nil "telegram-desktop"))
#+END_SRC

*** MuseScore
I haven't figured out how to engrave in Emacs, so for now...
#+BEGIN_SRC emacs-lisp
  (defun run-musescore ()
    "Start MuseScore."
    (interactive)
    (start-process "MuseScore" nil "musescore"))
#+END_SRC

*** LibreOffice
Shame me all you want. I'm still in introductory courses and haven't learned enough Org-mode to use it more meaningfully.
#+BEGIN_SRC emacs-lisp
  (defun run-libreoffice ()
    "Start LibreOffice."
    (interactive)
    (start-process "LibreOffice" nil "libreoffice"))
#+END_SRC

*** Transmission
#+BEGIN_SRC emacs-lisp
  (defun run-transmission ()
    "Start Transmission."
    (interactive)
    (start-process "Transmission" nil "transmission-gtk"))
#+END_SRC
** Keybindings
*** Global binds to use across everything
Anything I couldn't cram into ~desktop-environment-mode~ has been slapped into this area.
#+BEGIN_SRC emacs-lisp
  (setq exwm-input-global-keys
        `(;; Switching workspace focus
          ;; 1 opens 0, 2 opens 1, etc.
          ,@(mapcar
             (lambda (i)
               `(,(kbd (format "s-%d" (% (+ i 1) 10))) .
                 (lambda ()
                   (interactive)
                   (exwm-workspace-switch-create ,i))))
             (number-sequence 0 9))

          ;; Other workspace management
          ([?\s-q] . exwm-workspace-swap)
          ([?\s-w] . exwm-workspace-switch)
          ([?\s-e] . exwm-workspace-move-window)

          ;; Window size adjustment
          ([8388631] . enlarge-window) ; C-s-w
          ([8388627] . shrink-window) ; C-s-s
          ([8388609] . shrink-window-horizontally) ; C-s-a
          ([8388612] . enlarge-window-horizontally) ; C-s-d

          ;; Opening X applications
          ([?\s-g]    . run-gimp)
          ([?\s-s]    . run-steam)
          ([?\s-f]    . run-firefox)
          ([?\s-d]    . run-discord)
          ([?\s-t]    . run-telegram)
          ([?\s-m]    . run-musescore)
          ([?\s-b]    . run-libreoffice)
          ([?\s-o]    . run-transmission)
          ([?\s-r]    . monitor-settings)
          ([?\s-n]    . network-settings)
          ([?\s-v]    . volume-settings)
          ([s-return] . vterm)
          ([XF86Calculator] . calc)

          ;; Other desktop environment things
          ([?\s-x]       . dmenu)
          ([menu]        . smex)
          ([?\s- ]       . cycle-keyboard-layout)
          ([s-backspace] . cycle-keyboard-layout-reverse)
          ([s-tab]       . audio-loopback)

          ;; Controlling EMMS
          ([XF86AudioNext] . emms-next)
          ([XF86AudioPrev] . emms-previous)
          ([XF86AudioPlay] . emms-pause)
          ([XF86AudioStop] . emms-stop)))
#+END_SRC

*** Emacs key bindings in X windows
This is super nice, because I love these key bindings and they are just intuitive to me, and now they can carry over safely to other programs.
#+BEGIN_SRC emacs-lisp
  (setq exwm-input-simulation-keys
        '(;; Navigation
          ([?\C-b] . [left])
          ([?\C-f] . [right])
          ([?\C-p] . [up])
          ([?\C-n] . [down])

          ([?\M-b] . [C-left])
          ([?\M-f] . [C-right])
          ([?\M-p] . [C-up])
          ([?\M-n] . [C-down])

          ([?\C-a] . [home])
          ([?\C-e] . [end])
          ([?\C-v] . [next])
          ([?\M-v] . [prior])

          ;; Copy/Paste
          ([?\C-w] . [?\C-x])
          ([?\M-w] . [?\C-c])
          ([?\C-y] . [?\C-v])
          ([?\C-s] . [?\C-f])
          ([?\C-\/] . [?\C-z])

          ;; Other
          ([?\C-d] . [delete])
          ([?\C-k] . [S-end delete])
          ([?\C-g] . [escape])))

  ;; I can't do sequences above, so these are separate
  (defun farl-exwm/C-s ()
    "Pass C-s to the EXWM window."
    (interactive)
    (execute-kbd-macro (kbd "C-q C-s")))

  (defun farl-exwm/C-k ()
    "Pass C-k to the EXWM window."
    (interactive)
    (execute-kbd-macro (kbd "C-q C-k")))

  (define-key exwm-mode-map (kbd "C-x C-s") 'farl-exwm/C-s)
  (define-key exwm-mode-map (kbd "C-c C-l") 'farl-exwm/C-k)
#+END_SRC

*** Send a key verbatim more easily
#+BEGIN_SRC emacs-lisp
  (define-key exwm-mode-map (kbd "C-c C-q") nil)
  (define-key exwm-mode-map (kbd "C-q") 'exwm-input-send-next-key)
#+END_SRC

*** Inhibit things I don't use
This includes:
- Toggling fullscreen
- Toggling floating
- Toggling hiding
- Toggling the mode line
#+BEGIN_SRC emacs-lisp
  (dolist (key '("C-c C-t C-f"
                 "C-c C-t C-v"
                 "C-c C-t C-m"
                 "C-c C-f"))
    (define-key exwm-mode-map (kbd key) nil))
#+END_SRC

** On startup
*** Hide the cursor when typing
This is just a point of personal preference. I tried not using it for a while and personally it just felt wrong.
#+BEGIN_SRC emacs-lisp
  (start-process "Hide Cursor" nil "xbanish")
#+END_SRC

*** Disable screen blanking
I don't need my laptop's screen shutting off just because I'm sitting and watching a video too long.
#+BEGIN_SRC emacs-lisp
  (start-process "Disable Blanking" nil "xset"
                 "s" "off" "-dpms")
#+END_SRC

*** Disable the trackpad
This thing is disgusting, and I prefer trackpoints way more.
#+BEGIN_SRC emacs-lisp
  (start-process "Trackpad Setup" nil "xinput"
                 "disable" (shell-command-to-string
                            (concat "xinput | grep Synap | head -n 1 | "
                                    "sed -r 's/.*id=([0-9]+).*/\\1/' | "
                                    "tr '\n' ' ' | sed 's/ //'")))
#+END_SRC

*** Keyboard configuration
This block sets the keyboard layout to US and give Caps Lock the functionality of Control. I was hesitant to do this at first, but it's significantly more comfortable. I almost never used caps lock as it is, given my keyboards have no indicator for it on my laptops, but this gives me a much easier way to do commands without shifting my hand too far.
#+BEGIN_SRC emacs-lisp
  (start-process "Keyboard Layout" nil "setxkbmap"
                 "us" "-option" "ctrl:nocaps")
#+END_SRC

*** Start the compositor
I don't need it, but having basic compositing is very nice.
#+BEGIN_SRC emacs-lisp
  (start-process "Compositor" nil "xcompmgr")
#+END_SRC

*** Set fallback cursor
Some X windows will have weird cursors if this isn't done.
#+BEGIN_SRC emacs-lisp
  (start-process "Fallback Cursor" nil "xsetroot"
                 "-cursor_name" "left_ptr")
#+END_SRC

*** Start EXWM
#+BEGIN_SRC emacs-lisp
  (exwm-systemtray-enable)
  (exwm-config-ido)
  (exwm-enable)
#+END_SRC

With that out of the way, we can close off this block and move on to the next section.
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

* Making Emacs organize/play music
I am big on doing as much in Emacs as possible. Having my music player moved to Emacs was a HUGE step. When I first started using it, it was weird, but now I have come to absolutely love it. We only configure EMMS if ~mpd~ is found. When checking whether ~mpd~ is installed, a couple environment variables are also set.
#+BEGIN_SRC emacs-lisp
  (when (executable-find "mpd")
    (setenv "MPD_HOST" "localhost")
    (setenv "MPD_PORT" "6601")
#+END_SRC

** Installing EMMS
All I do here is configure EMMS. Binding keys is later.
#+BEGIN_SRC emacs-lisp
  (use-package emms
    :ensure t
    :defer t
    :init
    (require 'emms-setup)
    (require 'emms-player-mpd)
    (emms-all)
    (setq emms-seek-seconds 5
          emms-player-list '(emms-player-mpd)
          emms-info-functions '(emms-info mpd)
          emms-player-mpd-server-name "localhost"
          emms-player-mpd-server-port "6601"
          mpc-host "localhost:6601"))
#+END_SRC

** Daemon functions
*** Starting the daemon
#+BEGIN_SRC emacs-lisp
  (defun mpd/start-music-daemon ()
    "Start MPD, connect to it and sync the metadata cache"
    (interactive)
    (shell-command "mpd")
    (mpd/update-database)
    (emms-player-mpd-connect)
    (emms-cache-set-from-mpd-all)
    (message "MPD started!"))
#+END_SRC

*** Stopping the daemon
#+BEGIN_SRC emacs-lisp
  (defun mpd/kill-music-daemon ()
    "Stop playback and kill the music daemon."
    (interactive)
    (emms-stop)
    (call-process "killall" nil nil nil "mpd")
    (message "MPD killed!"))
#+END_SRC

*** Updating the database
#+BEGIN_SRC emacs-lisp
  (defun mpd/update-database ()
    "Update the MPD database synchronously."
    (interactive)
    (call-process "mpc" nil nil nil "update")
    (message "MPD database updated!"))
#+END_SRC

*** Shuffling the playlist
#+BEGIN_SRC emacs-lisp
  (defun farl-emms/shuffle-with-message ()
    "Shuffle the playlist and say so in the echo area."
    (interactive)
    (emms-shuffle)
    (message "Playlist has been shuffled."))
#+END_SRC

** Binding all the keys
Now using a keymap in place of that wonky as crap binding system. The new binds let me use ~emms~ in a terminal.
#+BEGIN_SRC emacs-lisp
  (defvar emms-map
    (let ((map (make-sparse-keymap)))
      ;; Opening playlist and music browser
      (define-key map (kbd "v") 'emms)
      (define-key map (kbd "b") 'emms-smart-browse)
      ;; Track navigation
      (define-key map (kbd "n n") 'emms-next)
      (define-key map (kbd "n p") 'emms-previous)
      (define-key map (kbd "p") 'emms-pause)
      (define-key map (kbd "s") 'emms-stop)
      ;; Repeat/shuffle
      (define-key map (kbd "t C-r") 'emms-toggle-repeat-track)
      (define-key map (kbd "t r") 'emms-toggle-repeat-playlist)
      (define-key map (kbd "t s") 'farl-emms/shuffle-with-message)
      ;; Refreshing various things
      (define-key map (kbd "r c") 'emms-player-mpd-update-all-reset-cache)
      (define-key map (kbd "r d") 'mpd/update-database)
      ;; `mpd'-specific functions
      (define-key map (kbd "d s") 'mpd/start-music-daemon)
      (define-key map (kbd "d q") 'mpd/kill-music-daemon)
      (define-key map (kbd "d u") 'mpd/update-database)
      map)
    "A keymap for controlling `emms'.")
  (global-set-key (kbd "C-c a") emms-map)
#+END_SRC

With EMMS now configured, we can close off this block and move on.
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

* Making Emacs a good text editor
This used to be a mess of different sections, but I've been working to categorize these settings far better. So, much of what was previously elsewhere is now set up in here. Everything in here /should/ be about making Emacs pleasant to use for editing text of various kinds. If it isn't, I have failed.
** Additional major modes
These are modes that enable Emacs to edit different kinds of files differently. Programming major modes are further down, in the programming section.

*** ~graphviz-dot-mode~ (diagram creation)
A nice way to make diagrams.
#+BEGIN_SRC emacs-lisp
  (use-package graphviz-dot-mode
    :ensure t
    :defer t
    :init
    (require 'graphviz-dot-mode))
#+END_SRC

*** ~markdown-mode~ (bootleg org-mode for GitHub)
I really don't like markdown but I have to use it for school, so...
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :defer t)
#+END_SRC

** General functionality
These settings are changes to core functionality more than they are changes that affect editing files.

*** Use UTF-8 encoding
This makes for a much easier time editing files and working with text.
#+BEGIN_SRC emacs-lisp
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC

*** Disable suspending Emacs
Why is this even something bound to begin with?
#+BEGIN_SRC emacs-lisp
  (dolist (key '("C-x C-z"
                 "C-z"))
    (global-unset-key (kbd key)))
#+END_SRC

*** Always confirm closing Emacs
I constantly kill Emacs on accident when running it in terminals, so this prevents me from doing that +as easily+.
#+BEGIN_SRC emacs-lisp
  (setq confirm-kill-emacs 'yes-or-no-p)
#+END_SRC

*** Open configuration with =C-c e=
Since this thing is changing all the time, I really like having it available on a shortcut.
#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    "Open the configuration file."
    (interactive)
    (find-file (expand-file-name "literate-emacs.org"
                                 user-emacs-directory)))

  (global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC

*** Don't unload fonts when not in use
This solves a number of hanging issues related to a number of different packages and symbols.
#+BEGIN_SRC emacs-lisp
  (setq inhibit-compacting-font-caches t)
#+END_SRC

*** Make scrolling a little less crazy
Not sure why the mouse wheel get acceleration, but thankfully I don't have to worry about that anymore.
#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 0
        auto-window-vscroll nil
        scroll-conservatively 100000
        scroll-preserve-screen-position 1
        mouse-wheel-scroll-amount '(1 ((shift) . 1))
        mouse-wheel-progressive-speed nil
        mouse-wheel-follow-mouse t)
#+END_SRC

*** Change current directory with =C-c d=
Useful for getting lost in the filesystem!
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c d") 'cd)
#+END_SRC

*** Enable word wrapping for all buffers
This is a point of convenience, even in programming language buffers. Wrapping words makes for a heck of a lot more readability of any kind of text, whether a program or just normal language.
#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode 1)
#+END_SRC

*** Use a visual bell instead of making noise
Sound is obnoxious and it should be visibly obvious without flashing the frame or mode line that something has gone wrong.
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

*** ~which-key~ (small menus to help with commands)
Even as I've gotten used to Emacs key bindings, it is always nice to have this around so that if I want to know, I can easily see what's what.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :defer t
    :init
    (which-key-mode 1))
#+END_SRC

*** Replace "yes or no" prompts with "y or n" prompts
Beauty in brevity.
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Enable ~ido-mode~, install ~ido-vertical-mode~ and ~smex~
I /love/ ~ido-mode~. However, I /HATE/ ~ido-mode~ right out of the box. A vertical list looks craptons nicer. Both ~ido-mode~ and ~ido-vertical-mode~ are configured in the same block. Default M-x behavior doesn't use ~ido-mode~, so we install a package which gives it ~ido-mode~ capabilities.
#+BEGIN_SRC emacs-lisp
  (use-package ido-vertical-mode
    :ensure t
    :defer t
    :init
    (setq ido-everywhere t
          ido-max-prospects 10
          ido-enable-prefix nil
          ido-enable-flex-matching t
          ido-use-filename-at-point nil
          ido-create-new-buffer 'always
          ido-vertical-define-keys 'C-n-and-C-p-only)
    (ido-mode 1)
    (ido-vertical-mode 1)
    (use-package smex
      :ensure t
      :defer t
      :bind (("M-x"    . smex)
             ("<menu>" . smex))))
#+END_SRC

** Personal save hooks
When I save a file, sometimes I want specific things to be done.

*** Tangle literate programming files
I've gotten really into literate programming lately, so this makes it much easier to tangle files.
#+BEGIN_SRC emacs-lisp
  (defun tangle-literate-program ()
    "Tangle a file if it's a literate programming file."
    (interactive)
    (when (and (equal major-mode 'org-mode)
               (string-match-p "literate" (buffer-file-name)))
      (org-babel-tangle)))

  (add-hook 'after-save-hook 'tangle-literate-program)
#+END_SRC

** Buffers/windows
*** Sloppy focus windows
I hate having to click to focus a different window, so I would rather just have windows sloppily focus.
#+BEGIN_SRC emacs-lisp
  (setq focus-follows-mouse t
        mouse-autoselect-window t)
#+END_SRC

*** Making buffer names unique
This looks a lot fancier than the default behavior.a
#+BEGIN_SRC emacs-lisp
  (setq uniquify-buffer-name-style 'forward
        uniquify-after-kill-buffer-p t)
#+END_SRC

*** Open dashboard with =C-c M-d=
I constantly accidentally close dashboard, so I made a way to open it again if I accidentally kill it.
#+BEGIN_SRC emacs-lisp
  (defun dashboard-restart ()
    "Restart the dashboard buffer and switch to it."
    (interactive)
    (dashboard-insert-startupify-lists)
    (switch-to-buffer "*dashboard*"))

  (global-set-key (kbd "C-c M-d") 'dashboard-restart)
#+END_SRC

*** Balance window sizes with =C-c b=
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c b") 'balance-windows)
#+END_SRC

*** Kill the current buffer with =C-x k=
I had to adjust the function which kills both the current buffer and the current window, because it did not cooperate with EXWM buffers. That's why I have this weird chunk I don't actually have the expertise yet to fully parse.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x k") 'kill-this-buffer)
#+END_SRC

*** Kill both the buffer and window with =C-x C-k=
#+BEGIN_SRC emacs-lisp
  (defun kill-this-buffer-and-window ()
    "Kill the current buffer and delete the selected window.

  This function has been altered to accommodate `exwm-mode'."
    (interactive)
    (let ((window-to-delete (selected-window))
          (buffer-to-kill (current-buffer))
          (delete-window-hook (lambda () (ignore-errors (delete-window)))))
      (unwind-protect
          (progn
            (add-hook 'kill-buffer-hook delete-window-hook t t)
            (if (kill-buffer (current-buffer))
                ;; If `delete-window' failed before, we repeat
                ;; it to regenerate the error in the echo area.
                (when (eq (selected-window) window-to-delete)
                  (delete-window)))))))

  (global-set-key (kbd "C-x C-k") 'kill-this-buffer-and-window)
#+END_SRC

*** Kill all buffers and all windows with =C-x C-M-k=
I wanted a way to quickly and gracefully destroy everything that is open at once.
#+BEGIN_SRC emacs-lisp
  (defun close-buffers-and-windows ()
    "Close every buffer and close all windows, then restart dashboard."
    (interactive)
    (unless (save-some-buffers)
      (when (yes-or-no-p "Really kill all buffers? ")
        (mapc 'kill-buffers (buffer-list))
        (delete-other-windows)
        (dashboard-restart))))

  (global-set-key (kbd "C-x C-M-k") 'close-buffers-and-windows)
#+END_SRC

*** Make the scratch buffer immortal and start blank
I kill the scratch buffer way too often if I don't do this. While I'm here, I might as well also make the scratch buffer blank.
#+BEGIN_SRC emacs-lisp
  (with-current-buffer "*scratch*"
    (emacs-lock-mode 'kill))

  (setq initial-scratch-message "")
#+END_SRC

*** ~buffer-move~ (moving windows) and ~windmove~ (changing focus)
Since apparently =C-x C-o= is actually something useful by default, I decided to squash ~windmove~ and ~buffer-move~ into a single keymap.
#+BEGIN_SRC emacs-lisp
  (use-package buffer-move
    :ensure t
    :defer t
    :init
    (defvar buffer-move-and-windmove-map
      (let ((map (make-sparse-keymap)))
        (define-key map (kbd "w") 'windmove-up)
        (define-key map (kbd "a") 'windmove-left)
        (define-key map (kbd "s") 'windmove-down)
        (define-key map (kbd "d") 'windmove-right)
        (define-key map (kbd "C-w") 'buf-move-up)
        (define-key map (kbd "C-a") 'buf-move-left)
        (define-key map (kbd "C-s") 'buf-move-down)
        (define-key map (kbd "C-d") 'buf-move-right)
        map)
      "A keymap for `buffer-move' and `windmove' functions.")
    (global-set-key (kbd "C-x o") buffer-move-and-windmove-map))
#+END_SRC

*** Move focus and show buffer-menu when explicitly creating new windows
This to me is preferable to the default behavior.
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-vertical ()
    "Open a new window vertically."
    (interactive)
    (split-window-below)
    (other-window 1)
    (ibuffer))

  (defun split-and-follow-horizontal ()
    "Open a new window horizontally."
    (interactive)
    (split-window-right)
    (other-window 1)
    (ibuffer))

  (global-set-key (kbd "C-x 2") 'split-and-follow-vertical)
  (global-set-key (kbd "C-x 3") 'split-and-follow-horizontal)
#+END_SRC

*** Use buffer-menu on =C-x b= so the buffer list doesn't open a new window
Just another point of personal convenience.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x b") 'ibuffer)
  (global-unset-key (kbd "C-x C-b"))
#+END_SRC

** Text editing
These settings are specifically about editing text and making that easier.

*** Spell-checking
Just a useful little tool to check spelling while editing a buffer. Only configured if ~aspell~ is installed. It's not super great, but it does the trick well enough for me.
#+BEGIN_SRC emacs-lisp
  (when (executable-find "aspell")
    (require 'flyspell)

    (setq ispell-program-name "aspell"
          ispell-dictionary "american")

    (add-hook 'flyspell-mode-hook 'flyspell-buffer)
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)
    (add-hook 'text-mode-hook 'flyspell-mode))
#+END_SRC

*** Better search behavior
This search behavior is *SO* much nicer than the default.
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :defer t
    :bind ("C-s" . swiper))
#+END_SRC

*** No backups or auto-saving
I love living on the edge.
#+BEGIN_SRC emacs-lisp
  (setq backup-inhibited t
        make-backup-files nil
        auto-save-default nil)
#+END_SRC

*** Automatically revert files on change
This way if files get modified in the middle of editing them, I don't overwrite the changes. This can also change ~dired~ and ~ibuffer~ buffers if I am not mistaken. However, I don't need to hear every last thing about it.
#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode 1)
  (setq global-auto-revert-non-file-buffers t
        auto-revert-remote-files t
        auto-revert-verbose nil)
#+END_SRC

*** End-of-file newlines and indent tabs
Screw indent tabs, spaces all the way. Also, if there is no end-of-file newline, add it.
#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)
  (setq-default indent-tabs-mode nil)
#+END_SRC

*** Manage the kill ring using a pop-up menu
Having the whole kill ring easy to scroll through is much less hassle than default behavior. We also set up some yanking behavior while we're at it.
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :defer t
    :bind ("M-y" . popup-kill-ring)
    :init
    (setq save-interprogram-paste-before-kill t
          mouse-drag-copy-region t
          mouse-yank-at-point t))
#+END_SRC

*** Delete whatever is selected if typing starts
This is to reflect behavior in other programs.
#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC

*** Hungrily remove all whitespace when deleting
This saves me tons of time when it comes to managing whitespace. Instead of having to repeatedly press delete or backspace, a single keystroke decimates all the whitespace between the point and whatever is in the direction the deletion happens.
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :ensure t
    :defer t
    :init
    (global-hungry-delete-mode 1))
#+END_SRC

*** Move around visible portions of files faster
If I want to hop around in a document without calling swiper, ~avy~ is definitely the way to go.
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :defer t
    :bind ("M-s" . avy-goto-char))
#+END_SRC

*** Move between SubWords as well as between words
This allows for much easier navigation between words when in programming language buffers, but also has utility outside of programming so it's enabled globally.
#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC

*** electric-pair-mode (OH MY GOD THIS IS SO GREAT)
I have no words for how convenient this has been and how much faster I get things done thanks to these five lines of elisp.
#+BEGIN_SRC emacs-lisp
  (setq electric-pair-pairs '((?\{ . ?\})
                              (?\( . ?\))
                              (?\[ . ?\])
                              (?\" . ?\")))
  (electric-pair-mode 1)
  (minibuffer-electric-default-mode 1)
#+END_SRC

*** Kill an entire word when you're in the middle of it
I don't need it super often, but it's still nice to have.
#+BEGIN_SRC emacs-lisp
  (defun whole-kill-word ()
    "Delete an entire word."
    (interactive)
    (backward-word)
    (kill-word 1))

  (global-set-key (kbd "C-c DEL") 'whole-kill-word)
#+END_SRC

*** Edit files with superuser privileges using =C-x C-M-f=
This is especially useful when I'm in my own desktop environment and need to edit system files.
#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :ensure t
    :defer t
    :bind ("C-x C-M-f" . sudo-edit))
#+END_SRC

** Programming
It's slowly growing, but I still truly do not need all that much when it comes to programming, mostly because I don't actually do all that much programming outside what I do for fun... and editing this file.

*** Use SBCL for inferior LISP mode
#+BEGIN_SRC emacs-lisp
  (setq inferior-lisp-program "sbcl")
#+END_SRC

*** ~magit~ (git but in Emacs)
I used to use a terminal for this, but holy crap this is a lot easier, a lot faster, and a whole lot nicer to use overall.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :defer t
    :bind ("C-c g" . magit-status))
#+END_SRC

*** Autocomplete backend
This is the base package. I changed some key bindings to make it more pleasant to use.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :defer t
    :init
    (setq company-idle-delay 0.75
          company-minimum-prefix-length 3)
    (global-company-mode 1)
    :bind (:map company-active-map
           ("M-n" . nil)
           ("M-p" . nil)
           ("C-n" . company-select-next)
           ("C-p" . company-select-previous)
           ("SPC" . company-abort)))
#+END_SRC

*** ~haskell-mode~
I have started to mess around with Haskell, so I needed to grab a mode for that. This supplies basically everything I need as far as I know, e.g. company autocompletion and flycheck information.
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure t
    :defer t
    :init
    (setq haskell-stylish-on-save t)
    :hook ((haskell-mode . interactive-haskell-mode)
           (haskell-mode . turn-on-haskell-doc-mode)
           (haskell-mode . haskell-indentation-mode)
           (haskell-mode . haskell-auto-insert-module-template)))
#+END_SRC

*** Python autocomplete
#+BEGIN_SRC emacs-lisp
  (use-package company-jedi
    :ensure t
    :defer t
    :init
    (add-to-list 'company-backends 'company-jedi))
#+END_SRC

*** On-the-fly syntax checking
This is nice to have so I can be told right away when I'm doing something wrong.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :defer t
    :init
    (global-flycheck-mode 1))
#+END_SRC

*** ~avy~-style navigation but between syntax errors
This one is *SUPER COOL*. Being able to jump straight to a problem is really useful.
#+BEGIN_SRC emacs-lisp
  (use-package avy-flycheck
    :ensure t
    :defer t
    :bind (:map prog-mode-map
           ("C-c C-'" . avy-flycheck-goto-error)))
#+END_SRC

** Org-mode
As I spend more time in Org-mode, the more I need from it.

*** Fancier bullet points
It's kinda slow, but bullet points are very very nice, much better than asterisks.
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :if window-system
    :ensure t
    :defer t
    :hook (org-mode . org-bullets-mode))
#+END_SRC

*** Presentations in Emacs
It's gonna need more polish, but it works.
#+BEGIN_SRC emacs-lisp
  (use-package epresent
    :if window-system
    :ensure t
    :defer t
    :bind (:map org-mode-map
           ("C-c r" . epresent-run)))
#+END_SRC

*** Quality-of-life settings
These are just quick things that make ~org-mode~ much easier to use.
#+BEGIN_SRC emacs-lisp
  (setq org-pretty-entities t
        org-src-fontify-natively t
        org-agenda-use-time-grid nil
        org-fontify-done-headline t
        org-src-tab-acts-natively t
        org-enforce-todo-dependencies t
        org-fontify-whole-heading-line t
        org-agenda-skip-deadline-if-done t
        org-agenda-skip-scheduled-if-done t
        org-fontify-quote-and-verse-blocks t
        org-src-window-setup 'current-window
        org-highlight-latex-and-related '(latex)
        org-ellipsis (if window-system "â¤µ" "...")
        org-hide-emphasis-markers (when window-system t))
#+END_SRC

*** Evaluating Graphviz blocks
Since obviously dot snippets are purely harmless +as far as I know+, I just don't bother with having to confirm evaluation every time I try to update a graphic.
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages 'org-babel-load-languages '((dot . t)))
  (setq org-confirm-babel-evaluate '(lambda (lang body) (not (eq lang "dot"))))
#+END_SRC

*** Shortcuts for various snippets in org-mode
This will expand as I get into more and more languages and take more notes in classes with different snippets of different languages.
#+BEGIN_SRC emacs-lisp
  (dolist (shortcut
           '(("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC")
             ("py" "#+BEGIN_SRC python\n?\n#+END_SRC")
             ("dot" "#+BEGIN_SRC dot :file ?.png :cmdline -Kdot -Tpng\n\n#+END_SRC")
             ("t" "#+BEGIN_SRC text :tangle ?\n\n#+END_SRC")
             ("css" "#+BEGIN_SRC css\n?\n#+END_SRC")))
    (add-to-list 'org-structure-template-alist shortcut))
#+END_SRC

*** Agenda (only enabled if an agenda is found)
I use =C-c M-a= and =C-c s-a= to do things related to my agenda. Only one of my systems actually has my agenda, so this only runs on that machine so I don't try any funny business on other machines.
#+BEGIN_SRC emacs-lisp
  (when (file-exists-p "~/agenda.org")
    (setq org-agenda-files '("~/agenda.org"))

    (defun open-agenda ()
      "Open the agenda file."
      (interactive)
      (find-file "~/agenda.org"))

    (global-set-key (kbd "C-c M-a") 'org-agenda)
    (global-set-key (kbd "C-c s-a") 'open-agenda))
#+END_SRC

*** Use the current window when editing source blocks
This is just a convenience thing.
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC

*** Automatically fix inline images generated for diagrams
This is exactly what I was looking for lmao
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
#+END_SRC

* Making Emacs =e x t e n d=
If it isn't about editing text, playing music, or being my entire desktop environment, it will most likely be found in this section.
** Built-in features
*** Calendar
Weeks start on Monday.
#+BEGIN_SRC emacs-lisp
  (setq calendar-week-start-day 1)
  (global-set-key (kbd "C-c l") 'calendar)
#+END_SRC

*** Calculator
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c c") 'calc)
#+END_SRC

*** Reading the manpages
Wow, there's actually an Emacs mode for this! I put these into the =C-h= binds, since it is a way of getting help, after all. If for some reason ~man~ is working, ~woman~ can still grab a manpage without calling ~man~.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-h 4 m") 'man)
  (global-set-key (kbd "C-h 4 w") 'woman)
#+END_SRC

** Not built-in
*** Emacs is my terminal
I've been jumping between ~vterm~ and ~ansi-term~. In the end ~vterm~ blows ~ansi-term~ clean out of the water. In the off-chance I'm running Emacs in the terminal, =C-c t= can open ~vterm~.
#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :ensure t
    :defer t
    :bind ("C-c t" . vterm))
#+END_SRC

*** Reading ebooks in Emacs
Not the best way to do epub reading, but at least it's in Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package nov
    :ensure t
    :defer t
    :mode ("\\.epub\\'" . nov-mode))
#+END_SRC

*** Getting the weather using Emacs
Picking a service to use for this was a pain. I ended up settling for wttrin because it is the fastest and easiest to use, and plays nice with my setup.
#+BEGIN_SRC emacs-lisp
  (use-package wttrin
    :ensure t
    :defer t
    :init
    (setq wttrin-default-cities '("Indianapolis"))
    :bind ("C-c w" . wttrin))
#+END_SRC

** Games
To make running games easier, I set up a keymap to which I add the games.
#+BEGIN_SRC emacs-lisp
  (defvar games-map
    (make-sparse-keymap)
    "A keymap to which games can be added.")

  (global-set-key (kbd "C-M-g") games-map)
#+END_SRC

*** Yahtzee
Fun dice game from my childhood. Now I can get mad at Emacs instead of my sister.
#+BEGIN_SRC emacs-lisp
  (use-package yahtzee
    :ensure t
    :defer t
    :bind (:map games-map
           ("y" . yahtzee)))
#+END_SRC

*** Sudoku
I /love/ sudoku puzzles.
#+BEGIN_SRC emacs-lisp
  (use-package sudoku
    :ensure t
    :defer t
    :bind (:map games-map
           ("s" . sudoku)))
#+END_SRC

*** Tetris
Tetris is my childhood. No way I wouldn't set it up to be nice and comfy.
#+BEGIN_SRC emacs-lisp
  (use-package tetris
    :ensure t
    :defer t
    :bind (:map games-map
           ("t" . 'tetris)
           :map tetris-mode-map
           ("w" . tetris-move-bottom)
           ("a" . tetris-move-left)
           ("s" . tetris-mode-down)
           ("d" . tetris-move-right)
           ([left] . tetris-rotate-next)
           ([right] . tetris-rotate-prev)
           ([?\t] . tetris-pause-game)
           ("r" . tetris-start-game)
           ("e" . tetris-end-game)))
#+END_SRC

*** Chess
Just for fun. I suck at chess but it's nice to have.
#+BEGIN_SRC emacs-lisp
  (use-package chess
    :ensure t
    :defer t
    :bind (:map games-map
           ("c" . chess)))
#+END_SRC

*** 2048
A simple and fun game. Was a big deal when I was in high school. I still play it from time to time.
#+BEGIN_SRC emacs-lisp
  (use-package 2048-game
    :ensure t
    :defer t
    :bind (:map games-map
           ("2" . 2048-game)))
#+END_SRC
* Giving ~init.el~ a footer
Since we gave ~init.el~ a header, I see no reason not to give it a footer.
#+BEGIN_SRC emacs-lisp
  ;;; init.el ends here
#+END_SRC
