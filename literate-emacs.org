#+TITLE: Farlado's Illiterate GNU Emacs
#+SUBTITLE: A far-from-sane literate Emacs configuration
#+LANGUAGE: en
#+OPTIONS: num:2 toc:2
#+PROPERTY: header-args :tangle (concat user-emacs-directory "init.el")

#+BEGIN_QUOTE
Overall, I think text editing is a solved problem. Text editors are like wine. The older the better. You do not want a shiny new text editor. You want the text editor that has been around long enough and used by enough geeks that every conceivable pattern of manipulating symbols on the screen has been thought of, and crystallized into a re-usable pack. -- [[https://blog.vivekhaldar.com/post/31970017734/new-frontiers-in-text-editing][Vivek Haldar]]
#+END_QUOTE

* About this configuration
This file is an attempt at a literate GNU Emacs (henceforth "Emacs") configuration. Admittedly, much of the "documentation" in here is more commentary I provide about my choices and personal feelings about certain things in Emacs based on my admittedly very limited opinion of the program than honest-to-god documentation of what this file contains. Regardless, the idea is that this file, when tangled, generates everything in my git repository, from ~LICENSE~ to ~init.el~. I would /highly/ recommend you *NOT* try to read the ~init.el~ file itself. It's a jungle, especially since all of the commentary regarding the configuration is in this file and not in ~init.el~.

** Okay, that's pretty neat. Why though?
The answer is rather simple. Before I used a fully literate, I had an ~init.el~ which tangled blocks from a ~config.org~ on the fly (read: on startup). It turns out this was abysmally slow, making for a startup time of around 4.5 seconds when loading into my desktop environment. Tangling blocks from a ~literate-emacs.org~ into an ~init.el~ cuts this time by about a third, around 2.8 seconds to load into my desktop environment. This also comes with the advantage of being a hub for /all/ things related to my Emacs configuration, where previously I had to check both ~init.el~ and ~config.org~ when I thought I might have changed something for the worse.

** Installation
/Note: these instructions are for users of GNU/Linux or other *NIX systems./
1) Clone the repo into your home directory as ~.emacs.d~.
2) Make sure you have all the right dependencies. See below for more details.
3) If using Emacs as a desktop environment, it may take a couple restarts to work right.

** Dependencies
Everything has different dependencies so make sure you have what you need. The easy route to getting all these dependencies installed and configured is to deploy [[https://github.com/farlado/dotfiles][my dotfiles]]:
#+BEGIN_SRC sh :tangle no
  sh -c "$(curl https://raw.githubusercontent.com/farlado/dotfiles/master/.config/deploy/deploy)"
#+END_SRC

|----------------------+--------------------------------------------|
| ~EXWM~ depends on...   | which is used for...                       |
|----------------------+--------------------------------------------|
| ~xorg~                 | obvious reasons                            |
| ~wmctrl~               | checking for a window manager              |
| ~xbanish~              | hiding the cursor while typing             |
| ~xcompmgr~             | compositor                                 |
| ~arandr~               | monitor configuration                      |
| ~nm-connection-editor~ | network configuration                      |
| ~firefox~              | browsing the web                           |
| ~libreoffice~          | editing unfriendly documents               |
| ~gimp~                 | editing images (Emacs can't do this sadly) |
| ~musescore~            | editing music                              |
| ~telegram~             | crappy messenger                           |
| ~discord~              | crappier messenger                         |
| ~steam~                | games platform                             |
|----------------------+--------------------------------------------|


|-----------------------------------+--------------------------------------|
| ~desktop-environment~ depends on... | which is used for...                 |
|-----------------------------------+--------------------------------------|
| ~alsa-utils~                        | volume adjustment                    |
| ~brightnessctl~                     | laptop backlight adjustment          |
| ~maim~                              | screenshots                          |
| ~xclip~                             | copying screenshots to the clipboard |
| ~i3lock-color~                      | lock screen                          |
|-----------------------------------+--------------------------------------|


|-------------------+---------------------+------------------------------------|
| Emacs uses...     | which depends on... | which is used for...               |
|-------------------+---------------------+------------------------------------|
| ~EMMS~              | ~mpd~                 | playing music                      |
|-------------------+---------------------+------------------------------------|
| ~vterm~             | ~cmake~               | handles the makefile               |
|                   | ~gcc~                 | any C compiler will do             |
|                   | ~libtool~             | make dependency                    |
|-------------------+---------------------+------------------------------------|
| ~nov~               | ~ebook-tools~         | opening epub files                 |
|-------------------+---------------------+------------------------------------|
| ~graphviz-dot-mode~ | ~graphviz~            | process dot files                  |
|-------------------+---------------------+------------------------------------|
| ~flyspell-mode~     | ~aspell~              | spell checking                     |
|-------------------+---------------------+------------------------------------|
| ~wttrin~            | ~curl~                | get weather data from the internet |
|-------------------+---------------------+------------------------------------|
| ~sudo-edit~         | ~sudo~                | duh                                |
|-------------------+---------------------+------------------------------------|
| ~flycheck~          | ~pylint~              | Python syntax checking             |
|-------------------+---------------------+------------------------------------|
| ~company~           | ~jedi~                | Python autocomplete                |
|-------------------+---------------------+------------------------------------|
| ~haskell-mode~      | ~stack~               | everything about Haskell           |
|-------------------+---------------------+------------------------------------|

** License
Because I +am a lazy piece of shit who doesn't like long licenses+ do not think much harm could come from using a pushover license for an Emacs configuration, I am publishing this literate Emacs configuration under the WTFPL.
#+BEGIN_SRC text :tangle LICENSE
  DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
  Version 2, December 2004

  Copyright (c) 2019-20 Farlado

  Everyone is permitted to copy and distribute verbatim or modified
  copies of this license document, and changing it is allowed as long
  as the name is changed.

             DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

   0. You just DO WHAT THE FUCK YOU WANT TO.
#+END_SRC

* Giving ~init.el~ a header
In order to make the file look at least somewhat decent, and to warn those who are unfortunate enough to think they'll just mosey on into ~init.el~ if they want to understand the config, we create a header that tells people the reality of the file.
#+BEGIN_SRC emacs-lisp
  ;;; init.el --- Initializing Emacs

  ;; This file is not part of GNU Emacs.
  
  ;;; Commentary:

  ;; This file has been automatically generated from `literate-emacs.org'.
  ;; If you don't have a copy of that file, it is best not to use this file!
  ;; All relevant commentary is in `literate-emacs.org', not here.
  ;; There may not be any comments past this point.
  ;; Abandon all hope, ye who enter here.
  
  ;;; Code:
#+END_SRC

* Making Emacs start quickly and smoothly
Even with the "small" amount I ask of Emacs, it's a lot of beef to start up as fast as I demand it start up. This is, of course, everything I want to run at startup, but also a few other settings which make more sense to set here, instead of later.

** Do these ASAP
Either I want these configured as soon as possible, or they are related to Emacs starting up. Which are which is left as an exercise to the reader.

*** Hide dumb stuff
I want to get GUI elements out of my face as soon as I possibly can. They just take up space.
#+BEGIN_SRC emacs-lisp
  (tooltip-mode -1)
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (setq use-dialog-box nil
        use-file-dialog nil)
#+END_SRC

*** Disable customize
I /hate/ ~customize~. I configure everything in this file, so I don't need anything messing with my ~init.el~, much less changing settings on me.
#+BEGIN_SRC emacs-lisp
  (setq custom-file "/dev/null")
#+END_SRC

*** Load newest bytecode
Always prefer the newest files when loading.
#+BEGIN_SRC emacs-lisp
  (setq load-prefer-newer t)
#+END_SRC

*** More complete apropos
This way, apropos does things more thoroughly, even if it's marginally slower.
#+BEGIN_SRC emacs-lisp
  (setq-default apropos-do-all t)
#+END_SRC

*** File name handling setup
For whatever reason, setting ~file-name-handler-alist~ to nil helps Emacs load faster. After Emacs finishes loading, it's reverted to its original value.
#+BEGIN_SRC emacs-lisp
  (defvar startup/file-name-handler-alist file-name-handler-alist
    "Temporary storage for `file-name-handler-alist' during startup.")

  (defun startup/revert-file-name-handler-alist ()
    "Revert `file-name-handler-alist' to its default value after startup."
    (setq file-name-handler-alist startup/file-name-handler-alist))

  (setq file-name-handler-alist nil)

  (add-hook 'emacs-startup-hook 'startup/revert-file-name-handler-alist)
#+END_SRC

*** Garbage collection postponing
Garbage collection shouldn't happen during startup, as that will slow Emacs down. Do it later. This is also where more ideal garbage collection settings are chosen.
#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6)

  (defun startup/reset-gc ()
    "Return garbage collection to normal parameters after startup."
    (setq gc-cons-threshold 16777216
          gc-cons-percentage 0.1))

  (add-hook 'emacs-startup-hook 'startup/reset-gc)
#+END_SRC

** Package management
Because I am writing this configuration to be as portable as possible (e.g. I should be able to dump this onto any machine and run it), I manage all packages through Emacs.

*** Protect packages from ~package-autoremove~
Since I do not use ~customize~ but really like protecting packages used in my configuration from ~package-autoremove~, I need to still set ~package-selected-packages~ so that it'll work.
#+BEGIN_SRC emacs-lisp
  (setq package-selected-packages
        '(async use-package auto-package-update dashboard exwm dmenu desktop-environment
          system-packages emms avy ido-vertical-mode buffer-move sudo-edit 2048-game
          graphviz-dot-mode vterm nov wttrin chess sudoku smex which-key popup-kill-ring
          swiper hungry-delete magit flycheck avy-flycheck company-jedi haskell-mode
          markdown-mode org-bullets epresent leuven-theme pretty-mode rainbow-mode
          rainbow-delimiters spaceline diminish))
#+END_SRC

*** Disable an annoying customize function
Since I don't use ~customize~, we don't need to mess with it every time a package is installed or uninstalled. Because of this, I need to first load everything related to package management.
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (defun package--save-selected-packages (&rest opt) nil)
#+END_SRC

*** Configure package repositories
Next, we have to configure a setting for sanity and add our repositories to the list.
#+BEGIN_SRC emacs-lisp
  (setq package-enable-at-startup nil
        package-archives '(("gnu"   . "https://elpa.gnu.org/packages/")
                           ("melpa" . "https://melpa.org/packages/")
                           ("org"   . "https://orgmode.org/elpa/")))
#+END_SRC

*** Initialize package management
Finally, we call ~package-initialize~. We only need to do this if we're running on Emacs 26 or below. Emacs 27 and beyond no longer require this call.
#+BEGIN_SRC emacs-lisp
  (when (< emacs-major-version 27)
    (package-initialize))
#+END_SRC

*** Bootstrap ~async~
This package is super useful for making package installation significantly faster. It also allows for asynchronous ~dired~.
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'async)
    (package-refresh-contents)
    (package-install 'async))

  (dired-async-mode 1)
  (async-bytecomp-package-mode 1)
  (setq async-bytecomp-allowed-packages '(all))
#+END_SRC

*** Bootstrap ~use-package~
Since I manage all Emacs packages in Emacs via this file, ~use-package~ makes it much easier to install all the packages I need. It also means I can see what packages take the longest to load.
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (setq use-package-compute-statistics t)
#+END_SRC

*** Automatically update packages
I don't want to have to manually update my stuff. This solution is literally plop-and-forget, and updates packages once a certain number of days has passed since the last time I updated packages.
#+BEGIN_SRC emacs-lisp
  (use-package auto-package-update
    :ensure t
    :defer t
    :init
    (setq auto-package-update-interval 2
          auto-package-update-delete-old-versions t
          auto-package-update-hide-results t)
    (auto-package-update-maybe))
#+END_SRC

** After everything else
These are other startup specific things, but they are not necessarily as pressing to startup as everything else.

*** Start Emacs server
Having the Emacs server running allows for a lot of neat integration with other parts of my destop environment. However, I don't want it to start too soon.
#+BEGIN_SRC emacs-lisp
  (require 'server)

  (defun server-start-if-not-running ()
    "Call `server-start' if `server-running-p' returns nil."
    (unless (server-running-p)
      (server-start)))

  (add-hook 'after-init-hook 'server-start-if-not-running)
#+END_SRC

*** dashboard package (replacement start screen)
I like the default start screen, but it just doesn't cut it for me. I just use this to have a nice screen when I start Emacs or close all my buffers.
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :defer t
    :init
    (setq dashboard-set-footer nil
          inhibit-startup-screen t
          dashboard-items '((recents . 10))
          dashboard-startup-banner 'official
          initial-buffer-choice (lambda () (get-buffer "*dashboard*"))
          dashboard-banner-logo-title "Welcome to Farlado's Illiterate GNU Emacs!")
    (dashboard-setup-startup-hook))
#+END_SRC

* Making Emacs significantly less ugly
Stock Emacs is /ugly/. Just straight up ugly. Suffice to say it leaves much to be desired.

** Font
*** Setting the font style
Originally I had this set up by means of ~custom-set-faces~, but frankly that is less easily configured than this method. First, we determine whether my preferred font is present on the system and set it if present. Otherwise, keep whatever default font Emacs chooses.
#+BEGIN_SRC emacs-lisp
  (when (member "Iosevka" (font-family-list))
    (set-face-attribute 'default nil :font "Iosevka"))
#+END_SRC

*** Determining a good font size
Next we need to determine what size to make the text. This is based on the width of the screens I regularly use. It uses shell commands for X window systems and built-in functions for Windows.
#+BEGIN_SRC emacs-lisp
  (let* ((res (if (eq window-system 'x)
                  (string-to-number
                   (shell-command-to-string
                    (concat "xrandr | grep \\* | "
                            "cut -d x -f 1 | "
                            "sort -n | head -n 1")))
                (/ (display-pixel-width) (display-screens))))
         (size (if (<= res 1366) 100
                 (if (<= res 1920) 150
                   (if (<= res 2560) 180
                     (if (<= res 3840) 220
                       240))))))
    (set-face-attribute 'default nil :height size))
#+END_SRC

** Theme
*** ~leuven-theme~ (my theme of choice)
I used to hate light themes. I'm not in that camp anymore. This theme is /elegant/.
#+BEGIN_SRC emacs-lisp
  (use-package leuven-theme
    :if window-system
    :ensure t
    :defer t
    :init
    (setq leuven-scale-org-agenda-structure t
          leuven-scale-outline-headlines t)
    (load-theme 'leuven t))
#+END_SRC

*** Fringes and dividers
Fringes and windows dividers make Emacs look far less sloppy. The color is grabbed from the mode line for consistency.
#+BEGIN_SRC emacs-lisp
  (setq window-divider-default-right-width 3)
  (dolist (face '(window-divider-first-pixel
                  window-divider-last-pixel
                  window-divider))
    (set-face-foreground face (face-attribute 'mode-line :background)))
  (window-divider-mode 1)
  (fringe-mode 10)
#+END_SRC

** Mode line
*** Use the mode line from Spacemacs
I *hate* the default mode line. The mode line from Spacemacs, ~spaceline~, is much less sucky. I also show and hide specific things when setting it up. In terminals, ~spaceline-emacs-theme~ just looks wrong, so I don't use it unless I'm in a graphical environment.
#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :ensure t
    :defer t
    :init
    (require 'spaceline-config)
    (setq powerline-default-separator 'wave
          spaceline-buffer-encoding-abbrev-p nil
          spaceline-buffer-size-p nil
          spaceline-line-column-p t
          column-number-indicator-zero-based nil)
    (if window-system
        (spaceline-emacs-theme)
      (spaceline-spacemacs-theme)))
#+END_SRC

*** Show clock and battery level on mode line
I use 24-hour time on all my clocks. I used to use ~fancy-battery~ for battery level but it constantly disappeared on my teeny tiny screens so I just decided not to bother with it. Plus it's one less package to configure lol.
#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format t)
  (display-time-mode 1)
  (display-battery-mode 1)
#+END_SRC

*** Hide various minor modes from the mode line
Works very nicely, makes the mode line far comfier. I set its installation as a hook so that I can keep the look section up a little higher.
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t
    :defer t
    :init
    (defun diminish-minor-modes ()
      "Diminish the minor modes in the list `minor-modes-to-diminish'."
      (dolist (mode minor-modes-to-diminish)
        (diminish mode)))
    (defvar minor-modes-to-diminish '(eldoc-mode
                                      subword-mode
                                      company-mode
                                      rainbow-mode
                                      flycheck-mode
                                      flyspell-mode
                                      which-key-mode
                                      auto-revert-mode
                                      visual-line-mode
                                      haskell-doc-mode
                                      flyspell-prog-mode
                                      hungry-delete-mode
                                      page-break-lines-mode
                                      desktop-environment-mode
                                      haskell-indentation-mode
                                      interactive-haskell-mode
                                      compilation-shell-minor-mode)
      "Minor modes to diminish using `diminish-minor-modes'.")
    (add-hook 'after-init-hook 'diminish-minor-modes))
#+END_SRC

** In buffers
*** Turn ^L into pretty lines
This is used in a number of places in Emacs. Better to have it on all the time than never on.
#+BEGIN_SRC emacs-lisp
  (global-page-break-lines-mode 1)
#+END_SRC

*** Line numbers (on most buffers)
I like having line numbers and indicators for lines past the EOF. However, I don't like line numbers in modes where it breaks the mode.
#+BEGIN_SRC emacs-lisp
  (global-display-line-numbers-mode 1)
  (setq-default indicate-empty-lines t)

  (dolist (hook '(Man-mode-hook
                  nov-mode-hook
                  shell-mode-hook
                  vterm-mode-hook
                  shell-mode-hook
                  snake-mode-hook
                  tetris-mode-hook
                  sudoku-mode-hook
                  custom-mode-hook
                  ibuffer-mode-hook
                  epresent-mode-hook
                  dashboard-mode-hook))
    (add-hook hook (lambda () (display-line-numbers-mode -1))))
#+END_SRC

*** Highlight matching parentheses
For those moments where I can't figure out what is going on with the parentheses...
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (setq show-paren-style 'parenthesis
        show-paren-delay 0)
#+END_SRC

*** Prettify various symbols in programming buffers
I don't like ~prettify-symbols-mode~. It doesn't do enough. This one helps so much more to make things look nice, especially in functional programming languages. I enable /all/ of them.
#+BEGIN_SRC emacs-lisp
  (use-package pretty-mode
    :if window-system
    :ensure t
    :defer t
    :init
    (global-pretty-mode 1)
    (pretty-activate-groups '(:nil
                              :sets
                              :logic
                              :greek
                              :types
                              :other
                              :arrows
                              :ordering
                              :equality
                              :function
                              :undefined
                              :arithmetic
                              :parentheses
                              :punctuation
                              :quantifiers
                              :sub-and-superscripts)))
#+END_SRC

*** Color the background of text based on the color/hex typed
I don't use it too much, but it's nice to have it around.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :if window-system
    :ensure t
    :defer t
    :init
    (define-globalized-minor-mode global-rainbow-mode rainbow-mode rainbow-mode)
    (global-rainbow-mode 1))
#+END_SRC

*** Change the color of various delimiters based on how deep they go
It's subtle on my theme, but it still helps me keep track of my brackets and parentheses.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :if window-system
    :ensure t
    :defer t
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

* Making Emacs a desktop environment
Yes, Emacs is my *entire desktop environment*. You should probably remove this stuff if you don't plan to use Emacs as your desktop environment. It's loaded right after the startup commands so that I can bind keys more easily later on. I sometimes have to run Emacs in Windows, so I really don't want this running when I'm not in an X window system. Before I get ahead of myself, I check whether there's already a running window manager.
#+BEGIN_SRC emacs-lisp
  (when (and (eq window-system 'x)
           (= (shell-command "wmctrl -m  1> /dev/null 2> /dev/null") 1))
    (set-frame-parameter nil 'fullscreen 'fullboth)
#+END_SRC

** Configuration
*** Installing the base window manager
This isn't actually where we do all the configuration, it's just where we install EXWM and load what we need to configure it. Usually it is best to configure packages inside of ~use-package~, but that would be a horrible idea due to just how many different things there are that need configuring.
#+BEGIN_SRC emacs-lisp
  (use-package exwm
    :ensure t
    :defer t
    :init
    (require 'exwm)
    (require 'exwm-randr)
    (require 'exwm-config)
    (require 'exwm-systemtray))
#+END_SRC

*** Getting a ~dmenu~ equivalent
Since I'm using Emacs as a window manager, I need ~dmenu~ so I can open X windows I haven't bound to keys. It will be bound elsewhere.
#+BEGIN_SRC emacs-lisp
  (use-package dmenu
    :ensure t
    :defer t)
#+END_SRC

*** ~desktop-environment-mode~
Previously I had to define a lot of functions to do these things, now I just change settings within ~desktop-environment-mode~.
#+BEGIN_SRC emacs-lisp
  (use-package desktop-environment
    :ensure t
    :defer t
    :init
    (desktop-environment-mode 1))
#+END_SRC
**** Volume adjustment
The only things I really don't like here are how much output it gives when you mute or unmute the speakers or microphone, so I set up basic scripts to give much more concise output.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-volume-toggle-command
        (concat "[ \"$(amixer set Master toggle | grep off)\" ] "
                "&& echo Volume is now muted. | tr '\n' ' ' "
                "|| echo Volume is now unmuted. | tr '\n' ' '")
        desktop-environment-volume-toggle-microphone-command
        (concat "[ \"$(amixer set Capture toggle | grep off)\" ] "
                "&& echo Microphone is now muted. | tr '\n' ' ' "
                "|| echo Microphone is now unmuted | tr '\n' ' '"))
#+END_SRC
**** Brightness adjustment
This one all I needed to do was change the increment and decrement values.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-brightness-normal-increment "5%+"
        desktop-environment-brightness-normal-decrement "5%-")
#+END_SRC
**** Screenshots
This one was the least straightforward because the way it's implemented by ~desktop-environment~ is *SUPER* wonky. Here are the binds which will be relevant.
#+BEGIN_SRC emacs-lisp
  ;; Storing to clipboard
  (define-key desktop-environment-mode-map (kbd "<print>")
    'farl-de/desktop-environment-screenshot-part-clip)
  (define-key desktop-environment-mode-map (kbd "<S-print>")
    'farl-de/desktop-environment-screenshot-clip)

  ;; Storing to file
  (define-key desktop-environment-mode-map (kbd "<C-print>")
    'farl-de/desktop-environment-screenshot-part)
  (define-key desktop-environment-mode-map (kbd "<C-S-print>")
    'farl-de/desktop-environment-screenshot)
#+END_SRC
First, I set what directory to store screenshots in.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-screenshot-directory "~/screenshots")
#+END_SRC
Then, I can set the commands for taking a full or partial screenshot and saving it to a file.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-screenshot-command
        "FILENAME=$(date +'%Y-%m-%d-%H:%M:%S').png && maim $FILENAME"
        desktop-environment-screenshot-partial-command
        "FILENAME=$(date +'%Y-%m-%d-%H:%M:%S').png && maim -s $FILENAME")
#+END_SRC
The functions which ~desktop-environment~ comes with are kinda garbage, so I made my own.
#+BEGIN_SRC emacs-lisp
  (defun farl-de/desktop-environment-screenshot ()
    "Take a screenshot and store it in a file."
    (interactive)
    (desktop-environment-screenshot)
    (message "Screenshot saved in ~/screenshots."))

  (defun farl-de/desktop-environment-screenshot-part ()
    "Take a capture of a portion of the screen and store it in a file."
    (interactive)
    (desktop-environment-screenshot-part)
    (message "Screenshot saved in ~/screenshots."))

  (defun farl-de/desktop-environment-screenshot-clip ()
    "Take a screenshot and put it in the clipboard."
    (interactive)
    (shell-command (concat desktop-environment-screenshot-command
                           " && xclip $FILENAME -selection clipboard "
                           "-t image/png &> /dev/null && rm $FILENAME"))
    (message "Screenshot copied to clipboard."))

  (defun farl-de/desktop-environment-screenshot-part-clip ()
    "Take a shot of a portion of the screen and put it in the clipboard."
    (interactive)
    (shell-command (concat desktop-environment-screenshot-partial-command
                           " && xclip $FILENAME -selection clipboard "
                           "-t image/png &> /dev/null && rm $FILENAME"))
    (message "Screenshot copied to clipboard."))
#+END_SRC
**** Lock screen
Haha yes, this is very long and very very stupid.
#+BEGIN_SRC emacs-lisp
  (setq desktop-environment-screenlock-command
        (concat "i3lock -nmk --color=000000 --timecolor=ffffffff --datecolor=ffffffff "
                "--wrongcolor=ffffffff --ringcolor=00000000 --insidecolor=00000000 "
                "--keyhlcolor=00000000 --bshlcolor=00000000 --separatorcolor=00000000 "
                "--ringvercolor=00000000 --insidevercolor=00000000 --linecolor=00000000 "
                "--ringwrongcolor=00000000 --insidewrongcolor=00000000 --timestr=%H:%M "
                "--datestr='%a %d %b' --time-font=Iosevka --date-font=Iosevka "
                "--wrong-font=Iosevka --timesize=128 --datesize=64 --wrongsize=32 "
                "--time-align 0 --date-align 0 --wrong-align 0 --indpos=-10:-10 "
                "--timepos=200:125 --datepos=200:215 --wrongpos=200:155 --locktext='' "
                "--lockfailedtext='' --noinputtext='' --radius 1 --ring-width 1 "
                " --veriftext='' --wrongtext='WRONG' --force-clock"))
#+END_SRC

*** System package management
This one is a pleasant surprise to have honestly. Having Emacs handle system packages as well as its own is a very pleasant surprise. Since I use ~yay~ on Arch, I configure an entry for it and use it if it's installed.
#+BEGIN_SRC emacs-lisp
  (use-package system-packages
    :ensure t
    :defer t
    :init
    (when (executable-find "yay")
      (require 'system-packages)
      (add-to-list 'system-packages-supported-package-managers
                   '(yay .
                         ((default-sudo . nil)
                          (install . "yay -S")
                          (search . "yay -Ss")
                          (uninstall . "yay -Rs")
                          (update . "yay -Syu")
                          (clean-cache . "yay -Sc")
                          (log . "car /var/log/pacman.log")
                          (get-info . "yay -Qi")
                          (get-info-remote . "yay -Si")
                          (list-files-provided-by . "yay -Ql")
                          (verify-all-packages . "yay -Qkk")
                          (verify-all-dependencies . "yay -Dk")
                          (remove-orphaned . "yay -Rns $(yay -Qtdq)")
                          (list-installed-packages . "yay -Qe")
                          (list-installed-packages-all . "yay -Q")
                          (list-dependencies-of . "yay -Qi")
                          (noconfirm . "--noconfirm"))))
      (setq system-packages-use-sudo nil
            system-packages-package-manager 'yay))
    :bind (("C-c p i" . system-packages-install)
           ("C-c p e" . system-packages-ensure)
           ("C-c p u" . system-packages-update)
           ("C-c p r" . system-packages-uninstall)
           ("C-c p o" . system-packages-remove-orphaned)
           ("C-c p c" . system-packages-clean-cache)
           ("C-c p l" . system-packages-log)
           ("C-c p s" . system-packages-search)
           ("C-c p g" . system-packages-get-info)
           ("C-c p d" . system-packages-list-dependencies-of)
           ("C-c p f" . system-packages-list-files-provided-by)
           ("C-c p p" . system-packages-list-installed-packages)
           ("C-c p f" . system-packages-verify-all-dependencies)
           ("C-c p v" . system-packages-verify-all-packages)))
#+END_SRC

*** Workspace configuration
No clue why you have to do so much just to give workspaces names, but at least you can do it. I also put which monitors to try to put workspaces onto here, alongside settings for which windows should float and which workspaces they should be on.
#+BEGIN_SRC emacs-lisp
  (setq exwm-workspace-number 3
        exwm-workspace-index-map (lambda (index)
                                   (let ((named-workspaces ["1" "2" "3"]))
                                     (if (< index (length named-workspaces))
                                         (elt named-workspaces index)
                                       (number-to-string index))))
        exwm-randr-workspace-output-plist '(0 "LVDS1"
                                            0 "LVDS-1"
                                            0 "eDP-1-1"
                                            0 "DP-1-2-2"
                                            1 "DP-1-2-1"
                                            2 "DP-1-2-3")
        exwm-manage-configurations '(((string= exwm-class-name "Steam")
                                      floating-mode-line nil
                                      workspace 0
                                      floating t)
                                     ((string= exwm-instance-name "telegram-desktop")
                                      workspace 2)
                                     ((string= exwm-class-name "discord")
                                      workspace 1)
                                     ((string= exwm-title "Event Tester")
                                      floating-mode-line nil
                                      floating t)))
#+END_SRC
Additionally, I define functions for switching between workspaces, to make the global binds down the line look significantly cleaner.
#+BEGIN_SRC emacs-lisp
  (defun farl-exwm/workspace-0 ()
    "Switch to EXWM workspace 0."
    (interactive)
    (exwm-workspace-switch-create 0))

  (defun farl-exwm/workspace-1 ()
    "Switch to EXWM workspace 1."
    (interactive)
    (exwm-workspace-switch-create 1))

  (defun farl-exwm/workspace-2 ()
    "Switch to EXWM workspace 2."
    (interactive)
    (exwm-workspace-switch-create 2))
#+END_SRC

*** Multi-head configuration
Thankfully, EXWM comes with hooks to handle when monitors are connected and disconnected, so I can set up an elisp function to handle monitor changes for me.
#+BEGIN_SRC emacs-lisp
  (defun display-and-dock-setup ()
    "Configure monitors and peripherals."
    ;; Monitors (works on both my X230 and my W541)
    (let* ((connected-monitors (split-string
                                (shell-command-to-string
                                 "xrandr | grep ' connected' | awk '{print $1}'")))
           (possible-monitors (if (member "LVDS-1" connected-monitors)
                                  '("LVDS-1" "VGA-1")
                                (if (member "LVDS1" connected-monitors)
                                    '("LVDS1" "VGA1")
                                  '("eDP-1-1" "DP-1-2-1" "DP-1-2-2"
                                    "DP-1-2-3" "VGA-1-1"))))
           (command "xrandr "))
      (dolist (monitor possible-monitors)
        (if (and (member monitor connected-monitors)
               (not (and (eq monitor "eDP-1-1")
                     (member "DP-1-2-1" connected-monitors))))
            (let* ((output (concat "--output " monitor " "))
                   (primary (when (or (eq monitor "LVDS-1")
                                     (eq monitor "eDP-1-1")
                                     (eq monitor "DP-1-2-2"))
                              "--primary "))
                   (rate (when (eq monitor "DP-1-2-2")
                           "--rate 75 "))
                   (res (concat "--mode " (if (or (eq monitor "LVDS-1")
                                                 (eq monitor "VGA-1"))
                                              "1366x768 "
                                            "1920x1080 ")))
                   (rotate (when (or (eq monitor "DP-1-2-1")
                                    (eq monitor "DP-1-2-3"))
                             (concat "--rotate " (if (eq monitor "DP-1-2-1")
                                                     "left "
                                                   "right "))))
                   (pos (concat "--pos " (if (not (or (eq monitor "DP-1-2-2")
                                                   (eq monitor "DP-1-2-3")))
                                             "0x0 "
                                           (if (eq monitor "DP-1-2-2")
                                               "1080x0 "
                                             "3000x0 ")))))
              (setq command (concat command output primary rate res rotate pos)))
          (setq command (concat command "--output " monitor " --off "))))
      (start-process-shell-command
       "Display Setup" nil command))
    ;; Disable trackpad
    (start-process-shell-command
     "Disable trackpad" nil (concat "xinput disable $(xinput list | "
                                  "grep Synaptics | head -n 1 | "
                                  "sed -r 's/.*id=([0-9]+).*/\\1/')"))
    ;; Configure trackball
    (let* ((trackball-id (shell-command-to-string
                          (concat "xinput | grep ELECOM | head -n 1 | sed -r "
                                  "'s/.*id=([0-9]+).*/\\1/' | tr '\\n' ' '"))))
      (dolist (command '("'libinput Button Scrolling Button' 10"
                         "'libinput Scroll Method Enabled' 0 0 1"))
        (start-process-shell-command
         "Trackball Setup" nil (concat "sleep 2 && xinput set-prop "
                                     trackball-id command)))
      (start-process-shell-command
       "Trackball Setup" nil (concat "sleep 2 && xinput set-button-map " trackball-id
                                   "1 2 3 4 5 6 7 8 9 2 1 2")))
    ;; Keyboard
    (start-process-shell-command
     "Keyboard Setup" nil "setxkbmap -option ctrl:nocaps"))

  (add-hook 'exwm-randr-screen-change-hook 'display-and-dock-setup)
  (exwm-randr-enable)
#+END_SRC

*** Configure floating window borders
Uses the same color as my mode line, uses the same width as window divider width. See below.
#+BEGIN_SRC emacs-lisp
  (setq exwm-floating-border-width 3
        exwm-floating-border-color (face-attribute 'mode-line :background))
#+END_SRC

*** Name EXWM buffers after the window title
This was annoying when I first installed EXWM. Thankfully this is a very easy fix.
#+BEGIN_SRC emacs-lisp
  (add-hook 'exwm-update-title-hook
            (lambda () (exwm-workspace-rename-buffer exwm-title)))
#+END_SRC

*** Ensure Java applications know the WM is non-reparenting
Stolen from the ~.xinitrc~ included with ~EXWM~.
#+BEGIN_SRC emacs-lisp
  (setenv "_JAVA_AWT_WM_NONREPARENTING" "1")
#+END_SRC

*** X applications
**** GIMP
Until GIMP's functionality gets merged into Emacs, guess I'm stuck having it.
#+BEGIN_SRC emacs-lisp
  (defun run-gimp ()
    "Start GIMP."
    (interactive)
    (start-process-shell-command
     "GIMP" nil "gimp"))
#+END_SRC
**** Steam
Gaming is possible with EXWM, if you run games windowed.
#+BEGIN_SRC emacs-lisp
  (defun run-steam ()
    "Start Steam."
    (interactive)
    (start-process-shell-command
     "Steam" nil "steam"))
#+END_SRC
**** Firefox
Firefox has some unique abilities when it comes to how to make windows behave which work better for me. I don't use tabs, and I don't want anything to do with them, and Firefox lets me hide the tab bar and force all tabs to actually open as new windows. It's like Suckless Surf, but orders of magnitude better.
#+BEGIN_SRC emacs-lisp
  (defun run-firefox ()
    "Start Firefox."
    (interactive)
    (start-process-shell-command
     "Firefox" nil "firefox"))
#+END_SRC
**** Discord
Yeah, I also use the light theme for Discord. It looks comfy, even if Discord is a garbage application.
#+BEGIN_SRC emacs-lisp
  (defun run-discord ()
    "Start Discord."
    (interactive)
    (start-process-shell-command
     "Discord" nil "discord"))
#+END_SRC
**** Telegram
I have a painfully white theme which fits perfectly with my setup.
#+BEGIN_SRC emacs-lisp
  (defun run-telegram ()
    "Start Telegram."
    (interactive)
    (start-process-shell-command
     "Telegram" nil "telegram-desktop"))
#+END_SRC
**** MuseScore
I haven't figured out how to engrave in Emacs, so for now...
#+BEGIN_SRC emacs-lisp
  (defun run-musescore ()
    "Start MuseScore."
    (interactive)
    (start-process-shell-command
     "MuseScore" nil "musescore"))
#+END_SRC
**** LibreOffice
Shame me all you want. I'm still in introductory courses and haven't learned enough Org-mode to use it more meaningfully.
#+BEGIN_SRC emacs-lisp
  (defun run-libreoffice ()
    "Start LibreOffice."
    (interactive)
    (start-process-shell-command
     "LibreOffice" nil "libreoffice"))
#+END_SRC
**** Transmission
#+BEGIN_SRC emacs-lisp
  (defun run-transmission ()
    "Start Transmission."
    (interactive)
    (start-process-shell-command
     "Transmission" nil "transmission-gtk"))
#+END_SRC

*** Other things a DE should probably have
**** Display setup
Calling ~arandr~ to adjust monitors is useful when I am preparing to present something using my computer or need to adjust how monitors are set up in a unique way that isn't a preset from my dotfiles.
#+BEGIN_SRC emacs-lisp
  (defun monitor-settings ()
    "Open arandr to configure monitors."
    (interactive)
    (start-process-shell-command
     "Monitor Settings" nil "arandr"))
#+END_SRC
**** Network settings
This one uses two windows: one to open the NetworkManager connection editor, and another to list WiFi networks nearby.
#+BEGIN_SRC emacs-lisp
  (defun network-settings ()
    "Open a NetworkManager connection editor."
    (interactive)
    (start-process-shell-command
     "Connections" nil "nm-connection-editor")
    (async-shell-command "nmcli dev wifi list"))
#+END_SRC
**** Volume mixer
For when you need to do volume mixing.
#+BEGIN_SRC emacs-lisp
  (defun volume-settings ()
    "Open pavucontrol to adjust volume."
    (interactive)
    (start-process-shell-command
     "Volume Mixer" nil "pavucontrol"))
#+END_SRC
**** Audio loop-back
Used when I play Jackbox Party Pack with friends. Also set up to launch ~pavucontrol~ to set up which programs to pass through to Discord.
#+BEGIN_SRC emacs-lisp
  (defun audio-loopback ()
    "Loop desktop audio into a null sink alongside the primary input."
    (interactive)
    ;; Create two modules: `loop' and `out'
    (dolist (sink '("loop"
                    "out"))
      (shell-command (concat "pacmd load-module module-null-sink sink_name=" sink))
      (shell-command (concat "pacmd update-sink-proplist "
                             sink " device.description=" sink)))
    ;; Loop `loop' to primary output, pipe it to `out', loop primary into to `out'
    (dolist (command '("sink=out"
                       "source=loop.monitor"
                       "source=loop.monitor sink=out"))
      (shell-command (concat "pacmd load-module module-loopback " command)))
    ;; Run `pavucontrol' and then unload the modules after it completes
    (start-process-shell-command
     "Audio Loop" nil (concat "pavucontrol && "
                            "pacmd unload-module module-null-sink && "
                            "pacmd unload-module module-loopback")))
#+END_SRC
**** Keyboard layout selection
This will eventually be its own package, but for now, it's just in my config. First, I set up three custom variables:
#+BEGIN_SRC emacs-lisp
  (defgroup keyboard-layout nil
    "Keyboard layouts to cycle through."
    :group 'environment)

  (defcustom keyboard-layout-1 "us"
    "The first of three keyboard layouts to cycle through.
  Set to nil to have one less keyboard layout."
    :group 'keyboard-layout
    :type 'string)

  (defcustom keyboard-layout-2 "epo"
    "The second of three keyboard layouts to cycle through.
  Set to nil to have one less keyboard layout."
    :group 'keyboard-layout
    :type 'string)

  (defcustom keyboard-layout-3 "de"
    "The third of three keyboard layouts to cycle through.
  Set to nil to have one less keyboard layout."
    :group 'keyboard-layout
    :type 'string)
#+END_SRC
Then, I use these functions to control setting and cycling the keyboard layout:
#+BEGIN_SRC emacs-lisp
  (defun get-keyboard-layout ()
    "Get the current keyboard layout."
    (shell-command-to-string
     (concat "setxkbmap -query | "
             "grep -oP 'layout:\\s*\\K(\\w+)' | "
             "tr '\n' ' ' | sed 's/ //'")))

  (defun set-keyboard-layout (&optional layout)
    "Set the keyboard layout to LAYOUT."
    (interactive)
    (let ((layout (or layout (read-string "Enter keyboard layout: "))))
      (shell-command (concat "setxkbmap " layout " -option ctrl:nocaps"))
      (message "Keyboard layout is now: %s" layout)))

  (defun cycle-keyboard-layout ()
    "Cycle between `keyboard-layout-1', `keyboard-layout-2', and `keyboard-layout-3'."
    (interactive)
    (let* ((current-layout (get-keyboard-layout))
           (new-layout (if (string= current-layout keyboard-layout-1)
                           (or keyboard-layout-2 keyboard-layout-3)
                         (if (string= current-layout keyboard-layout-2)
                             (or keyboard-layout-3 keyboard-layout-1)
                           (or keyboard-layout-1 keyboard-layout-2)))))
      (if new-layout
          (set-keyboard-layout new-layout)
        (message "No keyboard layouts selected."))))

  (defun cycle-keyboard-layout-reverse ()
    "Cycle between `keyboard-layout-1', `keyboard-layout-2', and `keyboard-layout-3' in reverse."
    (interactive)
    (let* ((current-layout (get-keyboard-layout))
           (new-layout (if (string= current-layout keyboard-layout-3)
                           (or keyboard-layout-2 keyboard-layout-1)
                         (if (string= current-layout keyboard-layout-2)
                             (or keyboard-layout-1 keyboard-layout-3)
                           (or keyboard-layout-3 keyboard-layout-2)))))
      (if new-layout
          (set-keyboard-layout new-layout)
        (message "No keyboard layouts selected."))))
#+END_SRC
**** Suspending
#+BEGIN_SRC emacs-lisp
  (defun suspend-computer ()
    (interactive)
    (when (yes-or-no-p "Really suspend? ")
      (shell-command "systemctl suspend -i")))

  (global-set-key (kbd "C-x C-M-s") 'suspend-computer)
#+END_SRC
**** Shutting down
I copied the function for quitting Emacs to handle shutting down.
#+BEGIN_SRC emacs-lisp
  (defun save-buffers-shut-down (&optional arg)
    "Offer to save each buffer, then shut down the computer.
  This function is literally just a copycat of `save-buffers-kill-emacs'.
  With prefix ARG, silently save all file-visiting buffers without asking.
  If there are active processes where `process-query-on-exit-flag'
  returns non-nil and `confirm-kill-processes' is non-nil,
  asks whether processes should be killed.
  Runs the members of `kill-emacs-query-functions' in turn and stops
  if any returns nil.  If `confirm-kill-emacs' is non-nil, calls it.
  Instead of just killing Emacs, shuts down the system."
    (interactive "P")
    ;; Don't use save-some-buffers-default-predicate, because we want
    ;; to ask about all the buffers before killing Emacs.
    (save-some-buffers arg t)
    (let ((confirm confirm-kill-emacs))
      (and
       (or (not (memq t (mapcar (function
                              (lambda (buf) (and (buffer-file-name buf)
                                          (buffer-modified-p buf))))
                             (buffer-list))))
          (progn (setq confirm nil)
                 (yes-or-no-p "Modified buffers exist; shut down anyway? ")))
       (or (not (fboundp 'process-list))
          ;; process-list is not defined on MSDOS.
          (not confirm-kill-processes)
          (let ((processes (process-list))
                active)
            (while processes
              (and (memq (process-status (car processes)) '(run stop open listen))
                 (process-query-on-exit-flag (car processes))
                 (setq active t))
              (setq processes (cdr processes)))
            (or (not active)
               (with-current-buffer-window
                (get-buffer-create "*Process List*") nil
                #'(lambda (window _value)
                    (with-selected-window window
                      (unwind-protect
                          (progn
                            (setq confirm nil)
                            (yes-or-no-p (concat "Active processes exist; kill "
                                                 "them and shut down anyway? ")))
                        (when (window-live-p window)
                          (quit-restore-window window 'kill)))))
                (list-processes t)))))
       ;; Query the user for other things, perhaps.
       (run-hook-with-args-until-failure 'kill-emacs-query-functions)
       (or (null confirm)
          (funcall confirm "Really shut down? "))
       (shell-command "shutdown now")
       (kill-emacs))))

  (global-set-key (kbd "C-x C-M-c") 'save-buffers-shut-down)
#+END_SRC
**** Rebooting
I copied the function for quitting Emacs to handle reboot too.
#+BEGIN_SRC emacs-lisp
  (defun save-buffers-reboot (&optional arg)
    "Offer to save each buffer, then shut down the computer.
  This function is literally just a copycat of `save-buffers-kill-emacs'.
  With prefix ARG, silently save all file-visiting buffers without asking.
  If there are active processes where `process-query-on-exit-flag'
  returns non-nil and `confirm-kill-processes' is non-nil,
  asks whether processes should be killed.
  Runs the members of `kill-emacs-query-functions' in turn and stops
  if any returns nil.  If `confirm-kill-emacs' is non-nil, calls it.
  Instead of just killing Emacs, shuts down the system."
    (interactive "P")
    ;; Don't use save-some-buffers-default-predicate, because we want
    ;; to ask about all the buffers before killing Emacs.
    (save-some-buffers arg t)
    (let ((confirm confirm-kill-emacs))
      (and
       (or (not (memq t (mapcar (function
                              (lambda (buf) (and (buffer-file-name buf)
                                          (buffer-modified-p buf))))
                             (buffer-list))))
          (progn (setq confirm nil)
                 (yes-or-no-p "Modified buffers exist; reboot anyway? ")))
       (or (not (fboundp 'process-list))
          ;; process-list is not defined on MSDOS.
          (not confirm-kill-processes)
          (let ((processes (process-list))
                active)
            (while processes
              (and (memq (process-status (car processes)) '(run stop open listen))
                 (process-query-on-exit-flag (car processes))
                 (setq active t))
              (setq processes (cdr processes)))
            (or (not active)
               (with-current-buffer-window
                (get-buffer-create "*Process List*") nil
                #'(lambda (window _value)
                    (with-selected-window window
                      (unwind-protect
                          (progn
                            (setq confirm nil)
                            (yes-or-no-p (concat "Active processes exist; kill "
                                                 "them and reboot anyway? ")))
                        (when (window-live-p window)
                          (quit-restore-window window 'kill)))))
                (list-processes t)))))
       ;; Query the user for other things, perhaps.
       (run-hook-with-args-until-failure 'kill-emacs-query-functions)
       (or (null confirm)
           (funcall confirm "Really reboot? "))
       (shell-command "reboot")
       (kill-emacs))))

  (global-set-key (kbd "C-x C-M-r") 'save-buffers-reboot)
#+END_SRC

** Keybindings
*** Global binds to use across everything
Anything I couldn't cram into ~desktop-environment-mode~ has been slapped into this area.
#+BEGIN_SRC emacs-lisp
  (setq exwm-input-global-keys
        `(;; Switching Workspaces
          ([?\s-q] . farl-exwm/workspace-1)
          ([?\s-w] . farl-exwm/workspace-0)
          ([?\s-e] . farl-exwm/workspace-2)

          ;; Opening X applications
          ([?\s-g]    . run-gimp)
          ([?\s-s]    . run-steam)
          ([?\s-f]    . run-firefox)
          ([?\s-d]    . run-discord)
          ([?\s-t]    . run-telegram)
          ([?\s-m]    . run-musescore)
          ([?\s-b]    . run-libreoffice)
          ([?\s-o]    . run-transmission)
          ([?\s-r]    . monitor-settings)
          ([?\s-n]    . network-settings)
          ([?\s-v]    . volume-settings)
          ([s-return] . vterm)

          ;; Other desktop environment things
          ([?\s-x]       . dmenu)
          ([menu]        . smex)
          ([?\s- ]       . cycle-keyboard-layout)
          ([s-backspace] . cycle-keyboard-layout-reverse)
          ([s-tab]       . audio-loopback)

          ;; Controlling EMMS
          ([XF86AudioNext] . emms-next)
          ([XF86AudioPrev] . emms-previous)
          ([XF86AudioPlay] . emms-pause)
          ([XF86AudioStop] . emms-stop)))
#+END_SRC

*** Emacs key bindings in X windows
This is super nice, because I love these key bindings and they are just intuitive to me, and now they can carry over safely to other programs.
#+BEGIN_SRC emacs-lisp
  (setq exwm-input-simulation-keys
        '(;; Navigation
          ([?\C-b] . [left])
          ([?\C-f] . [right])
          ([?\C-p] . [up])
          ([?\C-n] . [down])

          ([?\M-b] . [C-left])
          ([?\M-f] . [C-right])
          ([?\M-p] . [C-up])
          ([?\M-n] . [C-down])

          ([?\C-a] . [home])
          ([?\C-e] . [end])
          ([?\C-v] . [next])
          ([?\M-v] . [prior])

          ;; Copy/Paste
          ([?\C-w] . [?\C-x])
          ([?\M-w] . [?\C-c])
          ([?\C-y] . [?\C-v])
          ([?\C-s] . [?\C-f])
          ([?\C-\/] . [?\C-z])

          ;; Other
          ([?\C-d] . [delete])
          ([?\C-k] . [S-end delete])
          ([?\C-g] . [escape])))

  ;; I can't do sequences above, so this is separate
  (defun exwm-C-s ()
    "Pass C-s to the EXWM window."
    (interactive)
    (execute-kbd-macro (kbd "C-q C-s")))

  (define-key exwm-mode-map (kbd "C-x C-s") 'exwm-C-s)
#+END_SRC

*** Send a key verbatim more easily
#+BEGIN_SRC emacs-lisp
  (define-key exwm-mode-map (kbd "C-c C-q") nil)
  (define-key exwm-mode-map (kbd "C-q") 'exwm-input-send-next-key)
#+END_SRC

*** Inhibit things I don't use
This includes:
- Toggling fullscreen
- Toggling floating
- Toggling hiding
- Toggling the mode line
#+BEGIN_SRC emacs-lisp
  (dolist (key '("C-c C-t C-f"
                 "C-c C-t C-v"
                 "C-c C-t C-m"
                 "C-c C-f"))
    (define-key exwm-mode-map (kbd key) nil))
#+END_SRC

** On startup
*** Always hide the cursor when typing
Just a personal preference, I don't like seeing the cursor when I'm pressing keys.
#+BEGIN_SRC emacs-lisp
  (start-process-shell-command
   "Cursor Hiding" nil "xbanish")
#+END_SRC

*** Disable screen blanking
I don't need my laptop's screen shutting off just because I'm sitting and watching a video too long.
#+BEGIN_SRC emacs-lisp
  (start-process-shell-command
   "Disable Blanking" nil "xset s off -dpms")
#+END_SRC

*** Keyboard configuration
This block sets the keyboard layout to US and give Caps Lock the functionality of Control. I was hesitant to do this at first, but it's significantly more comfortable. I almost never used caps lock as it is, given my keyboards have no indicator for it on my laptops, but this gives me a much easier way to do commands without shifting my hand too far.
#+BEGIN_SRC emacs-lisp
  (start-process-shell-command
   "Keyboard Layout" nil "setxkbmap us -option ctrl:nocaps")
#+END_SRC

*** Set fallback cursor
Some X windows will have weird cursors if this isn't done.
#+BEGIN_SRC emacs-lisp
  (start-process-shell-command
   "Fallback Cursor" nil "xsetroot -cursor_name left_ptr")
#+END_SRC

*** Compositor
I don't need it, but having basic compositing is very nice.
#+BEGIN_SRC emacs-lisp
  (start-process-shell-command
   "Compositor" nil "xcompmgr")
#+END_SRC

*** Start EXWM
#+BEGIN_SRC emacs-lisp
  (exwm-enable)
  (exwm-config-ido)
  (exwm-systemtray-enable)
#+END_SRC
With that out of the way, we can close off this block and move on to the next section.
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

* Making Emacs organize/play music
I am big on doing as much in Emacs as possible. Having my music player moved to Emacs was a HUGE step. When I first started using it, it was weird, but now I have come to absolutely love it. We only configure EMMS if ~mpd~ is found.
#+BEGIN_SRC emacs-lisp
  (when (executable-find "mpd")
#+END_SRC

** Installing EMMS
All I do here is configure EMMS. Binding keys is later.
#+BEGIN_SRC emacs-lisp
  (use-package emms
    :ensure t
    :defer t
    :init
    (require 'emms-setup)
    (require 'emms-player-mpd)
    (emms-all)
    (setq emms-seek-seconds 5
	  emms-player-list '(emms-player-mpd)
	  emms-info-functions '(emms-info mpd)
	  emms-player-mpd-server-name "localhost"
	  emms-player-mpd-server-port "6601"
	  mpc-host "localhost:6601"))
#+END_SRC

** Daemon functions
*** Starting the daemon
#+BEGIN_SRC emacs-lisp
  (defun mpd/start-music-daemon ()
    "Start MPD, connect to it and sync the metadata cache"
    (interactive)
    (shell-command "mpd")
    (mpd/update-database)
    (emms-player-mpd-connect)
    (emms-cache-set-from-mpd-all)
    (message "MPD started!"))
#+END_SRC

*** Stopping the daemon
#+BEGIN_SRC emacs-lisp
  (defun mpd/kill-music-daemon ()
    "Stop playback and kill the music daemon."
    (interactive)
    (emms-stop)
    (call-process "killall" nil nil nil "mpd")
    (message "MPD killed!"))
#+END_SRC

*** Updating the database
#+BEGIN_SRC emacs-lisp
  (defun mpd/update-database ()
    "Update the MPD database synchronously."
    (interactive)
    (call-process "mpc" nil nil nil "update")
    (message "MPD database updated!"))
#+END_SRC

*** Shuffling the playlist
#+BEGIN_SRC emacs-lisp
  (defun farl-emms/shuffle-with-message ()
    "Shuffle the playlist and say so in the echo area."
    (interactive)
    (emms-shuffle)
    (message "Playlist has been shuffled."))
#+END_SRC

** Binding all the keys
Now using a keymap in place of that wonky as crap binding system. The new binds let me use ~emms~ in a terminal.
#+BEGIN_SRC emacs-lisp
  (defvar emms-map
    (let ((map (make-sparse-keymap)))
      ;; Opening playlist and music browser
      (define-key map (kbd "v") 'emms)
      (define-key map (kbd "b") 'emms-smart-browse)
      ;; Track navigation
      (define-key map (kbd "n n") 'emms-next)
      (define-key map (kbd "n p") 'emms-previous)
      (define-key map (kbd "p") 'emms-pause)
      (define-key map (kbd "s") 'emms-stop)
      ;; Repeat/shuffle
      (define-key map (kbd "t C-r") 'emms-toggle-repeat-track)
      (define-key map (kbd "t r") 'emms-toggle-repeat-playlist)
      (define-key map (kbd "t s") 'farl-emms/shuffle-with-message)
      ;; Refreshing various things
      (define-key map (kbd "r c") 'emms-player-mpd-update-all-reset-cache)
      (define-key map (kbd "r d") 'mpd/update-database)
      ;; mpd specific functions
      (define-key map (kbd "d s") 'mpd/start-music-daemon)
      (define-key map (kbd "d q") 'mpd/kill-music-daemon)
      (define-key map (kbd "d u") 'mpd/update-database)
      map)
    "A keymap for controlling `emms'.")
  (global-set-key (kbd "C-c a") emms-map)
#+END_SRC

With EMMS now configured, we can close off this block and move on.
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

* Making Emacs a good text editor
This used to be a mess of different sections, but I've been working to categorize these settings far better. So, much of what was previously elsewhere is now set up in here. Everything in here /should/ be about making Emacs pleasant to use for editing text of various kinds. If it isn't, I have failed.
** Additional major modes
These are modes that enable Emacs to edit different kinds of files differently. Programming major modes are further down, in the programming section.

*** ~graphviz-dot-mode~ (diagram creation)
A nice way to make diagrams.
#+BEGIN_SRC emacs-lisp
  (use-package graphviz-dot-mode
    :ensure t
    :defer t
    :init
    (require 'graphviz-dot-mode))
#+END_SRC

*** ~markdown-mode~ (bootleg org-mode for GitHub)
I really don't like markdown but I have to use it for school, so...
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :defer t)
#+END_SRC

** General functionality
These settings are changes to core functionality more than they are changes that affect editing files.

*** Use UTF-8 encoding
This makes for a much easier time editing files and working with text.
#+BEGIN_SRC emacs-lisp
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC

*** Disable suspending Emacs
Why is this even something bound to begin with?
#+BEGIN_SRC emacs-lisp
  (dolist (key '("C-x C-z"
                 "C-z"))
    (global-unset-key (kbd key)))
#+END_SRC

*** Always confirm closing Emacs
I constantly kill Emacs on accident when running it in terminals, so this prevents me from doing that +as easily+.
#+BEGIN_SRC emacs-lisp
  (setq confirm-kill-emacs 'yes-or-no-p)
#+END_SRC

*** Open configuration with =C-c e=
Since this thing is changing all the time, I really like having it available on a shortcut.
#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    "Open the configuration file."
    (interactive)
    (find-file (concat user-emacs-directory "literate-emacs.org")))

  (global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC

*** Don't unload fonts when not in use
This solves a number of hanging issues related to a number of different packages and symbols.
#+BEGIN_SRC emacs-lisp
  (setq inhibit-compacting-font-caches t)
#+END_SRC

*** Make scrolling a little less crazy
Not sure why the mouse wheel get acceleration, but thankfully I don't have to worry about that anymore.
#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 0
        auto-window-vscroll nil
        scroll-conservatively 100000
        scroll-preserve-screen-position 1
        mouse-wheel-scroll-amount '(1 ((shift) . 1))
        mouse-wheel-progressive-speed nil
        mouse-wheel-follow-mouse t)
#+END_SRC

*** Change current directory with =C-c d=
Useful for getting lost in the filesystem!
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c d") 'cd)
#+END_SRC

*** Enable word wrapping for all buffers
This is a point of convenience, even in programming language buffers. Wrapping words makes for a heck of a lot more readability of any kind of text, whether a program or just normal language.
#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode 1)
#+END_SRC

*** Use a visual bell instead of making noise
Sound is obnoxious and it should be visibly obvious without flashing the frame or mode line that something has gone wrong.
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore
        visible-bell t)
#+END_SRC

*** ~which-key~ (small menus to help with commands)
Even as I've gotten used to Emacs key bindings, it is always nice to have this around so that if I want to know, I can easily see what's what.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :defer t
    :init
    (which-key-mode 1))
#+END_SRC

*** Replace "yes or no" prompts with "y or n" prompts
Beauty in brevity.
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Enable ~ido-mode~, install ~ido-vertical-mode~ and ~smex~
I /love/ ~ido-mode~. However, I /HATE/ ~ido-mode~ right out of the box. A vertical list looks craptons nicer. Both ~ido-mode~ and ~ido-vertical-mode~ are configured in the same block. Default M-x behavior doesn't use ~ido-mode~, so we install a package which gives it ~ido-mode~ capabilities.
#+BEGIN_SRC emacs-lisp
  (use-package ido-vertical-mode
    :ensure t
    :defer t
    :init
    (setq ido-everywhere t
          ido-max-prospects 10
          ido-enable-prefix nil
          ido-enable-flex-matching t
          ido-use-filename-at-point nil
          ido-create-new-buffer 'always
          ido-vertical-define-keys 'C-n-and-C-p-only)
    (ido-mode 1)
    (ido-vertical-mode 1)
    (use-package smex
      :ensure t
      :defer t
      :bind (("M-x"    . smex)
             ("<menu>" . smex))))
#+END_SRC

** Personal save hooks
When I save a file, sometimes I want specific things to be done.

*** Tangle literate programming files
I've gotten really into literate programming lately, so this makes it much easier to tangle files.
#+BEGIN_SRC emacs-lisp
  (defun tangle-literate-program ()
    "Tangle a file if it's a literate programming file."
    (interactive)
    (when (and (equal major-mode 'org-mode)
             (cl-search "literate" (buffer-file-name)))
      (org-babel-tangle)))

  (add-hook 'after-save-hook 'tangle-literate-program)
#+END_SRC

** Buffers/windows
*** Sloppy focus windows
I hate having to click to focus a different window, so I would rather just have windows sloppily focus.
#+BEGIN_SRC emacs-lisp
  (setq focus-follows-mouse t
        mouse-autoselect-window t)
#+END_SRC

*** Making buffer names unique
This looks a lot fancier than the default behavior.a
#+BEGIN_SRC emacs-lisp
  (setq uniquify-buffer-name-style 'forward
        uniquify-after-kill-buffer-p t)
#+END_SRC

*** Open dashboard with =C-c M-d=
I constantly accidentally close dashboard, so I made a way to open it again if I accidentally kill it.
#+BEGIN_SRC emacs-lisp
  (defun dashboard-restart ()
    "Restart the dashboard buffer and switch to it."
    (interactive)
    (dashboard-insert-startupify-lists)
    (switch-to-buffer "*dashboard*"))

  (global-set-key (kbd "C-c M-d") 'dashboard-restart)
#+END_SRC

*** Balance window sizes with =C-c b=
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c b") 'balance-windows)
#+END_SRC

*** Kill the current buffer with =C-x k=
I had to adjust the function which kills both the current buffer and the current window, because it did not cooperate with EXWM buffers. That's why I have this weird chunk I don't actually have the expertise yet to fully parse.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x k") 'kill-this-buffer)
#+END_SRC

*** Kill both the buffer and window with =C-x C-k=
#+BEGIN_SRC emacs-lisp
  (defun kill-this-buffer-and-window ()
    "Kill the current buffer and delete the selected window.

  This function has been altered to accommodate EXWM."
    (interactive)
    (let ((window-to-delete (selected-window))
          (buffer-to-kill (current-buffer))
          (delete-window-hook (lambda () (ignore-errors (delete-window)))))
      (unwind-protect
          (progn
            (add-hook 'kill-buffer-hook delete-window-hook t t)
            (if (kill-buffer (current-buffer))
                ;; If `delete-window' failed before, we repeat
                ;; it to regenerate the error in the echo area.
                (when (eq (selected-window) window-to-delete)
                  (delete-window)))))))

  (global-set-key (kbd "C-x C-k") 'kill-this-buffer-and-window)
#+END_SRC

*** Kill all buffers and all windows with =C-x C-M-k=
I wanted a way to quickly and gracefully destroy everything that is open at once.
#+BEGIN_SRC emacs-lisp
  (defun close-buffers-and-windows ()
    "Close every buffer and close all windows, then restart dashboard."
    (interactive)
    (unless (save-some-buffers)
      (when (yes-or-no-p "Really kill all buffers? ")
        (mapc 'kill-buffers (buffer-list))
        (delete-other-windows)
        (dashboard-restart))))

  (global-set-key (kbd "C-x C-M-k") 'close-buffers-and-windows)
#+END_SRC

*** Make the scratch buffer immortal and start blank
I kill the scratch buffer way too often if I don't do this. While I'm here, I might as well also make the scratch buffer blank.
#+BEGIN_SRC emacs-lisp
  (with-current-buffer "*scratch*"
    (emacs-lock-mode 'kill))

  (setq initial-scratch-message "")
#+END_SRC

*** ~buffer-move~ (moving windows) and ~windmove~ (changing focus)
Since apparently =C-x C-o= is actually something useful by default, I decided to squash ~windmove~ and ~buffer-move~ into a single keymap.
#+BEGIN_SRC emacs-lisp
  (use-package buffer-move
    :ensure t
    :defer t
    :init
    (defvar buffer-move-and-windmove-map
      (let ((map (make-sparse-keymap)))
        (define-key map (kbd "w") 'windmove-up)
        (define-key map (kbd "a") 'windmove-left)
        (define-key map (kbd "s") 'windmove-down)
        (define-key map (kbd "d") 'windmove-right)
        (define-key map (kbd "C-w") 'buf-move-up)
        (define-key map (kbd "C-a") 'buf-move-left)
        (define-key map (kbd "C-s") 'buf-move-down)
        (define-key map (kbd "C-d") 'buf-move-right)
        map)
      "A keymap for `buffer-move' and `windmove' functions.")
    (global-set-key (kbd "C-x o") buffer-move-and-windmove-map))
#+END_SRC

*** Move focus and show buffer-menu when explicitly creating new windows
This to me is preferable to the default behavior.
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-vertical ()
    "Open a new window vertically."
    (interactive)
    (split-window-below)
    (other-window 1)
    (ibuffer))

  (defun split-and-follow-horizontal ()
    "Open a new window horizontally."
    (interactive)
    (split-window-right)
    (other-window 1)
    (ibuffer))

  (global-set-key (kbd "C-x 2") 'split-and-follow-vertical)
  (global-set-key (kbd "C-x 3") 'split-and-follow-horizontal)
#+END_SRC

*** Use buffer-menu on =C-x b= so the buffer list doesn't open a new window
Just another point of personal convenience.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x b") 'ibuffer)
  (global-unset-key (kbd "C-x C-b"))
#+END_SRC

** Text editing
These settings are specifically about editing text and making that easier.

*** Spell-checking
Just a useful little tool to check spelling while editing a buffer. Only configured if ~aspell~ is installed. It's not super great, but it does the trick well enough for me.
#+BEGIN_SRC emacs-lisp
  (when (executable-find "aspell")
    (require 'flyspell)

    (setq ispell-program-name "aspell"
          ispell-dictionary "american")

    (add-hook 'flyspell-mode-hook 'flyspell-buffer)
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)
    (add-hook 'text-mode-hook 'flyspell-mode))
#+END_SRC

*** Better search behavior
This search behavior is *SO* much nicer than the default.
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :defer t
    :bind ("C-s" . swiper))
#+END_SRC

*** No backups or auto-saving
I love living on the edge.
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil
        auto-save-default nil)
#+END_SRC

*** Automatically revert files on change
This way if files get modified in the middle of editing them, I don't overwrite the changes. This can also change ~dired~ and ~ibuffer~ buffers if I am not mistaken. However, I don't need to hear every last thing about it.
#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode 1)
  (setq global-auto-revert-non-file-buffers t
        auto-revert-remote-files t
        auto-revert-verbose nil)
#+END_SRC

*** End-of-file newlines and indent tabs
Screw indent tabs, spaces all the way. Also, if there is no end-of-file newline, add it.
#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)
  (setq-default indent-tabs-mode nil)
#+END_SRC

*** Manage the kill ring using a pop-up menu
Having the whole kill ring easy to scroll through is much less hassle than default behavior. We also set up some yanking behavior while we're at it.
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :defer t
    :bind ("M-y" . popup-kill-ring)
    :init
    (setq save-interprogram-paste-before-kill t
          mouse-drag-copy-region t
          mouse-yank-at-point t))
#+END_SRC

*** Delete whatever is selected if typing starts
This is to reflect behavior in other programs.
#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC

*** Hungrily remove all whitespace when deleting
This saves me tons of time when it comes to managing whitespace. Instead of having to repeatedly press delete or backspace, a single keystroke decimates all the whitespace between the point and whatever is in the direction the deletion happens.
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :ensure t
    :defer t
    :init
    (global-hungry-delete-mode 1))
#+END_SRC

*** Move around visible portions of files faster
If I want to hop around in a document without calling swiper, ~avy~ is definitely the way to go.
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :defer t
    :bind ("M-s" . avy-goto-char))
#+END_SRC

*** Move between SubWords as well as between words
This allows for much easier navigation between words when in programming language buffers, but also has utility outside of programming so it's enabled globally.
#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC

*** electric-pair-mode (OH MY GOD THIS IS SO GREAT)
I have no words for how convenient this has been and how much faster I get things done thanks to these five lines of elisp.
#+BEGIN_SRC emacs-lisp
  (setq electric-pair-pairs '((?\{ . ?\})
                              (?\( . ?\))
                              (?\[ . ?\])
                              (?\" . ?\")))
  (electric-pair-mode 1)
  (minibuffer-electric-default-mode 1)
#+END_SRC

*** Kill an entire word when you're in the middle of it
I don't need it super often, but it's still nice to have.
#+BEGIN_SRC emacs-lisp
  (defun whole-kill-word ()
    "Delete an entire word."
    (interactive)
    (backward-word)
    (kill-word 1))

  (global-set-key (kbd "C-c DEL") 'whole-kill-word)
#+END_SRC

*** Edit files with superuser privileges using =C-x C-M-f=
This is especially useful when I'm in my own desktop environment and need to edit system files.
#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :ensure t
    :defer t
    :bind ("C-x C-M-f" . sudo-edit))
#+END_SRC

** Programming
It's slowly growing, but I still truly do not need all that much when it comes to programming, mostly because I don't actually do all that much programming outside what I do for fun... and editing this file.

*** Use SBCL for inferior LISP mode
#+BEGIN_SRC emacs-lisp
  (setq inferior-lisp-program "sbcl")
#+END_SRC

*** ~magit~ (git but in Emacs)
I used to use a terminal for this, but holy crap this is a lot easier, a lot faster, and a whole lot nicer to use overall.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :defer t
    :bind ("C-c g" . magit-status))
#+END_SRC

*** Autocomplete backend
This is the base package. I changed some key bindings to make it more pleasant to use.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :defer t
    :init
    (setq company-idle-delay 0.75
          company-minimum-prefix-length 3)
    (global-company-mode 1)
    :bind (:map company-active-map
           ("M-n" . nil)
           ("M-p" . nil)
           ("C-n" . company-select-next)
           ("C-p" . company-select-previous)
           ("SPC" . company-abort)))
#+END_SRC

*** ~haskell-mode~
I have started to mess around with Haskell, so I needed to grab a mode for that. This supplies basically everything I need as far as I know, e.g. company autocompletion and flycheck information.
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure t
    :defer t
    :init
    (setq haskell-stylish-on-save t)
    :hook ((haskell-mode . interactive-haskell-mode)
           (haskell-mode . turn-on-haskell-doc-mode)
           (haskell-mode . haskell-indentation-mode)
           (haskell-mode . haskell-auto-insert-module-template)))
#+END_SRC

*** Python autocomplete
#+BEGIN_SRC emacs-lisp
  (use-package company-jedi
    :ensure t
    :defer t
    :init
    (add-to-list 'company-backends 'company-jedi))
#+END_SRC

*** On-the-fly syntax checking
This is nice to have so I can be told right away when I'm doing something wrong.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :defer t
    :init
    (global-flycheck-mode 1))
#+END_SRC

*** ~avy~-style navigation but between syntax errors
This one is *SUPER COOL*. Being able to jump straight to a problem is really useful.
#+BEGIN_SRC emacs-lisp
  (use-package avy-flycheck
    :ensure t
    :defer t
    :bind (:map prog-mode-map
           ("C-c C-'" . avy-flycheck-goto-error)))
#+END_SRC

** Org-mode
As I spend more time in Org-mode, the more I need from it.

*** Fancier bullet points
It's kinda slow, but bullet points are very very nice, much better than asterisks.
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :if window-system
    :ensure t
    :defer t
    :hook (org-mode . org-bullets-mode))
#+END_SRC

*** Presentations in Emacs
It's gonna need more polish, but it works.
#+BEGIN_SRC emacs-lisp
  (use-package epresent
    :if window-system
    :ensure t
    :defer t
    :bind (:map org-mode-map
           ("C-c r" . epresent-run)))
#+END_SRC

*** Quality-of-life settings
These are just quick things that make ~org-mode~ much easier to use.
#+BEGIN_SRC emacs-lisp
  (setq org-pretty-entities t
        org-src-fontify-natively t
        org-agenda-use-time-grid nil
        org-fontify-done-headline t
        org-src-tab-acts-natively t
        org-enforce-todo-dependencies t
        org-fontify-whole-heading-line t
        org-agenda-skip-deadline-if-done t
        org-agenda-skip-scheduled-if-done t
        org-fontify-quote-and-verse-blocks t
        org-src-window-setup 'current-window
        org-highlight-latex-and-related '(latex)
        org-ellipsis (if window-system "⤵" "...")
        org-hide-emphasis-markers (when window-system t))
#+END_SRC

*** Evaluating Graphviz blocks
Since obviously dot snippets are purely harmless +as far as I know+, I just don't bother with having to confirm evaluation every time I try to update a graphic.
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages 'org-babel-load-languages '((dot . t)))
  (setq org-confirm-babel-evaluate '(lambda (lang body) (not (eq lang "dot"))))
#+END_SRC

*** Shortcuts for various snippets in org-mode
This will expand as I get into more and more languages and take more notes in classes with different snippets of different languages.
#+BEGIN_SRC emacs-lisp
  (dolist (shortcut
           '(("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC")
             ("py" "#+BEGIN_SRC python\n?\n#+END_SRC")
             ("dot" "#+BEGIN_SRC dot :file ?.png :cmdline -Kdot -Tpng\n\n#+END_SRC")
             ("t" "#+BEGIN_SRC text :tangle ?\n\n#+END_SRC")
             ("css" "#+BEGIN_SRC css\n?\n#+END_SRC")))
    (add-to-list 'org-structure-template-alist shortcut))
#+END_SRC

*** Agenda (only enabled if an agenda is found)
I use =C-c M-a= and =C-c s-a= to do things related to my agenda. Only one of my systems actually has my agenda, so this only runs on that machine so I don't try any funny business on other machines.
#+BEGIN_SRC emacs-lisp
  (when (file-exists-p "~/agenda.org")
    (setq org-agenda-files '("~/agenda.org"))

    (defun open-agenda ()
      "Open the agenda file."
      (interactive)
      (find-file "~/agenda.org"))

    (global-set-key (kbd "C-c M-a") 'org-agenda)
    (global-set-key (kbd "C-c s-a") 'open-agenda))
#+END_SRC

*** Use the current window when editing source blocks
This is just a convenience thing.
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC

*** Automatically fix inline images generated for diagrams
This is exactly what I was looking for lmao
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
#+END_SRC

* Making Emacs =e x t e n d=
If it isn't about editing text, playing music, or being my entire desktop environment, it will most likely be found in this section.
** Built-in features
*** Calendar
Weeks start on Monday.
#+BEGIN_SRC emacs-lisp
  (setq calendar-week-start-day 1)
  (global-set-key (kbd "C-c l") 'calendar)
#+END_SRC

*** Calculator
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c c") 'calc)
#+END_SRC

*** Reading the manpages
Wow, there's actually an Emacs mode for this! I put it into the =C-h= binds, since it is a way of getting help, after all.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-h 4 m") 'man)
#+END_SRC

** Not built-in
*** Emacs as a terminal
I've been jumping between ~vterm~ and ~ansi-term~. I guess ~vterm~ is just easier to use. In the off-chance I'm running Emacs in the terminal, =C-c t= is usable to open ~vterm~.
#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :ensure t
    :defer t
    :bind ("C-c t" . vterm))
#+END_SRC

*** Reading ebooks in Emacs
Not the best way to do epub reading, but at least it's in Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package nov
    :ensure t
    :defer t
    :mode ("\\.epub\\'" . nov-mode))
#+END_SRC

*** Getting the weather using Emacs
Picking a service to use for this was a pain. I ended up settling for wttrin because it is the fastest and easiest to use, and plays nice with my setup.
#+BEGIN_SRC emacs-lisp
  (use-package wttrin
    :ensure t
    :defer t
    :init
    (setq wttrin-default-cities '("Indianapolis"))
    :bind ("C-c w" . wttrin))
#+END_SRC

** Games
To make running games easier, I set up a keymap to which I add the games.
#+BEGIN_SRC emacs-lisp
  (defvar games-map
    (make-sparse-keymap)
    "A keymap to which games can be added.")

  (global-set-key (kbd "C-M-g") games-map)
#+END_SRC

*** Chess
Just for fun. I suck at chess but it's nice to have.
#+BEGIN_SRC emacs-lisp
  (use-package chess
    :ensure t
    :defer t
    :bind (:map games-map
           ("c" . chess)))
#+END_SRC

*** Sudoku
I /love/ sudoku puzzles.
#+BEGIN_SRC emacs-lisp
  (use-package sudoku
    :ensure t
    :defer t
    :bind (:map games-map
           ("s" . sudoku)))
#+END_SRC

*** Tetris
Tetris is my childhood. No way I wouldn't set it up to be nice and comfy.
#+BEGIN_SRC emacs-lisp
  (use-package tetris
    :ensure t
    :defer t
    :bind (:map games-map
           ("t" . 'tetris)
           :map tetris-mode-map
           ("w" . tetris-move-bottom)
           ("a" . tetris-move-left)
           ("s" . tetris-mode-down)
           ("d" . tetris-move-right)
           ([left] . tetris-rotate-next)
           ([right] . tetris-rotate-prev)
           ([?\t] . tetris-pause-game)
           ("r" . tetris-start-game)
           ("e" . tetris-end-game)))
#+END_SRC

*** 2048
A simple and fun game. Was a big deal when I was in high school. I still play it from time to time.
#+BEGIN_SRC emacs-lisp
  (use-package 2048-game
    :ensure t
    :defer t
    :bind (:map games-map
           ("2" . 2048-game)))
#+END_SRC

* Giving ~init.el~ a footer
Since we gave ~init.el~ a header, I see no reason not to give it a footer.
#+BEGIN_SRC emacs-lisp
  ;;; init.el ends here
#+END_SRC
